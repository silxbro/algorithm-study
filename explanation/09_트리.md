# 트리
<br/>

# 목차
1. [트리 알아보기](#1-트리-알아보기)
2. [트라이](#2-트라이)
3. [이진 트리](#3-이진-트리)
4. [세그먼트 트리](#4-세그먼트-트리)
5. [최소 공통 조상](#5-최소-공통-조상)
<br/>

# 1. 트리 알아보기
- **`트리(tree)`** 는 노드와 에지로 연결된 **그래프의 특수한 형태**로, 주요 특징은 다음과 같다.
## (1) 트리의 특징
- **순환 구조(cycle)를 지니고 있지 않고**, **1개의 `루트 노드`** 가 존재한다.
- 루트 노드를 제외한 노드는 **단 1개의 부모 노드**를 갖는다.
-  트리의 **`부분 트리(subtree)`** 역시 트리의 모든 특징을 따른다.
## (2) 트리의 구성 요소
|구성 요소|설명|
|:---|:---|
|**노드**&nbsp;&nbsp;|데이터의 index와 value를 표현하는 요소|
|**에지**&nbsp;&nbsp;|노드와 노드의 연결 관계를 나타내는 선|
|**루트 노드**&nbsp;&nbsp;|트리에서 **가장 상위**에 존재하는 노드|
|**부모 노드**&nbsp;&nbsp;|두 노드 사이의 관계에서 상위 노드에 해당하는 노드|
|**자식 노드**&nbsp;&nbsp;|두 노드 사이의 관계에서 하위 노드에 해당하는 노드|
|**리프 노드**&nbsp;&nbsp;|트리에서 **가장 하위**에 존재하는 노드(**자식 노드가 없는** 노드)|
|**서브 트리**&nbsp;&nbsp;|전체 트리에 속한 작은 트리|

### [문제 067] : 트리의 부모 찾기 (1s)
  ### 문제
  - 루트 없는 트리가 주어진다. 이때 트리의 루트를 1이라고 정했을 때 각 노드의 부모를 구하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 노드의 개수 N(2≤N≤100,000), 2번째 줄부터 N-1개의 줄에 트리상에 연결된 두 노드가 주어진다.
  ### 출력
  - 1번째 줄부터 N-1개의 줄에 각 노드의 부모 노드 번호를 2번 노드부터 순서대로 출력한다.
  ### 예제 입력1
  ```java
  7   // 노드 개수
  1 6
  6 3
  3 5
  4 1
  2 4
  4 7
  ```
  ### 예제 출력1
  ```java
  4
  6
  1
  3
  1
  4
  ```
  ### 예제 입력2
  ```java
  12
  1 2
  1 3
  2 4
  3 5
  3 6
  4 7
  4 8
  5 9
  5 10
  6 11
  6 12
  ```
  ### 예제 출력2
  ```java
  1
  1
  2
  3
  3
  4
  4
  5
  5
  6
  6
  ```
  ### [1단계] 문제 분석하기
  - 주어지는 데이터가 단순하게 연결돼 있는 두 노드를 알려 주는 것이므로 데이터를 저장할 때 양방향 에지로 간주하고 저장한다. 인접 리스트 자료구조를 사용하면 간편하게
    데이터를 저장할 수 있다. 트리의 루트가 1이라고 지정돼 있기 때문에 1번 노드부터 DFS로 탐색하면서 부모 노드를 찾아 주면 문제를 쉽게 해결할 수 있다.
  ### [2단계] 손으로 풀어보기
  1. 인접 리스트로 트리 데이터를 구현한다.
  2. DFS 탐색을 수행한다. 수행할 때는 부모 노드의 값을 정답 배열에 저장한다.
  3. 정답 배열의 2번 인덱스부터 값을 차례대로 출력한다.
  - 트리는 그래프 자료구조 중 하나의 형태이므로 그래프를 구현하는 방식을 사용할 수도 있고, 탐색 역시 그래프 탐색 알고리즘을 사용할 수 있다는 것을 생각해 볼 수 있다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(노드 개수)
  tree(트리 데이터 저장 인접 리스트)
  visited(방문 기록 저장 배열)
  answer(부모 노드 저장 정답 배열)
  for (N의 개수만큼 반복하기) {
    tree 인접 리스트의 각 ArrayList 초기화하기
  }
  for (N-1의 개수만큼 반복하기) {
    tree 인접 리스트에 트리 데이터 저장하기
  }
  1번 노드부터 DFS 실행하기
  for (2~N 반복하기) {
    answer 배열 출력하기
  }
  // DFS 구현하기
  DFS {
    visied 배열에 현재 노드 방문 기록하기
    if(현재 노드의 연결 노드 중 방문하지 않은 노드) {
      부모 노드 저장하기
      DFS 실행하기(재귀 함수 형태)
    }
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam067_트리의부모찾기](src/book/ch09/exam067_트리의부모찾기.java)
### [문제 068] : 리프 노드의 개수 구하기 (2s)
  ### 문제
  - 트리에서 리프 노드는 자식의 개수가 0인 노드를 말한다. 노드를 지우면 그 노드와 노드의 모든 자손이 트리에서 제거된다.<br/>
    주어진 트리에서 노드 1개를 지울 때 남은 트리에서 리프 노드의 개수를 구하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 트리의 노드의 개수 N이 주어진다. N은 50보다 작거나 같은 자연수다. 2번째 줄에 0번 노드부터 N-1번 노드까지 각 노드의 부모가 주어진다. 만약 부모 노드가
    없다면 루트 노드 - 1이 주어진다. 3번째 줄에는 지울 노드의 번호가 주어진다.
  ### 출력
  - 1번째 줄에 입력으로 주어진 트리에서 입력으로 주어진 노드를 지웠을 때 남아 있는 리프 노드의 개수를 출력한다.
  ### 예제 입력1
  ```java
  9   // 노드 개수
  -1 0 0 2 2 4 4 6 6
  4   // 삭제 노드
  ```
  ### 예제 출력1
  ```java
  2
  ```
  ### [1단계] 문제 분석하기
  - 이 문제의 핵심은 '리프 노드를 어떻게 제거하는가?'이다. 리프 노드를 탐색하는 탐색 알고리즘을 수행할 때나 제거하는 노드가 나왔을 때 탐색을 종료하는 아이디어를 적용하면
    실제 리프 노드를 제거하는 효과를 낼 수 있다.
  ### [2단계] 손으로 풀어보기
  1. 인접 리스트로 트리 데이터를 구현한다.
  2. DFS 또는 BFS 탐색을 수행하면서 리프 노드의 개수를 센다. 단, 제거 대상 노드를 만났을 때는 그 아래 자식 노드들과 관련된 탐색은 중지한다. 이는 제거한 노드의 범위에서
     리프 노드를 제거하는 효과가 있다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(노드 개수)
  tree(트리 데이터 저장 인접 리스트)
  visited(방문 기록 저장 배열)
  answer(리프 노드 개수 저장 변수)
  deleteNode(삭제 노드)
  for (N의 개수만큼 반복하기) {
    tree 인접 리스트의 각 ArrayList 초기화하기
  }
  for (N의 개수만큼 반복하기) {
    if (루트 노드가 아닌 경우)
      tree 인접 리스트에 트리 데이터 저장하기
    else
      루트 노드값 저장하기
  }
  삭제 노드값 저장하기
  if (삭제 노드값이 0) 모두 삭제되므로 0을 출력하고 프로세스 끝냄
  else DFS(root)   // 루트 노드부터 DFS 실행하기
    answer 출력하기
  // DFS 구현하기
  DFS {
    방문 배열에 현재 노드 방문 기록하기
    for (연결 노드 탐색하기) {
      현재 노드의 연결 노드 중 방문하지 않은 노드이고 삭제 노드가 아닐 때
        자식 노드 개수 증가
        DFS 실행하기(재귀 함수 형태)
    }
    만약 자식 노드 개수가 0이면 answer 변수 증가
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam068_리프노드](src/book/ch09/exam068_리프노드.java)
  

# 2. 트라이
- **`트라이(trie)`** 는 **문자열 검색**을 빠르게 실행할 수 있도록 설계한 트리 형태의 자료구조이다.
## 트라이의 핵심 이론
- 트라이는 일반적으로 단어들을 **사전의 형태**로 생성한 후 트리의 부모 자식 노드 관계를 이용하여 검색을 수행한다.
  ### 트라이의 특징
  - **N진 트리** : **문자 종류의 개수에 따라 N이 결정된다.** 예를 들어 알파벳은 26개의 문자로 이뤄져 있으므로 26진 트리로 구성된다.
  - **루트 노드**는 항상 빈 문자열을 뜻하는 **공백 상태**를 유지한다.
  - (ex) 영단어 apple, air, apply를 순서대로 트라이 자료구조에 삽입하는 경우
    - 먼저 루트 노드는 공백을 유지하고 apple의 각 알파벳에 해당하는 노드를 생성한다. 그다음으로 air를 삽입할 때는 루트 노드에서부터 검색한다. a 노드는 공백 상태가
      아니므로 이동하고, i와 r은 공백 상태이므로 신규 노드를 생성한다. apply를 삽입할 때도 **검색 노드가 공백 상태이면 신규 노드를 생성하고, 아니면 이동하는 원리**로
      트라이 자료구조를 구현한다.
### [문제 069] : 문자열 찾기 (2s)
  ### 문제
  - 총 N개의 문자열로 이뤄진 집합 S가 있다. 입력으로 주어지는 M개의 문자열 중 집합 S에 포함돼 있는 것이 총 몇 개인지 구하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 문자열의 개수 N과 M(1≤N≤10,000, 1≤M≤10,000)이 주어진다. 그다음 N개의 줄에는 집합 S에 포함돼 있는 문자열이 주어지고, 그다음 M개의 줄에는 검사해야 하는
    문자열이 주어진다. 입력으로 주어지는 문자열은 알파벳 소문자로만 이뤄져 있으며, 길이는 500을 넘지 않는다. 집합 S에 같은 문자열이 여러 번 주어지는 경우는 없다.
  ### 출력
  - 1번째 줄에 M개의 문자열 중 총 몇 개가 집합 S에 포함돼 있는지 출력한다.
  ### 예제 입력1
  ```java
  5 11  // N,M
  baekjoononlinejudge
  startlink
  codeplus
  sundaycoding
  codingsh
  baekjoon
  codeplus
  codeminus
  startlink
  starlink
  sundaycoding
  codingsh
  codinghs
  sondaycoding
  startrink
  icerink
  ```
  ### 예제 출력1
  ```java
  4
  ```
  ### [1단계] 문제 분석하기
  - 집합 S에 속해 있는 단어들을 이용해 트라이 구조를 생성하고, 트라이 검색을 이용해 문자열 M개의 포함 여부를 카운트하는 전형적인 트라이 자료구조 문제이다.
  ### [2단계] 손으로 풀어보기
  1. 트라이 자료구조를 생성한다. 현재 문자열을 가리키는 위치의 노드가 공백 상태라면 신규 노드를 생성하고, 아니라면 이동한다. 문자열의 마지막에 도달하면 리프 노드라고
     표시한다.
  2. 트라이 자료구조 검색으로 집합 S에 포함된 문자열을 센다. 부모-자식 관계 구조를 이용해 대상 문자열을 검색했을 때 문자열이 끝날 때까지 공백 상태가 없고, 현재 문자의
     마지막 노드가 트라이의 리프 노드라면 이 문자를 집합 S에 포함된 문자열로 센다.
  ### [3단계] 슈도코드 작성하기
  ```java
  n(집합 S의 문자열 개수) m(검사할 문자열 개수)
  while(n만큼 반복하기) {   // 트라이 자료구조 구축하기
    text(집합 S의 문자열)
    현재 노드를 루트 노드로 설정하기
    for (i를 text 문자열 길이만큼 반복하기) {
      c(i번째 문자)
      if (c 변수에 해당하는 다음 노드가 null) 신규 노드 생성하기
      else 현재 노드를 c 변수 노드로 변경하기
      if (i가 문자열의 마지막이면 isEnd 변수를 true로 설정하기
    }
  }
  count(정답 변수)
  while(m만큼 반복하기) {   // 트라이 자료구조 검색하기
    text(검색 문자열)
    현재 노드를 루트 노드로 설정하기
    for (i를 text 문자열 길이만큼 반복하기) {
      if (c 변수에 해당하는 다음 노드가 null) 이 문자열 검색 종료
      else 현재 노드를 c 변수 노드로 변경하기
      if (i가 마지막 문자열이고, 현재 노드의 isEnd값이 true이면) count값 올리기
    }
  }
  count 출력하기
  // 트라이 자료구조를 위한 t노드 class 구현하기
  class t노드 {
    next(다음 노드 배열)   // 26size 배열로 선언하기
    isEnd(마지막 문자열 여부 표시하기)
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam069_문자열찾기](src/book/ch09/exam069_문자열찾기.java)

# 3. 이진 트리
- **`이진 트리(binary tree)`** 는 각 노드의 **자식 노드(차수)의 개수가 2 이하로 구성돼 있는 트리**를 말한다. 트리 영역에서 가장 많이 사용되는 형태이다.
## (1) 이진 트리의 종류
- **편향 이진 트리** : 노드들이 한쪽으로 편향돼 생성된 이진 트리
- **포화 이진 트리** : 트리의 높이가 모두 일정하며 리프 노드가 꽉찬 이진 트리
- **완전 이진 트리** : **마지막 레벨을 제외하고 완전하게 노드들이 채워져 있고, 마지막 레벨은 왼쪽부터 채워진 트리**이다.
- 데이터를 트리 자료구조에 저장할 때 편향 이진 트리의 형태로 저장하면 탐색 속도가 저하되고 공간이 많이 낭비되는 단점이 있다. 일반적으로 코딩 테스트에서 데이터를 트리에
  담는다고 하면 **`완전 이진 트리`** 형태를 떠올리면 된다.
## (2) 이진 트리의 순차 표현
- 가장 직관적이면서 편리한 트리 자료구조 형태는 바로 **`배열`** 이다.
  ### 트리의 노드와 배열의 인덱스 사이 상관 관계
  |이동 목표 노드|인덱스 연산|제약 조건(N=노드 개수)|
  |:---|:---|:---|
  |루트 노드|index = 1||
  |부모 노드|index = index / 2|현재 노드가 루트 노드가 아님|
  |왼쪽 자식 노드|index = index * 2|index * 2 ≤ N|
  |오른쪽 자식 노드|index = index * 2 + 1|index * 2 + 1 ≤ N|
  - 위의 인덱스 연산 방식은 향후 **`세그먼트 트리(segment tree)`** 나 **`LCA(lowest common ancestor)`** 알고리즘에서도 기본이 되는 연산이다.
### [문제 070] : 트리 순회하기 (2s)
  ### 문제
  - 이진 트리를 입력받아 전위 순회(preorder traversal), 중위 순회(inorder traversal), 후위 순회(postorder traversal)한 결과를 출력하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 이진 트리의 노드 개수 N(1≤N≤26), 2번째 줄부터 N개의 줄에 걸쳐 각 노드와 그의 왼쪽 자식 노드, 오른쪽 자식 노드가 주어진다. 노드의 이름은 A부터 차례대로
    영문자 대문자로 매겨지며, 항상 A가 루트 노드가 된다. 자식 노드가 없을 때는 .으로 표현된다.
  ### 출력
  - 1번쨰 줄에 전위 순회, 2번째 줄에 중위 순회, 3번째 줄에 후위 순회한 결과를 출력한다. 각 줄에 N개의 알파벳을 공백 없이 출력하면 된다.
  ### 예제 입력1
  ```java
  7   // 노드 개수
  A B C
  B D .
  C E F
  E . .
  F . G
  D . .
  G . .
  ```
  ### 예제 출력1
  ```java
  ABDCEFG
  DBAECFG
  DBEGFCA
  ```
  ### [1단계] 문제 분석하기
  - 특별한 아이디어를 떠올릴 필요 없이 문제가 요구하는 자료구조 형태만 충실히 구현하면 되는 문제이다. 문제에서 주어진 입력값을 트리 형태의 자료구조에 적절하게 저장하고,
    그 안에서 탐색을 수행하는 로직을 구현해 보자. 클래스로 노드를 구현하는 방식, 2차원 배열로 구현하는 방식 등 다양한 방법으로 문제를 해결할 수 있다. 여기에서는 2차원
    배열을 이용해 구현하는 방식을 선택해보자.
  ### [2단계] 손으로 풀어보기
  1. 2차원 배열에 트리 데이터를 저장한다(실제로 저장할 때는 코드에서 적절하게 index화하여 저장한다).
  2. 전위 순회 함수를 구현해 실행한다.
     - **전위 순회 순서** : **`현재 노드 → 왼쪽 노드 → 오른쪽 노드`** 순서로 탐색
  3. 중위 순회, 후위 순회 함수도 과정 2와 같은 방식으로 구현해 실행한다.
     - **중위 순회 순서** : **`왼쪽 노드 → 현재 노드 → 오른쪽 노드`** 순서로 탐색
     - **후위 순회 순서** : **`왼쪽 노드 → 오른쪽 노드 → 현재 노드`** 순서로 탐색
  ### [3단계] 슈도코드 작성하기
  ```java
  N(노드 개수), tree(tree 데이터 저장 2차원 배열)
  for (N의 개수만큼 반복하기) {
    if (왼쪽 자식 노드가 없을 때)
      tree 배열에 -1 저장하기
    else
      tree 배열에 왼쪽 자식 노드 인덱스 저장하기
    if (오른쪽 자식 노드가 없을 때)
      tree 배열에 -1 저장하기
    else
      tree 배열에 오른쪽 자식 노드 인덱스 저장하기
  }
  preOrder 실행하기 → inOrder 실행하기 → postOrder 실행하기
  preOrder {    // preOrder 구현하기 : 중간 → 왼쪽 → 오른쪽
    현재값이 -1이면 리턴(자식 노드가 없으면)
    1. 현재 노드 출력하기
    2. 왼쪽 자식 노드 탐색하기
    3. 오른쪽 자식 노드 탐색하기
  }
  inOrder {     // inOrder 구현하기 : 왼쪽 → 중간 → 오른쪽
    현재값이 -1이면 리턴(자식 노드가 없으면)
    1. 왼쪽 자식 노드 탐색하기
    2. 현재 노드값 출력하기
    3. 오른쪽 자식 노드 탐색하기
  }
  postOrder {   // postOrder 구현하기 : 왼쪽 → 오른쪽 → 중간
    현재값이 -1이면 리턴(자식 노드가 없으면)
    1. 왼쪽 자식 노드 탐색하기
    2. 오른쪽 자식 노드 탐색하기
    3. 현재 노드값 출력하기
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam070_트리순회](src/book/ch09/exam070_트리순회.java)

# 4. 세그먼트 트리
- 주어진 데이터들의 **구간 합**과 **데이터 업데이트**를 빠르게 수행하기 위해 고안해낸 자료구조의 형태가 바로 **`세그먼트 트리`** 이다. 더 큰 범위는 **`인덱스 트리`**
  라고 불리는데, 코딩 테스트 영역에서는 큰 차이가 없다고 생각해도 된다.
- 세그먼트 트리의 종류는 구간 합, 최대/최소 구하기로 나눌 수 있다.
## 1. 트리 초기화하기
1. 리프 노드의 개수가 데이터의 개수(N) 이상이 되도록 트리 배열을 만든다. **트리 배열의 크기**를 구하는 방법은 **`2^k ≥ N`을 만족하는 k의 최솟값을 구한 후 `2^k * 2`를
  트리 배열의 크기로 정의** 하면 된다.
2. 리프 노드에 원본 데이터를 입력한다. 이때 리프 노드의 시작 위치를 트리 배열의 인덱스로 구해야 하는데, 구하는 방식은 **`2^k`** 를 **시작 인덱스**로 취하면 된다.
3. 리프 노드를 제외한 나머지 노드의 값을 채운다(2^k - 1부터 1번 쪽으로 채운다). 채워야 하는 인덱스가 N이라고 가정하면 **자신의 자식 노드를 이용**해 해당 값을 채울 수 있다.
   자식 노드의 인덱스는 이진 트리 형식이기 때문에 **`2N`**, **`2N + 1`** 이 된다. 각 케이스별로 적절하게 계산한다.
   - 구간 합 : A[N] = A[2N] + A[2N + 1]
   - 최대 : A[N] = Math.max(A[2N], A[2N + 1])
   - 최소 : A[N] = Math.min(A[2N]. A[2N + 1])
- 위와 같이 세그먼트 트리를 구성해 놓으면 그 이후 질의와 관련된 결괏값이나 데이터 업데이트 요구사항에 관해 좀 더 **빠른 시간 복잡도** 안에서 해결할 수 있다.
## 2. 질의값 구하기
- 주어진 질의 인덱스를 세그먼트 트리의 리프 노드에 해당하는 인덱스로 변경한다. 기존 샘플을 기준으로 한 인덱스값과 세그먼트 트리 배열에서의 인덱스값이 다르기 때문에
  인덱스를 변경해야 한다.
### (1) 질의 인덱스를 세그먼트 트리 인덱스로 변경하는 방법
- **세그먼트 트리 index = 주어진 질의 index + `2^k - 1`**
### (2) 질의값 구하는 과정
1. **`start_index % 2 == 1`** 일 때 해당 노드를 선택한다.
2. **`end_index % 2 == 0`** 일 때 해당 노드를 선택한다.
3. 1에서 노드를 선택했다면 **`start_index = (start_index + 1) / 2`** 연산을, 선택하지 않았다면 **`start_index = start_index / 2`** 연산을 실행한다.
4. 2에서 노드를 선택했다면 **`end_index = (end_index - 1) / 2`** 연산을, 선택하지 않았다면 **`end_index = end_index / 2`** 연산을 실행한다.
5. 1~4를 반복하다가 **`end_index < start_index`** 가 되면 종료한다.
- 1~2에서 해당 노드를 선택했다는 것은 해당 노드의 부모가 나타내는 범위가 질의 범위를 넘어가기 때문에 해당 노드를 질의값에 영향을 미치는 **독립 노드로 선택**하고,
  해당 노드의 **부모 노드는 대상 범위에서 제외**한다는 뜻이다. 부모 노드를 대상 범위에서 제거하는 방법은 바로 3~4에서 질의 범위에 해당하는 부모 노드로 이동하기 위해
  인덱스 연산을 index / 2 가 아닌 (index + 1) / 2, (index - 1) / 2로 수행하는 것이다.
### (3) 질의에 해당하는 노드 선택 방법
- 질의에 해당하는 노드를 선택하는 방법은 구간 합, 최댓값 구하기, 최솟값 구하기 모두 동일하며 선택된 노드들에 관해 **마지막에 연산하는 방식**만 다르다.
  - **구간 합** : 선택된 노드들을 모두 더한다.
  - **최댓값** : 선택된 노드들 중 MAX값을 선택해 출력한다.
  - **최솟값** : 선택된 노드들 중 MIN값을 선택해 출력한다.
## 3. 데이터 업데이트하기
- 업데이트 방식은 자신의 부모 노드로 이동하면서 업데이트한다는 것은 동일하지만, 어떤 값으로 업데이트할 것인지에 관해서는 트리 타입별로 조금 다르다.
  - **구간 합** : 원래 데이터와 변경 데이터의 차이만큼 부모 노드로 올라가면서 변경한다.
  - **최댓값** : 변경 데이터와 자신과 같은 부모를 지니고 있는 다른 자식 노드와 비교해 더 큰 값으로 업데이트한다. 업데이트가 일어나지 않으면 종료한다.
  - **최솟값** : 변경 데이터와 자신과 같은 부모를 지니고 있는 다른 자식 노드와 비교해 더 작은 값으로 업데이트한다. 업데이트가 일어나지 않으면 종료한다.
    
### [문제 071] : 구간 합 구하기 3 (2s)
  ### 문제
  - 어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고, 그 중간에 어떤 부분의 합을 구하려 한다. 만약 1,2,3,4,5라는 수가 있고, 3번째 수를 6으로 바꾸고
    2번째부터 5번째까지 합을 구하라고 한다면 17을 출력하면 되는 것이다. 그리고 이 상태에서 5번째 수를 2로 바꾸고, 3번째부터 5번째까지 합을 구하라고 한다면 12가 될 것이다.
  ### 입력
  - 1번째 줄에 N(1≤N≤1,000,000)과 M(1≤M≤10,000), K(1≤K≤10,000)가 주어진다. N은 수의 개수, M은 수의 변경이 일어나는 횟수, K는 구간의 합을 구하는 횟수다. 그리고 2번째 줄부터
    N+1번째 줄까지 N개의 수가 주어진다. 그리고 N+2번째 줄부터 N + M + K + 1번째 줄까지 3개의 정수 a,b,c가 주어지는데, a가 1일 때 b(1≤b≤N) 번째 수를 ㅊc로 바꾸고, a가 2일
    경우에는 b(1≤b≤N)번째 수에서 c(b≤c≤N)번째 수까지의 합을 구해 출력하면 된다. 입력으로 주어지는 모든 수는 -263보다 크거나 같고, 263-1보다 작거나 같은 정수다.
  ### 출력
  - 1번째 줄부터 K줄에 걸쳐 구한 구간의 합을 출력한다. 단, 정답은 -263보다 크거나 같고, 263-1보다 작거나 같은 정수다.
  ### 예제 입력1
  ```java
  5 2 2   // 노드 개수, 변경 횟수, 구간 합 횟수
  1
  2
  3
  4
  5
  1 3 6
  2 2 5
  1 5 2
  2 3 5
  ```
  ### 예제 출력1
  ```java
  17
  12
  ```
  ### [1단계] 문제 분석하기
  - 단순하게 구간 합을 구하는 문제라면 앞에서 배운 합 배열 자료구조를 이용해 쉽게 해결할 수 있다. 하지만 이 문제를 합 배열로 풀지 못하는 이유는 중간에 **수의 변경**이
    빈번히 일어나는 상황이 존재하기 때문이다. 합 배열은 자료구조의 특성상 데이터 변경에 시간이 오래 걸리는 단점이 있다. 따라서 이 문제는 데이터의 변경에도 시간이 비교적
    적게 걸리는 세그먼트 트리 자료구조를 이용해 해결한다.
  ### [2단계] 손으로 풀어보기
  1. 1차원 배열을 이용해 트리의 값을 초기화한다. 트리 배열 크기가 N=5이므로 2^k ≥ N을 만족하는 k의 값은 3이고, 배열의 크기는 2^3*2=16이 된다.
     시작 인덱스는 2^3 = start_index = 8이 된다.
  2. 질의값 연산 함수와 데이터 업데이트 함수를 수행하고, 질의와 관련된 결괏값을 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  tree(세그먼트 트리 배열)
  N(수의 개수), M(변경이 일어나는 개수), K(구한 합을 구하는 개수)
  treeSize 구하기 → Math.pow(2, 트리의 높이 + 1)
  leftNodeStartIndex 구하기 → treeSize / 2 - 1  // 리프 노드 시작 인덱스
  tree 배열의 리프 노드 영역에 데이터 입력받기
  setTree(트리의 크기)                                          // 초기 트리를 생성하는 함수
  for (M+K만큼 반복하기) {
    a(질의 유형), s(시작 인덱스), e(변경값 또는 종료 인덱스)
    a가 1일 때 → changeVal(tree에서 시작 인덱스, e(변경값))          // 데이터 변경 함수
    a가 2일 때 → getSum(tree에서 시작 인덱스, tree에서 종료 인덱스)  // 구간 합 함수 호출 및 출력
  }

  // 구간 합을 구하는 함수
  getSum(시작 인덱스, 종료 인덱스) {
    while (시작 인덱스와 종료 인덱스가 교차될 때까지) {
      if (시작 인덱스 % 2 == 1) 해당 노드의 값을 구간 합에 추가하고 시작 인덱스 증가
      if (종료 인덱스 % 2 == 0) 해당 노드의 값을 구간 합에 추가하고 종료 인덱스 감소
      시작 인덱스 = 시작 인덱스 / 2
      종료 인덱스 = 종료 인덱스 / 2
    }
    구간 합 결과 리턴하기
  }

  // 값 변경 함수 구현하기
  changeVal(시작 인덱스, 변경값) {
    diff(현재 노드의 값과 변경된 값의 차이)
    while (시작 인덱스가 0보다 크다) {
      시작 인덱스의 트리값에 diff값을 더함
      시작 인덱스 = 시작 인덱스 / 2
    }
  }

  // 초기 트리 생성 함수 구현하기
  setTree(트리의 마지막 인덱스) {
    while (인덱스가 루트가 아닐 때까지 반복하기) {
      트리의 인덱스/2 부분(부모 노드)에 현재 index의 트리값 더하기
      index 1개 감소
    }
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam071_구간합구하기3](src/book/ch09/exam071_구간합구하기3.java)
### [문제 072] : 최솟값 찾기 2 (1s)
  ### 문제
  - N(1≤N≤100,000)개의 정수들이 있을 때 A번째 정수에서 B번째 정수까지 중 가장 작은 정수를 찾는 것은 어려운 일이 아니다. 하지만 이와 같은 a,b의 쌍이 M(1≤M≤100,000)개
    주어졌을 때는 어려운 문제가 된다. 이 문제를 해결해 보자.<br/>
    여기서 A번째라는 것은 입력되는 순서로 A번째라는 이야기다. 예를 들어 a=1, b=3이라면 입력된 순서대로 1번, 2번, 3번 정수 중 최솟값을 찾아야 한다. 각각의 정수들은 1 이상
    1,000,000,000 이하의 값을 갖는다.
  ### 입력
  - 1번째 줄에 N,M이 주어진다. 다음 N개의 줄에는 N개의 정수가 주어진다. 다음 M개의 줄에는 a,b의 쌍이 주어진다.
  ### 출력
  - M개의 줄에 입력받은 순서대로 각 a,b와 관련된 답을 출력한다.
  ### 예제 입력1
  ```java
  10 4   // 노드 개수, 질의 개수
  75
  30
  100
  38
  50
  51
  52
  20
  81
  5
  1 10
  3 5
  6 9
  8 10
  ```
  ### 예제 출력1
  ```java
  5
  38
  20
  5
  ```
  ### [1단계] 문제 분석하기
  - 전형적인 세그먼트 트리 문제이다. 데이터를 변경하는 부분이 없기 때문에 1차원 배열에 최솟값 기준으로 트리 데이터를 저장하고, 질의를 수행하는 함수까지만 구현하면 된다.
  ### [2단계] 손으로 풀어보기
  1. 1차원 배열로 트리의 값을 **최댓값 기준으로 초기화**한다. 트리 배열 크기가 N=10이므로 2^k ≥ N를 만족하는 k의 값은 4이고, 배열의 크기는 2^4*2=32가 된다.
     시작 인덱스는 2^4 = start_index = 16이 된다.
  2. 질의값 연산 함수를 수행하고, 결괏값을 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  tree(세그먼트 트리 배열)
  N(수의 개수), M(최솟값을 구하는 횟수)
  treeSize 구하기 → Math.pow(2, 트리의 높이 + 1)
  leftNodeStartIndex 구하기 → treeSize / 2 - 1   // 리프 노드 시작 인덱스
  트리 초기화하기(모든 값을 Max값으로 초기화)     // ***누락하기 쉬운 부분
  tree 배열의 리프 노드 영역에 데이터 입력받기
  setTree(트리의 크기)                            // 초기 트리를 생성하는 함수
  for (M만큼 반복하기) {
    getMin(tree에서 시작 인덱스, tree에서 종료 인덱스)   // 최솟값을 구하는 함수 호출 및 출력하기
  }

  // 범위의 최솟값을 구하는 함수
  getMin(시작 인덱스, 종료 인덱스) {
    Min(범위의 최솟값을 나타내는 변수, MAX_VALUE로 초기화)
    while (시작 인덱스와 종료 인덱스가 교차될 때까지) {
      if (시작 인덱스 % 2 == 1) {
        Min과 현재 인덱스의 트리값을 비교해 작은 값을 Min 변수에 저장
        시작 인덱스 증가
      }
      if (종료 인덱스 % 2 == 0) {
        Min과 현재 인덱스의 트리값을 비교해 작은 값을 Min 변수에 저장
        종료 인덱스 감소
      }
      시작 인덱스 = 시작 인덱스 / 2
      종료 인덱스 = 종료 인덱스 / 2
    }
    Min값 리턴하기
  }

  // 초기 트리 생성 함수
  setTree(트리의 마지막 인덱스) {
    while (인덱스가 루트가 아닐 때까지 반복하기) {
      트리의 인덱스/2 부분(부모 노드)의 값과 현재의 값을 비교해 현재의 값이 더 작을 때
      해당 값을 트리의 인덱스/2 부분(부모 노드)에 저장하기
      index 1 감소
    }
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam072_최솟값](src/book/ch09/exam072_최솟값.java)
### [문제 073] : 구간 곱 구하기 (1s)
  ### 문제
  - 어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고, 그 중간에 어떤 구간의 곱을 구하려 한다. 만약 1,2,3,4,5라는 수가 있고, 3번째 수를 6으로 바꾸고
    2번째부터 5번째까지 곱을 구하라고 한다면 240을 출력하면 되는 것이다. 그리고 그 상태에서 5번째 수를 2로 바꾸고 3번째부터 5번째까지 곱을 구하라고 한다면 48이 될 것이다.
  ### 입력
  - 1번째 줄에 수의 개수 N(1≤N≤1,000,000)과 M(1≤M≤10,000), K(1≤K≤10,000)가 주어진다. M은 수의 변경이 일어나는 횟수, K는 구간의 곱을 구하는 횟수다. 그리고 2번째 줄부터
    N+1번째 줄까지 N개의 수가 주어진다. 그리고 N+2번째 줄부터 N+M+K+1번째 줄까지 3개의 정수 a,b,c가 주어지는데, a가 1일 때 b번째 수를 c로 바꾸고, a가 2일 경우에는 b부터
    c까지의 곱을 구해 출력하면 된다. 입력으로 주어지는 모든 수는 0보다 크거나 같고, 1,000,000보다 작거나 같은 정수다.
  ### 출력
  - 1번째 줄부터 K줄에 걸쳐 구한 구간의 곱을 1,000,000,007로 나눈 나머지를 출력한다.
  ### 예제 입력1
  ```java
  5 2 2   // 노드 개수, 변경 횟수, 구간 곱 횟수
  1
  2
  3
  4
  5
  1 3 6
  2 2 5
  1 5 2
  2 3 5
  ```
  ### 예제 출력1
  ```java
  240
  48
  ```
  ### [1단계] 문제 분석하기
  - 대부분의 세그먼트 트리는 구간 합, 최댓값, 최솟값에 관해 많은 문제가 출제된다. 이 문제는 조금은 색다른 구간 곱과 관련된 문제이다. 기본 틀은 세그먼트 트리의 다른 문제와
    동일하다. 이 문제에서 조건에 따라 자유자재로 기존의 알고리즘 코드를 수정할 수 있는 훈련을 하고자 한다. 곱셈의 성질을 염두해 두고 문제를 풀어보자.
  ### [2단계] 손으로 풀어보기
  1. 1차원 배열로 트리의 값을 초기화한다. 트리 배열 크기가 N=5이므로 2^k ≥ N을 만족하는 k의 값은 3이고, 배열의 크기는 2^3*2=16이 된다. 시작 인덱스는 2^3 = start_index = 8이 된다.
     곱셈이기 때문에 **초깃값을 1로 저장**해 주고, 부모 노드를 양쪽 자식 노드의 곱으로 표현한다. 이때 MOD 연산을 지속적으로 수행해 값의 범위가 1,000,000,007이 넘지 않도록 구현한다.
  2. 질의값 연산 함수와 데이터 업데이트 함수를 수행하고 결괏값을 출력한다. 이때 값을 업데이트하거나 구간 곱을 구하는 각 곱셈마다 모두 MOD 연산을 수행한다.
     곱셈의 성질에 따른 세부 코드가 변경돼야 하며, MOD 연산 로직을 추가해야 한다.
     #### 곱셈과 관련된 % 연산의 성질
          (A * B) % C = (A % C) * (B % C) % C
     - 두 값을 곱셈한 후 % 연산한 결과는 각각 % 연산한 값을 곱해 % 연산을 한 것과 동일함
  #### [업데이트할 때 기존의 값이 0일 때]
  - 이 문제에서 고민해야 할 부분은 값 업데이트에서 기존의 값이 0일 때이다. 기존의 값이 0이었다면 이 부모 노드는 모두 0으로 저장돼 있는 상태이다.<br/>
    따라서 기존의 구간 합과 같이 변경된 값을 부모 노드에 적용해도 '0 * 변경된 데이터'의 형태이므로 **업데이트되지 않는 현상이 발생**한다.<br/>
    따라서 이 부분은 부모 노드의 값을 업데이트할 때 **양쪽 자식의 곱으로 업데이트**해 주도록 세부 로직을 고민해야 한다. 또한 각 프로세스마다 꼼꼼하게 MOD 연산을
    수행하는 것도 잊지 말아야 한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  tree(세그먼트 트리 배열)
  N(수의 개수), M(변경이 일어나는 개수), K(구간 곱을 구하는 개수)
  MOD(1000000007)
  treeSize 구하기 → Math.pow(2, 트리의 높이 + 1)
  leftNodeStartIndex 구하기 → treeSize / 2 - 1                     // 리프 노드 시작 인덱스
  tree 초기화하기                                                  // 구간 곱이므로 1로 초기화하기
  tree 배열의 리프 노드 영역에 데이터 입력받기
  setTree(트리의 크기)                                             // 초기 트리를 생성하는 함수
  for (M+K만큼 반복하기) {
    a(질의 유형), s(시작 인덱스), e(변경값 또는 종료 인덱스)
    a가 1일 때 → changeVal(tree에서 시작 인덱스, e(변경값))         // 데이터 변경 함수
    a가 2일 때 → getMul(tree에서 시작 인덱스, tree에서 종료 인덱스) // 구간 곱 함수 호출 및 출력
  }
  // 구간 곱을 구하는 함수
  getMul(시작 인덱스, 종료 인덱스) {
    while (시작 인덱스와 종료 인덱스가 교차될 때까지) {
      if (시작 인덱스 % 2 == 1) {
        해당 노드의 값을 구간 곱에 곱하기 % MOD
        시작 인덱스 1 증가
      }
      if (종료 인덱스 % 2 == 0) {
        해당 노드의 값을 구간 곱에 곱하기 % MOD
        종료 인덱스 1 감소
      }
      시작 인덱스 = 시작 인덱스 / 2
      종료 인덱스 = 종료 인덱스 / 2
    }
    구간 곱 결과 리턴하기
  }

  // 값 변경 함수
  changeVal(시작 인덱스, 변경값) {
    현재 index에 변경값 저장하기
    while (시작 인덱스가 1보다 크다) {
      시작 인덱스 = 시작 인덱스 / 2
      // 현재 노드의 양쪽 자식 노드를 찾아 곱하는 로직
      시작 인덱스의 트리값 = 시작 인덱스 * 2의 트리값 % MOD * 시작 인덱스 * 2 + 1의 트리값 % MOD
    }
  }

  // 초기 트리 생성 함수
  setTree(트리의 마지막 인덱스) {
    while(인덱스가 루트가 아닐 때까지 반복하기) {
      트리의 인덱스/2 부분(부모 노드)에 현재 index의 트리값 곱하기 % MOD
      index 1 감소
    }
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam073_구간곱구하기](src/book/ch09/exam073_구간곱구하기.java)

# 5. 최소 공통 조상
- 트리 그래프에서 임의의 두 노드를 선택했을 때 두 노드가 각각 자신을 포함해 거슬러 올라가면서 부모 노드를 탐색할 때 **처음 공통으로 만나게 되는 부모 노드**를
  **`최소 공통 조상(LCA: lowest common ancestor)`** 이라고 한다.
## (1) 일반적인 최소 공통 조상 구하기
1. #### 루트 노드에서 탐색을 시작해 각 노드의 부모 노드와 깊이를 저장한다.
    - 이때 탐색은 DFS 또는 BFS를 이용해 수행한다.<br/>
2. #### 선택된 두 노드의 깊이가 다른 경우, 더 깊은 노드의 노드를 부모 노드로 1개씩 올려 주면서 같은 깊이로 맞춘다.
    - 이때 두 노드가 같으면 해당 노드가 최소 공통 조상이므로 탐색을 종료한다.
3. #### 깊이가 같은 상태에서는 동시에 부모 노드로 올라가면서 두 노드가 같은 노드가 될 때까지 반복한다. 이때 처음 만는 노드가 최소 공통 조상이 된다.

- 이와 같은 방식을 이용하면 최소 공통 조상을 구할 수 있지만, 트리의 높이가 커질 경우 **시간 제약 문제에 직면**할 수 있다.
  
## (2) 최소 공통 조상 빠르게 구하기
- 일반적인 최소 공통 구하기 알고리즘의 시간 제약 문제를 해결하기 위해 새롭게 제안된 방식이다.<br/>
  '최소 공통 조상 빠르게 구하기'의 핵심은 서로의 깊이를 맞춰 주거나 같아지는 노드를 찾을 때 기존에 한 단계씩 올려 주는 방식에서 **`2^K`** 씩 올라가 비교하는 방식이다.
  따라서 기존에 자신의 부모 노드만 저장해 놓던 방식에서 **2^K번째 위치의 부모 노드까지 저장**해 둬야 한다.
### 1. 부모 노드 저장 배열 만들기
#### [부모 노드 배열의 정의]
- P[K][N] = N번 노드의 2^K번째 부모의 노드 번호
#### [부모 노드 배열의 점화식]
- **P[K][N] = P[K-1][P[K-1][N]]**
- 점화식에서 N의 2^K번째 부모 노드는 **N의 2^(K-1)번째 부모 노드의 2^(K-1)번째 부모 노드**라는 의미이다.
- 배열에서 K는 **`트리의 깊이 > 2^K`를 만족하는 최댓값**이다.
#### [부모 노드 배열 만들기]
- **`K = 0`** 번째 배열을 탐색해 **초기화**한 후, 초기화된 배열을 바탕으로 K를 1씩 증가시키면서 나머지 배열을 채운다.
### 2. 선택된 두 노드의 깊이 맞추기
- P 배열을 이용해 깊이를 **`2^K` 단위로 넘어가면서 맞춘다.** <br/>
  만약 높이 차이가 20이라고 가정하면 2^K ≤ 20을 만족하면서 K가 최대가 되는 만큼 이동하면서 높이 차이가 0이 될 때까지 반복한다. 즉, 높이 차이가 20일 경우에는
  2^4(20) → 2^2(4)와 같이 두 번 이동하면 된다.
### 3. 최소 공통 조상 찾기
1. 공통 조상을 찾는 작업 역시 한 단계씩이 아닌 2^K 단위로 점프하면서 맞춘다. K값을 1씩 감소하면서 P 배열을 이용해 **최초로 두 노드의 부모가 달라지는 값**을 찾는다.
2. 최초로 달라지는 K에 대한 두 노드의 부모 노드를 찾아 이동한다. 이를 K가 0이 될 때까지 반복한다. 반복문이 종료된 후 이동한 2개의 노드가 같은 노드라면 해당노드가,
   다른 노드라면 바로 위의 부모 노드가 최소 공통 조상이 된다.

### [문제 074] : 최소 공통 조상 구하기 1 (3s)
  ### 문제
  - N(2≤N≤50,000)개의 노드로 이루어진 트리가 주어진다. 트리의 각 노드는 1번부터 N번까지 번호가 매겨져 있으며, 루트는 1번이다. 두 노드의 쌍 M(1≤M≤10,000)개가 주어졌을 때
    두 노드의 가장 가까운 공통 조상이 몇 번인지 출력하시오.
  ### 입력
  - 1번째 줄에 노드의 개수 N, 그다음 N-1개의 줄에는 트리상에서 연결된 두 노드가 주어진다. 그다음 줄에 가장 가까운 공통 조상을 알고 싶은 쌍의 개수 M이 주어지고, 그다음
    M개 줄에는 노드 쌍이 주어진다.
  ### 출력
  - M개의 줄에 차례대로 입력받은 두 노드의 가장 가까운 공통 조상을 출력한다.
  ### 예제 입력1
  ```java
  15    // 노드 개수
  1 2
  1 3
  2 4
  3 7
  6 2
  3 8
  4 9
  2 5
  5 11
  7 13
  10 4
  11 15
  12 5
  14 7
  6     // 질의 개수
  6 11
  10 9
  2 6
  7 6
  8 13
  8 15
  ```
  ### 예제 출력1
  ```java
  2
  4
  2
  1
  3
  1
  ```
  ### [1단계] 문제 분석하기
  - 질의 개수가 10,000개이며 노드 개수가 50,000개로 비교적 데이터가 크지 않아 일반적인 방식의 LCA 알고리즘으로 구현하면 되는 문제이다.
  ### [2단계] 손으로 풀어보기
  1. 인접 리스트로 트리 데이터를 구현한다.
  2. 탐색 알고리즘(DFS, BFS)를 이용해 각 노드의 깊이를 구한다.
  3. 깊이를 맞추기 위해 더 깊은 노드를 같은 깊이가 될 때까지 부모 노드로 이동한다.
  4. 부모 노드로 계속 올라가면서 최소 공통 조상을 찾는다.
  ### [3단계] 슈도코드 작성하기
  ```java
  tree(인접 리스트 자료구조)
  N(수의 개수), M(질의 개수)
  depth(노드 깊이 배열) parent(노드 조상 배열)
  visited(방문 여부 저장하기 배열)
  for (N의 개수만큼 반복하기) {
    tree 인접 리스트의 각 ArrayList 초기화
  }
  for (N-1의 개수만큼 반복하기) {
    tree 인접 리스트의 그래프 데이터 저장하기
  }
  BFS(1)   // depth와 부모 노드를 BFS를 이용해 구하기
  for (M의 개수만큼 반복하기) {
    a(1번 노드), b(2번 노드)
    executeLCA(a와 b의 LCA를 구하는 함수 호출 및 결괏값 출력하기)
  }
  // LCA를 구하는 함수 구현하기
  executeLCA(1번 노드, 2번 노드) {
    1번 노드가 depth가 더 작으면 1번 노드와 2번 노드 swap
    두 노드의 depth를 동일하기 맞추기(a를 부모 노드로 변경을 높이가 맞을 때까지 반복하기)
    두 노드의 같은 조상이 나올 때까지 각 노드를 부모 노드로 변경하는 작업을 반복하기
    최소 공통 조상 리턴하기
  }
  // BFS 구현하기
  BFS {
    큐 자료구조에 출발 노드 더하기(add 연산)
    visited 배열에 현재 노드 방문 기록하기
    while (큐가 빌 때까지) {
      큐에서 노드 데이터를 가져오기(poll 연산)
      현재 노드의 연결 노드 중 방문하지 않은 노드로 반복하기 {
        큐에 데이터 삽입(add 연산)하고 visited 배열에 방문 기록하기
        parent 배열에 자신의 부모 노드 저장하기
        depth 배열에 현재 높이 저장하기
      }
      if (이번 높이에 해당하는 모든 노드를 방문했을 때) {
        현재 배열의 depth를 1 증가
      }
    }
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam074_LCA](src/book/ch09/exam074_LCA.java)
### [문제 075] : 최소 공통 조상 구하기 2 (1.5s)
  ### 문제
  - N(2≤N≤100,000)개의 노드로 이뤄진 트리가 주어진다. 트리의 각 노드는 1번부터 N번까지 번호가 매겨져 있으며, 루트는 1번이다. 두 노드의 쌍 M(1≤M≤100,000)개가 주어졌을 때
    두 노드의 가장 가까운 공통 조상이 몇 번인지 출력하시오.
  ### 입력
  - 1번째 줄에 노드의 개수 N, 그다음 N-1개 줄에는 트리상에서 연결된 두 노드가 주어진다. 그다음 줄에 가장 가까운 공통 조상을 알고 싶은 쌍의 개수 M이 주어지고,
    그다음 M개의 줄에는 노드 쌍이 주어진다.
  ### 출력
  - M개의 줄에 차례대로 입력받은 두 노드의 가장 가까운 공통 조상을 출력한다.
  ### 예제 입력1
  ```java
  15    // 노드 개수
  1 2
  1 3
  2 4
  3 7
  6 2
  3 8
  4 9
  2 5
  5 11
  7 13
  10 4
  11 15
  12 5
  14 7
  6     // 질의 개수
  6 11
  10 9
  2 6
  7 6
  8 13
  8 15
  ```
  ### 예제 출력1
  ```java
  2
  4
  2
  1
  3
  1
  ```
  ### [1단계] 문제 분석하기
  - 기존 LCA 문제보다 노드의 개수와 질의(M)의 개수가 매우 커진 것을 확인할 수 있다. 그렇기 때문에 일반적인 '최소 공통 조상 구하기' 방식으로 이 문제를 구현하면
    시간 초과가 발생한다. '제곱근 형태를 이용한 빠르게 최소 공통 조상을 구하기' 방식으로 이 문제를 해결할 수 있다.
  ### [2단계] 손으로 풀어보기
  1. 인접 리스트로 트리 데이터를 구현한다.
  2. 탐색 알고리즘(DFS, BFS)을 이용해 각 노드의 깊이를 구한다.
  3. 점화식을 이용해 parent 배열(부모 노드 배열)을 구한다.
     - 부모 노드 배열 점화식 : P[K][N] = P[K-1][P[K-1][N]]
  4. 깊이가 큰 노드는 parent 배열을 이용해 2^k만큼 빠르게 이동시켜 깊이를 맞춘다. 한 칸씩 오르는 것이 아닌 2의 제곱수로 빠르게 올라간다.
  5. 부모 노드로 올라가면서 최소 공통 조상을 찾는다. parent 배열을 이용해 2^k만큼 넘어가면서 찾는 것이 핵심이다. k는 0에서부터 1씩 증가한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  tree(인접 리스트 자료구조)
  N(수의 개수), M(질의 개수)
  depth(노드 깊이 배열), parent(노드 조상 배열)
  visited(방문 여부 저장 배열)
  for (N의 개수만큼 반복하기) {
    tree 인접 리스트의 각 ArrayList 초기화
  }
  for (N-1의 개수만큼 반복하기) {
    tree 인접 리스트에 그래프 데이터 저장하기
  }
  BFS(1)                                     // depth와 부모 노드를 BFS를 이용해 구하기
  kmax(최대 가능 높이) 구하기
  parent 크기 선언하기 → [kmax + 1][N + 1]   // 2^k까지의 부모 노드 저장하기
  for (kmax만큼 반복하기) {
    for (노드 개수만큼 반복하기) {
      점화식을 이용해 parent 구성하기 → parent[k][n] = parent[k-1][parent[k-1][n]]
    }
  }
  for (M의 개수만큼 반복하기) {
    a(1번 노드), b(2번 노드)
    executeLCA(a와 b의 LCA를 구하는 함수 호출 및 결괏값 출력하기)
  }
  // LCA를 구하는 함수 구현하기
  executeLCA(1번 노드, 2번 노드) {
    1번 노드가 depth가 더 작으면 1번 노드와 2번 노드 swap
    // parent 배열을 이용해 2의 제곱수로 이동하기
    두 노드의 depth를 동일하게 맞추기
    두 노드의 조상이 같을 때까지 각 노드를 부모 노드로 변경하는 작업을 반복하기
    최소 공통 조상 리턴하기
  }
  // BFS 구현하기
  BFS {
    큐 자료구조에 출발 노드 더하기(add 연산)
    visited 배열에 현재 노드 방문 기록하기
    while (큐가 빌 때까지) {
      큐에서 노드 데이터를 가져오기(poll 연산)
      가져온 노드 출력하기
      현재 노드의 연결 노드 중 방문하지 않은 노드로 반복하기 {
        큐에서 노드 데이터 삽입(add 연산)하고 visited 배열에 방문 기록하기
        parent 배열에 자신의 부모 노드 저장하기
        depth 배열에 현재 높이 저장하기
      }
      if (이번 높이에 해당하는 모든 노드를 방문했을 때) {
        현재 배열의 depth를 1 증가
      }
    }
  } 
  ```
  ### [4단계] 코드 구현하기
  - [exam075_LCA2](src/book/ch09/exam075_LCA2.java)
