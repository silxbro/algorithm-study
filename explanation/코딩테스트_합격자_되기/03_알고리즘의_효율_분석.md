# 3. 알고리즘의 효율 분석
<br/>

---

## 1. 시간 복잡도란?
코딩테스트에서 보게 될 문제들은 저마다 '가장 효율적으로 해결하는 알고리즘'이 있다. 이는 알고리즘이 실행되는 제한 시간과 관련이 있다.
문제를 풀 수 있는 알고리즘이 여럿 있을 때 어떤 알고리즘은 문제를 빠르게 풀고, 어떤 알고리즘은 문제를 느리게 푼다면 당연히 문제를 빠르게 푸는 알고리즘을 선택해야 할 것이다.
그런데 그런 알고리즘은 어떤 기준으로 선정해야 할까? 바로 시간 복잡도를 보고 선정해야 한다.

**`시간 복잡도`(time complexity)란, 알고리즘의 성능을 나타내는 지표로, 입력 크기에 대한 연산 횟수의 상한을 의미한다. 시간 복잡도는 낮으면 낮을수록 좋다.**
예를 들어 어떤 문제를 해결하는 알고리즘 A, B, C가 있을 때 시간 복잡도가 가장 낮은 알고리즘이 A라면 A를 사용하는 게 좋을 것이다.

### 🥎 1차원 배열 검색하기
1차원 배열에 값이 있을 때 특정 값을 배열의 맨 앞에서 순서대로 검색한다고 해보자. 이때 값을 가장 빨리 찾는 경우와 가장 늦게 찾는 경우는 언제일까?
#### [값을 가장 빨리 찾는 경우]
- 값을 가장 빨리 찾는 경우는 검색 시작 위치에 찾을 값이 바로 있는 경우이다.
  다음 그림에서는 배열의 1번째 위치부터 값을 찾고 있는데 찾을 값인 1이 배열 1번째 위치에 있으므로 1번만 비교하여 검색을 끝낸다.

  <img src="https://github.com/silxbro/algorithm-study/assets/142463332/54b59971-b624-4fcb-9a20-1ba041561980" width="400">

#### [값을 가장 늦게 찾는 경우]
- 값을 가장 늦게 찾는 경우는 아예 찾으려는 값이 없거나 가장 마지막에 위치하는 경우이다. 다음은 전체 배열을 탐색해도 찾으려는 값이 없는 겨우이다. 연산 횟수가 최대이다.

  <img src="https://github.com/silxbro/algorithm-study/assets/142463332/a8f318a6-8c91-49cd-9be7-776d0ac47f36" width="450">

### 🥎 알고리즘 수행 시간을 측정하는 방법
그럼 진짜 시간을 측정하는 방법, 알고리즘 수행 시간을 측정하는 방법을 알아보자. 알고리즘 수행 시간 측정 방법으로는 절대 시간을 측정하는 방법과 시간 복잡도를 측정하는 방법이 있다.

#### [절대 시간을 측정하는 방법]
- 절대 시간을 측정하는 방법은 말 그대로 시간을 측정하면 된다. 예를 들어 배열에서 검색하는 프로그램을 작성한 다음 프로그램을 실행하여 결과가 나올 때까지의 시간을 측정하면 된다.
  그러나 이 방법은 프로그램을 실행하는 환경에 따라 달라질 수 있어서 코딩 테스테에서는 잘 활용하지 않는다.

#### [시간 복잡도를 측정하는 방법]
- 시간 복잡도를 측정하는 방법은 앞서 검색 문제에서 살짝 언급한 '연산 횟수'와 관련이 있다. 즉, 시간 복잡도는 알고리즘이 시작한 순간부터 결괏값이 나올 때까지의 연산 횟수를 나타낸다.
  그리고 시간 복잡도를 측정한 결과는 다음과 같이 최선(best), 보통(normal), 최악(worst)의 경우로 나눈다.

  앞에서는 '배열의 맨 앞부터 하나씩 검사하기'라는 알고리즘을 사용했다. 이 알고리즘은 상황에 따라 최선의 연산 횟수는 1번, 최악의 연산 횟수는 8번이었다.

    - **시간 복잡도를 표현할 방법이 필요하다**
        - 그러나 이렇게 최선은 1, 최악은 8이라는 특정한 입력 크기에 따른 연산 횟수로 시간 복잡도를 이야기하는 건 특정 상황에 한한 것이므로 무의미하다.
          예를 들어 위에서 설명한 1차원 배열에서 검색하는 문제에서 배열 크기가 1이면 최선, 보통, 최악의 경우는 모두 연산 횟수가 1이다.
          이 결과만 보고 '이 알고리즘은 모든 경우에 연산 횟수가 1인 성능을 가지는 것이구나'라고 생각하면 안 된다.

          다시 말해 특정 입력 크기에 한하여 연산 횟수를 기준으로 시간 복잡도를 측정하면 안 된다. 입력 크기를 N으로 일반화하여 연산 횟수의 추이를 나타내야 한다.
          이런 방식으로 연산 횟수의 추이를 활용해서 시간 복잡도를 표현하는 방법을 **점근적 표기법**이라고 한다.
          그리고 코딩 테스테스트는 모든 경우의 수에서 알고리즘이 문제를 처리하는 것을 고려해야 하므로 시간 복잡도는 **최악의 경우**를 가정하여 이야기하는 것이 일반적이다.


### 🥎 최악의 경우 시간 복잡도를 표현하는 빅오 표기법
그렇다면 최악의 경우에 대하여 시간 복잡도를 표현하는 방법은 무엇이 있을까? 가장 많이 사용하는 점근적 표기법은 상한선을 활용하는 방법이다.
그리고 이 표기법을 **빅오 표기법**(big-O notation)이라고 한다.

빅오 표기법은 어렵지 않다. 어떤 프로그램의 연산 횟수가 f(x)라고 할 때 함수의 최고차항을 남기고 계수를 지워 O(...)와 같이 표기하면 된다.
예를 들어 어떤 프로그램의 연산 횟수가 f(x) = 2x^2 + 3x + 5 라면 시간 복잡도를 O(x^2)과 같이 표현하면 된다. 빅오 표기법은 다음 표를 보면 더 쉽게 이해할 수 있다.
- 점근 표기법이란 어떤 함수의 증가하는 추세를 표현하는 표기법이다.
- 상한선은 빅오 표기법, 하한선은 빅오메가 표기법으로 표시한다.

|수식|빅오 표기|설명|
|:---:|:---:|:---|
|3x^2 + 5x + 6|O(x^2)|다항함수로 구성되어 있으므로 최고차항 x^2만 남음|
|x + logx|O(x)|다항함수와 로그함수로 구성되어 있으므로 증가폭이 더 낮은 로그함수는 사라지고 다항함수만 남음|
|2^x + 10x^5 + 5x^2|O(2^x)|지수함수는 다항함수보다 빠르게 증가하므로 지수함수만 남음|
|5x^2 - 6x|O(x^2)|최고차항 x^2만 남음|

### 🥎 그나저나 왜 이렇게 표기할까?
빅오 표기법으로 최악의 시간 복잡도를 표기하는 방법 자체가 어렵진 않다. 그런데 이 식은 어디서 나온 것일까? 예를 들어 다음과 같은 코드가 있다고 생각해보자.
```java
public static void main(String[] args) {
  solution(6);
}

public static void solution(int n) {
  int count = 0;

  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
      count++;
    }
  }

  for (int i = 0; i < n; i++) {
    count++;
  }

  for (int i = 0; i < n * 2; i++) {
    count++;
  }

  for (int i = 0; i < 5; i++) {
    count++;
  }

  System.out.println(count);
}
```

solution() 함수는 주석 영역별로 각각 n^2, n, 2n, 5번의 증가 연산을 하며 결괏값은 곧 연산 횟수를 의미한다.
지금의 경우 solution(6)을 호출하면 6^2 + 6 + 2 * 6 + 5, 즉, 연산 횟수는 59이다. 이때 solution() 함수는 식으로 다음과 같이 표현할 수 있다.

- n = x일 때 f(x) = x^2 + 3x + 5

이때 다음을 만족하는 C가 있으면 f(x)의 최악의 시간 복잡도는 O(g(x))라고 쓴다.
- 특정 x 시점 이후부터 항상 f(x) <= C * g(x)를 만족
- C는 상수

쉽게 말해 g(x)에 상수 C를 곱했을 때 특정 시점부터 f(x)를 넘어서는지 여부를 보면 된다. 그래프를 살펴보면 금방 이해할 수 있다.
아래 그래프의 경우, C는 2, g(x)는 x^2이다.

<img src="https://github.com/silxbro/algorithm-study/assets/142463332/7dc2e1e8-d87d-437a-ad5c-3323bea2ee1e" width="500">

그래프를 보면 대략 x=4부터 항상 2x^2가 f(x)를 넘으므로 위 공식을 만족한다. 그런데 위 공식을 만족하는 g(x)는 하나만 있을까? 이렇게 생각해볼 수도 있을 것이다.

"g(x)=x, C=50인 경우 x에 값을 몇 개 넣어보니 f(x)보다 값이 크네...? 그렇다면 시간 복잡도는 O(x)라고 해도 되는 것 아닐까?"

조금만 생각해보면 아니라는 걸 알 수 있다. 왜냐하면 50x는 대략 x=47에서 다시 역전당하기 때문이다. 이런 이유로 f(x) = x^2 + 3x + 5의 시간 복잡도는 O(x^2)이라고 쓸 수 있다.

<img src="https://github.com/silxbro/algorithm-study/assets/142463332/4a968993-c9a2-4ad9-85b2-4bebd1526a0b" width="300">

### 🥎 빅오 표기법을 쉽게 쓸 때는 왜 최고차항만 남기고 계수를 지울까?
앞서 빅오 표기법은 다음과 같이 f(x)의 최고차항만 남기고 계수를 지워 O(...)와 같이 쓸 수 있다고 했다. 어떻게 이렇게 해도 되는지 설명하겠다.

- f(x) = x^2 + 3x + 5에서 최고 차항인 x^2만 남김
- x^2는 앞의 차수가 1이므로 제거할 것이 없음
- 시간 복잡도는 O(x^2)

다음은 x, x^2, x^3을 비교한 그래프이다. 그래프를 보면 데이터가 커질수록 세 그래프의 차이는 확연히 벌어진다. x값이 무한하게 커지면 그 격차는 더 심해진다.
x^3에 비해 x와 x^2는 무시할 수 있을 정도로 작을 것이다.

<img src="https://github.com/silxbro/algorithm-study/assets/142463332/85d20d5e-1a92-44bb-9e57-0176571f5e5a" width="400">

지수함수와 로그함수의 경우도 'x가 무한히 커진다'라는 것만 상상할 수 있으면 쉽게 이해할 수 있다. 로그함수는 다항함수보다 느리게 증가하고, 지수함수는 다항함수보다 빠르게 증가한다.
이 우선순위대로면 다항함수와 로그함수가 섞여 있을 때 로그함수를, 지수함수와 다항함수가 섞여 있다면 다항함수를 지워야 할 것이다.

### 🥎 시간 복잡도를 코딩 테스트에 활용하는 방법
이제 시간 복잡도를 표현하는 방법이 빅오 표기법이라는 건 알았다. 그럼 빅오 표기법을 어떻게 활용하면 좋을까?
**코딩테스트 문제에는 제한 시간이 있으므로 문제를 분석한 후에 빅오 표기법을 활용해서 해당 알고리즘을 적용했을 때 제한 시간 내에 출력값이 나올 수 있을지 확인해볼 수 있다.**
그러면 문제 조건에 맞지 않는 알고리즘을 적용하느라 낭비하는 시간을 줄일 수 있다. 보통은 다음을 기준으로 알고리즘을 선택한다.

- "컴퓨터가 초당 연산할 수 있는 최대 횟수는 1억 번이다."

코딩테스트의 문제는 출제자가 의도한 로직을 구현했다면 대부분의 코드를 정답 처리할 수 있도록 채점 시간을 충분히 여유있게 지정한다.
**따라서 연산 횟수는 1,000~3,000만 정도로 고려해서 시간 복잡도를 생각하면 된다.** 예를 들어 제한 시간이 1초인 문제는 연산 횟수가 3,000만이 넘는 알고리즘은 사용하면 안 된다.
제한 시간이 1초인 문제에서 각 시간 복잡도별로 허용할 수 있는 N의 가용 범위는 다음과 같이 생각하면 된다.
- 언어별로 성능은 다를 수 있으나 특정 언어가 유리하거나 불리하면 안 된다. 그래서 언어에 따른 성능 차이는 고려하지 않아도 된다.

|**시간 복잡도**|**N의 가용 범위**|
|:---:|:---:|
|O(N!)|10|
|O(2^N)|20~25|
|O(N^3)|200~300|
|O(N^2)|3,000~5,000|
|O(NlogN)|100만|
|O(N)|1,000~2,000만|
|O(logN)|10억|

맨 처음 우리가 살펴본 배열에서 검색하기로 돌아가보면, 시간 복잡도인 O(N)이 허용하는 연산 횟수는 2,000만이므로 데이터의 개수가 2,000만 개 이하면 이 알고리즘은 사용해도 된다.
**바로 이렇게 시간 복잡도를 활용하여 불필요한 알고리즘을 제외하면 된다.**
<br/>
<br/>

## 2. 시간 복잡도 계산해보기
이제 실전으로 넘어와 시간 복잡도를 계산해보자. 몇 가지 상황을 보면서 시간 복잡도를 계산하는 방법을 익혀두면 다른 문제를 풀 때도 시간 복잡도를 수월하게 계산해볼 수 있다.
여기서는 (1) 문제 정의부터 시작해서 (2) 연산 횟수를 측정한 후 (3) 시간 복잡도를 분석하는 순서로 공부를 진행해보자.

### 🥎 별 찍기 문제
별 찍기 문제는 언어를 공부하였다면 매우 익숙할 것이다. 문제는 숫자 N을 입력받으면 N번째 줄까지 별을 1개부터 N개까지 늘려가며 출력하라는 것이다.
다음 입출력 예를 확인하면 어떤 문제인지 쉽게 이해할 수 있을 것이다.

<img src="https://github.com/silxbro/algorithm-study/assets/142463332/affc3c72-0931-4336-abef-d422b20c78c4" width="170">

#### [푸는 과정]
- 우선 연산 횟수를 구한다. 지금은 출력 자체가 연산이다. 1번째 줄은 1번 연산, 2번째 줄은 2번 연산, ..., N번째 줄은 N번 연산한다. 그림으로 보면 다음과 같다.

  <img src="https://github.com/silxbro/algorithm-study/assets/142463332/469c4e59-1964-4583-bc9a-80434727d52d" width="600">

  결국 연산 횟수 f(N)는 다음과 같다. 빅오 표기법으로는 O(N^2)이라고 할 수 있다.

  f(N) = 1 + 2 + ... + N = N(N+1) / 2


### 🥎 박테리아 수명 문제
초기 박테리아 세포 개수가 N개일 때 해마다 세포 개수가 이전 세포 개수의 반으로 준다면 언제 모든 박테리아가 죽을지 계산히야 한다. 입출력의 예는 아래쪽 표와 같다.

<img src="https://github.com/silxbro/algorithm-study/assets/142463332/8586594c-8e9e-48b5-8604-2523d6c0c168" width="70">


#### [푸는 과정]
- 예를 들어 N이 16인 경우, 모든 박테리아는 5년이면 소멸한다.

  <img src="https://github.com/silxbro/algorithm-study/assets/142463332/3411dae5-44ed-4170-8927-cc4736b9633f" width="550">

  현재 박테리아의 수가 N이라면 1년 뒤의 박테리아 수는 1/2 * N이라고 할 수 있다. Y년 후의 박테리아의 수는 (1/2)^Y * N이다. 이를 그림으로 나타내면 다음과 같다.

  <img src="https://github.com/silxbro/algorithm-study/assets/142463332/91fa8f37-4220-4d06-8f53-59b0d10bde79" width="500">

  그러면 박테리아의 소멸 시기는 (1/2)^Y * N의 값이 최초로 1보다 작아질 때이다. 수식으로는 (1/2)^Y * N <= 1인 Y를 찾으면 된다. 이 수식은 다음과 같이 정리할 수 있다.
    - (1/2)^Y은 1/2^Y로 생각해 (1/2)^Y * N는 N/2^Y < 1이다.
    - 양변에 2^Y를 곱해 식을 정리하면 2*Y > N이고
    - 양변에 로그를 취하면 Y > log(2)N이다.

  이를 통해 이 알고리즘은 O(logN)의 시간 복잡도를 가진다는 것을 알 수 있다.
  > 앞으로 문제를 풀 때 특정값을 계속 반으로 줄이는 동작을 한다면 시간 복잡도를 O(logN)이라 생각하면 된다. 시간 복잡도가 O(logN)인 문제들은 이후 정렬이나 이진 트리를 공부하면서 다시 보도록 한다.

<br/>

지금까지 빅오 표기법으로 알고리즘의 효율을 분석하는 방법을 공부하였다. 코딩 테스트에서 시간 복잡도를 이해하고 분석하는 것은 매우 중요하다.
시간 복잡도를 이해하면 알고리즘의 성능을 정확하게 측정할 수 있으므로 문제를 풀 수 있는 적절한 알고리즘을 선택하고 설계할 수 있기 때문이다.
내가 적용한 알고리즘이 문제를 해결할 수 있는지, 왜 시간 초과가 발생하는지 원인을 명확히 인지하고 공부하기 바란다.