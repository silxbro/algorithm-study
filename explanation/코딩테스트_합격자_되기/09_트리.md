# 09. 트리

<br/>

---

## 1. 트리 개념
트리(tree)는 데이터를 저장하고 탐색하기에 유용한 구조를 갖고 있다. 여기서는 트리가 데이터를 어떤 방식으로 저장하고 탐색하는지 알아보자.

#### [트리의 특성을 활용하는 분야]
프로그래밍 분야에서 트리는 계층 구조를 표현하는 용도로 많이 사용한다. 예를 들어 파일 시스템이나 디렉터리 구조 등을 트리로 구성하거나 관리할 수 있다.
- **인공 지능** : 인공지능의 판단 기준을 만들 때 의사 결정 트리를 사용한다. 이를 통해 외부에서 입력된 데이터를 분류하거나 상황을 예측하는 모델을 만들 수 있다.
- **자동 완성 기능** : 트리는 문자열 처리에도 많이 활용된다. 예를 들어 검색 엔진에서 자동 검색어 추천 기능도 트라이(trie)라는 독특한 트리 구조를 활용한 것이다.
  이를 활용하면 접두사나 패턴 검색을 쉽게 할 수 있다.
- **데이터베이스** : 데이터를 쉽게 검색, 삽입, 삭제를 할 수 있도록 트리를 활용해서 데이터를 구조화하고 인덱싱한다. 이때 B-트리나 B+트리를 많이 사용한다.

### 🥎 나무를 거꾸로 뒤집어 놓은 모양의 트리
트리(tree)는 나무 기둥에서 가지가 뻗어나가는 모습을 거꾸로 뒤집어 놓은 모양이다. 따라서 나무 밑둥(root)이 맨 위에 있다. 다음 그림은 트리 구조를 표현한 것이다.
트리 구조를 표현하는 데 사용하는 새로운 용어가 많이 등장한다. 그림과 함께 용어를 꼼꼼하게 보기 바란다.

<img src="https://github.com/user-attachments/assets/4cf150d9-09b9-4c1e-9234-4251751ac8b4" width="550"/><br/>

#### [트리를 구성하는 노드]
노드는 트리를 구성하는 요소이다. 노드 중 가장 위에 있는 노드를 **루트 노드**(root node)라고 한다. 앞의 그림에서는 맨 위에 있는 값 1이 들어 있는 노드가 루트 노드이다.

#### [노드를 연결하는 에지]
노드와 노드 사이에는 이어주는 선이 있다. 이를 **간선** 또는 **에지**라고 한다. 트리는 노드와 노드가 단방향 간선으로 연결되어 있고, 루트 노드에서 각 노드까지 경로는 유일하다.
루트 노드로부터 특정 노드까지 거쳐가는 최소한의 간선 수를 레벨로 표현한다. 예를 들어 루트 노드는 레벨 0, 노드 19, 2, 13은 레벨 1이다.

#### [부모-자식, 형제 관계를 가지는 노드]
간선으로 연결된 노드들은 서로 **부모-자식 관계**가 있다고 표현한다.
간선으로 직접 연결된 노드 중 상대적으로 위에 있는 노드를 **부모 노드**(parent node), 아래에 있는 노드를 **자식 노드**(child node)라고 한다.
그림에는 표현하지 않았지만 2, 7, 5의 관계를 보면 2가 상대적으로 7, 5의 부모 노드인 셈이다. 그리고 7, 5처럼 같은 부모 노드를 갖는 노드를 **형제 노드**(silbling node)라고 한다.

#### [자식이 없는 말단 노드]
자식이 없는 노드는 **리프 노드**(leaf node)라고 한다.
- 리프 노드는 우리말로는 말단 노드라고도 한다.

#### [아래로 향하는 간선의 개수, 차수]
**차수**(degree)란 특정 노드에서 아래로 향하는 간선의 개수이다. 에를 들어 노드 1은 차수가 3이다. 왜냐하면 아래로 향하는 간선이 3개이기 때문이다.

#### [원소, 노드, 가지, 간선, 가중치... 뭐가 뭔지 헷갈릴 거예요]
많은 전문가는 트리나 그래프를 이야기할 때 원소/노드/버텍스, 가지/간선/에지, 가중치/웨이트 등 다양한 용어를 자연스럽게 혼용한다.
**여기서는 트리, 그래프 모두에서 노드, 간선, 가중치라는 용어로 통일해 사용한다.**
음차나 번역 용어 사용에 대한 절대 규칙이 없는 상황에서 현업에서 보편적으로 사용하는 용어가 무엇인가에 대해 고민했고, 규칙성은 없으나 통일성 있게 용어를 사용하자고 결론을 내렸다.

#### [코딩테스트에서는 이진 트리만 알면 된다]
트리 종류는 굉장히 다양하지만 코딩테스트에서는 **이진 트리**(binary tree)만 제대로 알고 있으면 충분하다.
이진 트리란 모든 노드의 최대 차수가 2를 넘지 않는 트리를 말한다(간선이 최대 2개인 트리이다).

<br/>

## 2. 이진 트리 표현하기
이진 트리는 배열이나 포인터로 구현할 수 있다. 여기서는 배열로 이진 트리를 구현하는 방법을 알아본 후, 포인터로 구현하는 방법을 알아본다.
이진 트리는 다음과 같이 노드 하나가 최대 2개의 자식 노드를 갖는다.

### 🥎 배열로 표현하기
배열은 선형 자료구조이고 트리는 계층 자료구조이다. 따라서 배열로 트리를 표현하려면 다음 3가지 규칙이 필요하다. 참고로 이 규칙은 루트 노드를 배열 인덱스 1번이라고 생각하여 작성한 규칙이다.
- 루트 노드는 배열 인덱스 1번에 저장한다.
- 왼쪽 자식 노드의 배열 인덱스는 **부모 노드의 배열 인덱스 ✕ 2** 이다.
- 오른쪽 자식 노드의 배열 인덱스는 **부모 노드이 배열 인덱스 ✕ 2 + 1** 이다.

위 규칙에 맞게 인덱스를 붙이면 다음과 같을 것이다.

<img src="https://github.com/user-attachments/assets/cb14413b-b544-4189-a077-03d3d116fb27" width="250"/><br/>

정말 규칙에 맞게 되었는지 역으로 확인해보자. 실선 화살표를 따라가며 인덱스를 확인해보면 1 -> 2 -> 4 -> 8이다. **인덱스가 부모 ✕ 2로 증가한다.**
점선 화살표를 따라가며 인덱스를 확인해보면 1 -> 3 -> 7이다. **인덱스가 부모 인덱스 ✕ 2 + 1로 증가한다.** 실제 배열에 이진 트리를 저장하면 다음과 같다.

<img src="https://github.com/user-attachments/assets/4aa22b14-9e86-47e6-850c-3a53bd4d94c5" width="600"/><br/>

루트 노드를 인덱스 0으로 하면 왼쪽 자식 노드는 **부모 노드의 배열 인덱스 ✕ 2 + 1이 되고,** 오른쪽 자식 노드는 **부모 노드의 배열 인덱스 ✕ 2 + 2가 된다.**
입력값에 따라 루트 노드를 0 혹은 1로 정해야 하는 경우가 있으므로 알아두면 편하다.

#### [인덱스를 0으로 했을 때와 1로 했을 때의 차이는 무엇일까요?]
- 인덱스를 0으로 하면 인덱스를 1로 정했을 때와 특정 노드의 인덱스 계산식이 달라진다. 인덱스를 반드시 1로 해야 하는 건 아니므로 필요하다면 인덱스를 0으로 해도 좋다.

트리를 표현한 배열을 보면 빈 값이 꽤 많이 보인다. 노드들의 부모-자식 관계를 곱셈 연산하여 배열의 인덱스로 사용하기 때문에 실제 노드 개수보다 많은 공간을 사용할 수밖에 없다.
즉, 배열로 트리를 표현하면 자식이 없거나 쓰지 않는 인덱스들은 모두 빈 값이므로 메모리가 낭비된다는 단점이 있다.
**그렇다고 해서 배열 표현 방법이 나쁘다는 것은 아니다. 이진 트리를 배열로 표현하는 방식은 굉장히 구현 난이도가 쉬우므로, 메모리만 넉넉하다면 구현 시간을 단축하는 용도로 좋다.
다행히도 대부분 코딩테스트에서는 배열로 이진 트리를 구현해도 괜찮은 경우가 많다.**
- 참고로 이진 트리의 노드가 N개일 때, 배열로 이진 트리를 생성하면 O(N)이 걸린다.

### 🥎 이진 트리 순회하기
이진 트리 구현 방법을 알았으니 이제는 이진 트리에서 순회하는 방법을 알아보자. 순회란 어떤 데이터가 있을 때 그 데이터를 빠짐 없이 방문하는 것을 의미한다.
트리에서 데이터를 검색하려면 트리를 순회할 수 있어야 한다. 배열에서 인덱스로 데이터를 검색할 때 순회하는 것처럼 트리도 순회할 방법이 필요하다. 이진 트리에서의 순회는 다음과 같이 총 3가지 방법이 있다.
- **전위 순회(preorder)** : **현재 노드를 부모 노드로 생각했을 때** 부모 노드 -> 왼쪽 자식 노드 -> 오른쪽 자식 노드 순서로 방문한다.
- **중위 순회(inorder)** : **현재 노드를 부모 노드로 생각했을 때** 왼쪽 자식 노드 -> 부모 노드 -> 오르쪽 자식 노드 순서로 방문한다.
- **후위 순회(postorder)** : **현재 노드를 부모 노드로 생각했을 때** 왼쪽 자식 노드 -> 오른쪽 자식 노드 -> 부모 노드 순서로 방문한다.

순회에서 주목해야 할 표현은 '현재 노드를 부모 노드로 생각했을 때'이다. 이 콘셉트를 이해해야 순회를 쉽게 이해할 수 있다.
우선은 이 표현에 주목해야 한다는 것만 기억해두고 각 순회 과정의 설명을 보면서 더 깊게 이해해보자.

#### (1) 전위 순회 과정 살펴보기
준위 순회는 현재 노드를 부모 노드로 생각했을 때 부모 노드 -> 왼쪽 자식 노드 -> 오른쪽 자식 노드 순서로 방문한다.

**[1단계]** 루트 노드에서 시작한다. 현재 노드를 부모로 생각하면 방문 순서는 1 -> 4 -> 8이다. 그러니 노드 1(자신, 현재 부모)을 방문한 다음 왼쪽 자식인 노드 4로 이동한다.

<img src="https://github.com/user-attachments/assets/204fecfe-469d-44e7-93e7-c07c0c2aeb9a" width="230"/><br/>

**[2단계]** 노드 4로 이동한다. 방문 순서는 4 -> 3 -> 5이므로 자신을 방문하고 3으로 이동한다.

<img src="https://github.com/user-attachments/assets/1e5ddcf3-da8a-47ad-851f-8d7df89d5157" width="230"/><br/>

**[3단계]** 노드 3으로 이동한다. 방문 순서는 3 -> 2 -> (오른쪽 자식 없음)이므로 자신을 방문하고 2로 이동한다.

<img src="https://github.com/user-attachments/assets/0bf86169-b64d-4fc9-ae96-ffe4de98fc13" width="230"/><br/>

**[4단계]** 노드 2로 이동했다. 2 -> (왼쪽 자식 없음) -> (오른쪽 자식 없음)이므로 자신을 방문하고, 더 방문할 자식이 없으므로 3으로 거슬러 올라간다.
노드 3은 3 -> 2 -> (오른쪽 자식 없음)이다. 자신과 왼쪽 자식은 이미 방문했고 더 방문할 자식도 없다. 부모로 거슬러 올라간다.
노드 4에서는 4 -> 3 -> 5이다. 5로 이동한다.

<img src="https://github.com/user-attachments/assets/1650cda8-9529-4348-8ac5-7808ae89e711" width="230"/><br/>

**[5단계]** 마찬가지로 노드 5는 본인을 출력하고 방문할 자식이 없으므로 거슬러 올라가 노드 1까지 간다. 노드 1은 오른쪽 자식만 남았으므로 노드 8로 이동한다.

<img src="https://github.com/user-attachments/assets/c261510d-f609-45e0-9a58-0a1990fbd6b0" width="230"/><br/>

**[6단계]** 이런 방식으로 출력하면 1 -> 4 -> 3 -> 2 -> 5 -> 8 -> 7 -> 6 순서로 트리를 순회하게 된다.

<img src="https://github.com/user-attachments/assets/f6686dd7-c06a-435f-9cc8-cb253d3faaf7" width="230"/><br/>

전위 순회는 이렇게 거치는 노드를 우선 방문(출력)하므로 직관적으로 이해하기 쉽다. 전위 순회는 트리를 복사할 때 많이 사용한다.
- 전위 순회가 직관적으로 이해하기 쉬운 이유는 거치는 노드를 방문하기 때문이다. 중위 순회와 후위 순회를 공부하면 이 의미를 알게 될 것이다.

#### (2) 중위 순회 과정 살펴보기
**중위 순회는 현재 노드를 부모 노드로 생각했을 때 방문 우선순위가 왼쪽 자식 노드 -> 부모 노드 -> 오른쪽 자식 노드이다.**
다시 말해 중위 순회는 거쳐가는 노드, 즉, 현재 노드를 거치기만 할 뿐 '방문'하지 않는다. 바로 이 지점이 처음 공부하는 사람에게 '중위 순회는 난해하다'라고 여기게 만든다.
#### [방문이란?]
- 방문이라는 표현을 자주 사용하고 있다. 탐색에서 방문이란 탐색을 마친 상태를 말한다. 탐색 과정에서 지나치는 것과 그렇지 않은 것을 구분하기 위해 방문이라는 용어를 사용한다.
  다음 그림을 보면 가운데 노드는 지나가기만 했고, 나머지 노드는 방문을 완료했다.

  <img src="https://github.com/user-attachments/assets/2870c1d3-18cf-4289-a651-e88e07b2168e" width="400"/><br/>

**[1단계]** 1에서 방문 우선순위는 4 -> 1 -> 8이므로 우선 4로 이동한다.
이렇게 중위 순회는 현재 자신을 부모 노드로 생각했을 때 왼쪽 자식 노드를 우선해야 하므로 부모 노드는 지나갈 뿐 방문하지는 않는다.

<img src="https://github.com/user-attachments/assets/e4f2d41b-5a5f-41ef-9bf5-97757c11b801" width="230"/><br/>

**[2단계]** 노드 4에 와서도 마찬가지이다. 자신을 부모 노드로 생각했을 때 방문 우선순위는 3 -> 4 -> 5이므로 노드 3으로 이동한다.

<img src="https://github.com/user-attachments/assets/4a851568-9712-4676-ac27-da3e39921756" width="230"/><br/>

**[3단계]** 노드 3은 2 -> 3 -> (오른쪽 자식 없음)이다. 2로 이동한다.

<img src="https://github.com/user-attachments/assets/b702e64a-72b7-4585-b257-6258407c0565" width="250"/><br/>

**[4단계]** 노드 2는 (왼쪽 자식 없음) -> 2 -> (오른쪽 자식 없음)이다. 자신을 방문하고 거슬러 올라간다.

<img src="https://github.com/user-attachments/assets/16ab369a-906c-4253-8f30-76fd4bd0fc1f" width="250"/><br/>

**[5단계]** 노드 3은 2 -> 3 -> (오른쪽 자식 없음)이다. 즉, 방문 순서가 이제 자신이다. 자신을 방문하고, 오른쪽 자식이 없으므로 거슬러 올라간다.

<img src="https://github.com/user-attachments/assets/09bfa754-a607-4521-a22a-9c48dc36732b" width="250"/><br/>

**[6단계]** 노드 4는 3 -> 4 -> 5이다. 자신을 방문하고 오른쪽 자식 5로 간다.

<img src="https://github.com/user-attachments/assets/77d51da4-27e3-4129-84b7-8fd88e02fd6e" width="250"/><br/>

**[7단계]** 노드 5는 (왼쪽 자식 없음) -> 5 -> (오른쪽 자식 없음)이다. 자신을 방문하고 거슬러 올라간다. 노드 4는 모든 노드를 방문했다. 1로 거슬로 올라간다.
- 굵은 선이 이동, 색칠한 원이 방문이다. 여기부터는 말풍선 표시를 하지 않는다.

<img src="https://github.com/user-attachments/assets/dac31e1f-4e83-4fe3-a807-2659fcade03a" width="250"/><br/>

**[8단계]** 노드 1은 4 -> 1 -> 8이다. 자신을 방문하고 오른쪽으로 이동한다.

<img src="https://github.com/user-attachments/assets/9f45ac33-ed6c-4caf-8663-ad2411190f5d" width="250"/><br/>

**[9단계]** 노드 8은 (왼쪽 자식 없음) -> 8 -> 7이다. 자신을 방문하고 오른쪽으로 이동한다.

<img src="https://github.com/user-attachments/assets/c039ecdc-fcf4-4ac5-bf6d-2f32595f6c67" width="250"/><br/>

**[10단계]** 노드 7은 6 -> 7 -> (오른쪽 자식 없음)이다. 6으로 이동한 다음 6은 자식이 없으므로 방문한다.

<img src="https://github.com/user-attachments/assets/ead2fc90-e3f3-404f-bec9-c59c8ef3e9d8" width="250"/><br/>

**[11단계]** 마지막 노드 7을 방문한다. 중위 순회는 2 -> 3 -> 4 -> 5 -> 1 -> 8 -> 6 -> 7 순서로 노드를 방문한다.

<img src="https://github.com/user-attachments/assets/e7ba01d4-3d5e-437e-a22a-8d76e3f24bfa" width="250"/><br/>


중위 순회 방문 과정을 살펴보았다. 이를 통해 현재 자신을 부모로 생각했을 때 방문 우선순위를 따지는 방법을 알았기 바란다. 중위 순회는 이진 탐색 트리에서 정렬된 순서대로 값을 가져올 때 사용된다.

#### (3) 후위 순회 과정 살펴보기
후위 순회는 **현재 노드를 부모 노드로 생각했을 때 왼쪽 자식 -> 오른쪽 자식 -> 부모 순서로 방문한다.** 여기도 그림과 함께 방문 순서를 보자.

**[1단계]** 노드 1부터 시작한다. 4 -> 8 -> 1 이므로 일단 4로 이동한다.

<img src="https://github.com/user-attachments/assets/239bdc96-07af-44fb-9cac-51f590a11e5c" width="250"/><br/>

**[2단계]** 노드 4도 마찬가지이다. 3 -> 5 -> 4이므로 3으로 이동한다.

<img src="https://github.com/user-attachments/assets/f0e401df-551d-41e0-8a5b-9264de6ecd6b" width="250"/><br/>

**[3단계]** 노드 3은 2 -> (오른쪽 자식 없음) -> 3이므로 2로 이동한다.

<img src="https://github.com/user-attachments/assets/07e78152-ac40-4be0-90dd-8a91d25fd92d" width="250"/><br/>

**[4단계]** 노드 2는 (왼쪽 자식 없음) -> (오른쪽 자식 없음) -> 2이므로 자신을 방문하고 3으로 거슬러 올라간다. 아마 중위 순회를 이해했다면 이후 과정도 쉽게 상상할 수 있을 것이다.

<img src="https://github.com/user-attachments/assets/88db69ca-f7fa-4063-b237-f590275ec051" width="250"/><br/>

**[5단계]** 노드 3은 2 -> (오른쪽 자식 없음) -> 3이다. 2는 이미 방문했고, 오른쪽 자식이 없으니 자신을 출력하고 거슬러 올라간다.

<img src="https://github.com/user-attachments/assets/c11f57aa-0315-4b29-998e-07ede8d0c26f" width="250"/><br/>

**[6단계]** 이런 식으로 방문하면 2 -> 3 -> 5 -> 4 -> 6 -> 7 -> 8 -> 1 순서로 방문한다.

<img src="https://github.com/user-attachments/assets/73c2ef38-8c28-4e34-ad21-03f4fbbb9e59" width="600"/><br/>

지금은 이해가 잘 되지 않겠지만 노드를 삭제할 때는 부모를 먼저 삭제하면 안 된다. 자식 노드부터 삭제해야 트리를 유지하며 재귀로 루트 노드까지 삭제할 수 있기 때문이다.
그래서 자식 노드부터 방문한다는 특성이 있는 후위 순회는 트리 삭제에 자주 활용한다.

### 🥎 포인터로 표현하기
이번에는 포인터로 트리를 표현하는 방법을 알아보자. 포인터로 트리를 표현하려면 노드부터 정의해야 한다. 다음 그림처럼 노드는 노드의 값, 왼쪽 자식 노드와 오른쪽 자식 노드를 가진다.

<img src="https://github.com/user-attachments/assets/e2e830e5-bcb5-46ff-942e-c3c90e95440d" width="500"/><br/>

이 노드 구성을 트리에 적용하면 다음과 같다.

<img src="https://github.com/user-attachments/assets/5f820871-4732-4109-94f3-8c17e2fcb157" width="650"/><br/>

포인터로 표현한 트리는 배열과 달리 인덱스 연산을 하지 않으므로 메모리 공간을 낭비하지 않는다만 실제 노드를 따라가도록 구현해야 하므로 구현 난이도는 배열로 표현한 트리에 비해 조금 높다.

### 🥎 인접 리스트로 표현하기
이번에는 인접 리스트로 트리를 표현하는 방법을 알아보자. 인접 리스트로 트리를 표현하려면 정점의 번호(수)만큼 리스트를 만들어야 한다. 리스트는 해당 정점에서 연결된 노드의 번호가 된다.

<img src="https://github.com/user-attachments/assets/6c8a225d-c269-47f3-ae0a-3f65da1f9b5d" width="500"/><br/>

인접 리스트로 표현하면 자식 노드의 수가 2개 이상일 경우도 표현하기 좋다.
또한 메모리 공간이 크게 낭비되지도 않고, 어떤 정점에서 이동할 수 있는 다음 정점을 빠르게 탐색할 수도 있어 시간 복잡도 면에서도 상당히 이점이 많아 인접 리스트는 트리를 포함한 그래프 문제에서
가장 많이 사용하는 표현 방식이다.

<br/>

## 3. 이진 트리 탐색하기
**이진 트리에서 가장 중요한 것은 바로 탐색을 효율적으로 할 수 있도록 트리를 구축하는 것이다.** 물건을 잘 정리해두면 쉽게 찾을 수 있는 것과 같다.
이진 트리는 자식 노드가 최대 2개인 트리를 말하며 목적에 따라 여러 종류가 있다. 여기서는 이진 탐색 트리(binary search tree)를 만들고, 이를 활용해 원하는 노드를 효율적으로 찾는 방법을 알아보자.

### 🥎 이진 탐색 트리 구축하기
이진 탐색 트리의 대상 데이터가 3 -> 4 -> 2 -> 8 -> 9 -> 7 -> 1 순서로 들어온다고 생각하고 이진 탐색 트리부터 구축하도록 하자.
**이진 탐색 트리는 데이터 크기를 따져 크기가 작으면 왼쪽 자식 위치에, 크거나 같으면 오른쪽 자식 위치에 배치하는 독특한 정렬 방식을 갖고 있다.**
다음을 보면 데이터를 전부 삽입한 다음 정렬하는 것이 아니라 데이터를 하나씩 삽입하면서 이진 탐색 트리를 구축한다. 즉, 삽입과 동시에 정렬을 한다.

**[1단계]** 최초의 데이터는 루트 노드가 된다. 3을 이진 탐색 트리에 루트 노드로 추가한다.

<img src="https://github.com/user-attachments/assets/1a2ae168-cecc-41e5-9b6e-81c941b1eaa5" width="50"/><br/>

**[2단계]** 현재 삽입하려는 데이터는 4이다. 3보다 크므로 오른쪽 자식 위치에 배치한다.

<img src="https://github.com/user-attachments/assets/231b242a-4a8f-4df2-b2f5-8def33c5f4e0" width="150"/><br/>

**[3단계]** 현재 삽입하려는 데이터는 2이다. 2는 3보다 작으므로 왼쪽 자식 위치에 삽입한다.

<img src="https://github.com/user-attachments/assets/8cedbeb4-a464-4ebb-89a2-f9a2e6e8ae0b" width="200"/><br/>

**[4단계]** 현재 삽입하려는 데이터는 8이다. 8은 3보다 크므로 오른쪽 자식 위치를 본다. 이미 자식이 있는 경우 값을 비교한다. 8은 4보다 크므로 오른쪽 자식 위치를 본다.
위치가 비어 있으므로 8을 배치한다. 이런식으로 이진 탐색 트리를 구축할 때는 넣으려는 대상 데이터의 값이 크거나 같으면 오른쪽 자식으로, 작으면 왼쪽 자식으로 배치한다.

<img src="https://github.com/user-attachments/assets/cefe0618-c279-443f-9de4-dd8fa7eb44da" width="230"/><br/>

**[5단계]** 9는 3보다 크므로 오른쪽을 본다. 4보다도 크므로 다시 오른쪽을 본다. 8보다도 크다. 오른쪽에 배치한다.

<img src="https://github.com/user-attachments/assets/365a716e-9c3f-4546-ad34-5b993e802ad2" width="200"/><br/>

**[6단계]** 7은 3보다 크고, 4보다 크고, 8보다는 작으므로 8의 왼쪽 자식에 배치한다.

<img src="https://github.com/user-attachments/assets/8b75df62-9707-4150-af1c-78d1e710e55f" width="200"/><br/>

**[7단계]** 1은 3보다 작고, 3보다 작으니 2의 왼쪽 자식에 배치한다.

<img src="https://github.com/user-attachments/assets/1319f616-f445-49ab-a373-510a5a966aa4" width="230"/><br/>


### 🥎 이진 탐색 트리 탐색하기
이제 탐색해보자. 이진 탐색 트리를 탐색하는 방법은 다음과 같다.
- (1) 찾으려는 값이 현재 노드의 값과 같으면 탐색을 종료하고 크면 오른쪽 노드를 탐색한다.
- (2) 본인이 찾으려는 값이 현재 노드의 값보다 작으면 왼쪽 노드를 탐색한다.
- (3) 값을 찾으면 종료한다. 노드가 없을 때까지 계속 탐색했는데 값이 없으며녀 현재 트리에 값이 없는 것이다.

검색 대상 트리는 다음과 같다. 여기서 5를 찾는다고 생각해보자.

<img src="https://github.com/user-attachments/assets/6d9f9ca3-f46d-4857-be02-74f982b67fd5" width="250"/><br/>

3보다 크니 우선 오른쪽을 본다. 6보다는 작으니 왼쪽을 본다. 왼쪽에는 아무것도 없다. 이진 탐색 트리를 구축한 방식대로 찾았을 때 5가 없으므로 이 트리에는 5가 없다고 판단해도 된다.

#### [배열 탐색과 비교하면 어떨까?]
이진 탐색 트리의 탐색 과정은 쉽게 이해했을 것이다. 그런데 왜 굳이 이렇게 탐색할까? 그건 배열 탐색과 비교해보면 금방 알 수 있다. 배열에서는 (아마 다 알고 있겠지만) 다음과 같이 순차적으로 5를 찾는다.

<img src="https://github.com/user-attachments/assets/2066b7a7-8a25-4e73-8afb-d181ea0ba561" width="300"/><br/>

5가 없다는 것을 알아내기 위해 7번의 비교 연산을 진행했다. 그에 반해 이진 탐색 트리는 단 2번만 비교 연산을 진행하여 알아냈다. 이런 점에서 배열 탐색보다 이진 탐색 트리의 탐색이 훨씬 빠르다고 할 수 있다.
그럴 수 있는 이유는 이진 탐색 트리의 구축 방식에 있다.

#### [이진 탐색 트리는 크면 오른쪽, 작으면 왼쪽]
모든 탐색 알고리즘에서 탐색 효율을 개선하는 방법은 같다. 탐색 대상이 아닌 노드를 한 번에 많이 제외할 수 있으면 된다. 방에서 핸드폰을 찾는다고 가정해보자.
모든 물건을 방 하나에 몰아 놓으면 방에 있는 물건을 전부 확인하며 핸드폰을 찾아야 한다. 하지만 전자기기만 따로 분류해서 정리해 놓았다면 다른 곳은 아예 찾을 필요가 없다.
이렇게 탐색 대상이 아닌 것들을 빠르게 제외하면 원하는 것을 빠르게 찾을 수 있다. 이진 탐색 트리의 원리도 동일하다.
이진 탐색 트리의 구축 방식 자체가 갖는 특성은 **데이터 크기에 따라 하위 데이터 중 한 방향을 검색 대상에서 제외하므로** 검색을 빠르게 만들어준다.
앞서 5를 찾을 때를 다시 생각해보자. 루트 노드 3보다 크다는 판단을 내리면서 하위의 왼쪽 데이터는 검색 대상에서 제외해버렸다.

#### [이진 탐색 트리의 시간 복잡도]
이진 탐색 트리의 시간 복잡도는 트리 균형에 의존한다. 트리의 균형이 잡혔다는 건 각 노드의 차수가 비슷하게 유지되면서 각 노드의 자식 노드 수가 비슷하게 유지되는 것을 말한다.
균형이 유지되었다고 가정했을 때 삽입과 탐색 연산 시 이진 탐색 트리에 저장된 노드가 N개라고 하면 시간 복잡도는 O(logN)이다. 하지만 균형이 맞지 않을 때는 시간 복잡도가 배열과 비슷하다.
왜 그런지 바로 이어서 알아보자.
- 균형이 잡혀 있다는 건 왼쪽과 오른쪽 서브 트리의 높이 차가 1 이하인 경우를 말한다. 그렇지 않을 때 균형이 잡혀 있지 않다라고 표현한다.

### 🥎 이진 탐색 트리와 배열 탐색의 효율 비교
지금까지의 설명을 읽으면 이런 생각을 할 수 있다.
- '이진 탐색 트리에서 탐색하는 것이 배열에서 탐색하는 것보다 효율이 좋은 것 같네!'

하지만 두 자료구조의 삽입과 탐색 시간 복잡도는 이진 탐색 트리의 균형이 맞지 않으면, 다시 말해 최악의 경우 "O(N)으로 같다"라고 이야기한다. 약간의 전제가 필요하긴 하다.
그 이야기를 잠깐 하고 넘어가자.

#### [치우쳐진 형태의 트리]
이진 탐색 트리가 만약 이런 형태를 하고 있다면 어떨까?

<img src="https://github.com/user-attachments/assets/2ab21ae2-41db-4eed-b631-38309efdbe0c" width="250"/><br/>

이진 트리는 왼쪽 혹은 오른쪽 자식 노드만 있어야 한다. 그런데 오른쪽 자식만 있는 것이다. 모든 노드가 루트 노드인 3보다 커서 오른쪽으로 치우쳐졌다.
이런 트리에서 9를 찾는다면 모든 노드를 다 탐색해야 하므로 O(N)의 시간 복잡도가 필요하다. 다만 이렇게 극단적으로 치우친 경우는 지극히 예외 상황이다.
사실 대부분의 상황에서는 이진 탐색 트리의 탐색 성능이 더 좋다. 다만 이렇게 치우쳐지지 않도록 균형을 유지하는 이진 탐색 트리가 있다.

#### [균형 이진 탐색 트리]
그런 이진 탐색 트리들을 균형 이진 탐색 트리(balanced binary search tree)라고 한다. 균형 이진 탐색 트리는 또 세부적으로 AVL 트리, 레드-블랙 트리 등으로 구분하여 부른다.
균형 이진 탐색 트리를 활용하면 이진 트리의 탐색 연산 횟수가 트리 높이에 비례하고 트리의 높이는 logN이므로 탐색 시간 복잡도를 O(logN)으로 유지할 수 있다.
다만 균형 이진 탐색 트리 구현은 난이도가 너무 높아서 코딩테스트에는 나오지 않을 가능성이 매우 높다. 트리를 더 공부하고 싶다면 자료구조 책 등을 이용하여 깊이 공부하기 바란다.

<br/>

## 4. 몸풀기 문제
### [문제 25] 트리 순회
- 권장 시간 복잡도 : O(N)

> 이진 트리를 표현한 리스트 nodes를 인자로 받습니다. 예를 들어서 nodes가 [1, 2, 3, 4, 5, 6, 7]이면 다음과 같은 트리를 표현한 것입니다.
> 해당 이진 트리에 대하여 전위 순회, 중위 순회, 후위 순회 결과를 반환하는 solution() 함수를 구현하세요.

<img src="https://github.com/user-attachments/assets/4ef96d1a-138f-4056-a0c4-336802ae8eb2" width="250"/><br/>

#### [제약 조건]
- 입력 노드값의 개수는 1개 이상 1,000개 이하이다.
- 노드값은 정수형이며, 중복되지 않는다.

#### [입출력의 예]
|nodes|return|
|:---:|:---:|
|[1, 2, 3, 4, 5, 6, 7]|["1 2 4 5 3 6 7", "4 2 5 1 6 3 7", "4 5 2 6 7 3 1"]|

#### [문제 분석하고 풀기]
말 그대로 전위, 중위, 후위 순회를 반환하면 되는 문제이다.

```java
class Solution {
  public static String[] solution(int[] nodes) {
    String[] result = new String[3];
    result[0] = preorder(nodes, 0).trim();  // 마지막 공백 제거
    result[1] = inorder(nodes, 0).trim();  // 마지막 공백 제거
    result[2] = postorder(nodes, 0).trim();  // 마지막 공백 제거
    return result;
  }

  private static String preorder(int[] nodes, int idx) {
    if (idx >= nodex.length) {  // idx가 범위를 벗어나면 빈 문자열 반환
      return "";
    }

    // 루트 노드 -> 왼쪽 서브 트리 -> 오른쪽 서브 트리 순으로
       재귀 호출하여 결과를 이어 붙임
    return nodes[idx] + " " +
            preorder(nodes, 2 * idx + 1) +
            preorder(nodex, 2 * idx + 2);
  }

  private static String inorder(int[] nodes, int idx) {
    if (idx >= nodes.length) {  // idx가 범위를 벗어나면 빈 문자열 반환
      return "";
    }

    // 왼쪽 서브 트리 -> 루트 노드 -> 오른쪽 서브 트리 순으로 재귀 호출하여 결과를 이어 붙임
    return inorder(nodes, 2 * idx + 1) +
            nodes[idx] + " " +
            inorder(nodes, 2 * idx + 2); 
  }

  private static String postorder(int[] nodes, int idx) {
    if (idx >= nodes.length) {  // idx가 범위를 벗어나면 빈 문자열 반환
      return "";
    }

    // 왼쪽 서브 트리 -> 오른쪽 서브 트리 -> 루트 노드 순으로 재귀 호출하여 결과를 이어 붙임
    return postorder(2 * idx + 1) +
            postorder(2 * idx + 2) +
            nodes[idx] + " ";

  }
}
```

위 코드에서 nodes는 노드 리스트를 의미하며 solutino() 메서드에서는 이 nodes 리스트와 루트 노드의 인덱스를 preorder(), inorder(), postorder() 메서드에 인수로 전달하여
전위 순회, 중위 순회, 후위 순회 결과를 각각 계산하고 이를 리스트로 반환한다.
preorder(), inorder(), postorder() 메서드에서는 idx가 노드 배열의 길이보다 작을 때만 재귀 호출하도록 하며 idx가 노드 배열의 길이와 같거나 크면 빈 문자열을 반환한다.
solution() 메서드에서는 반환된 결과 문자열에서 마지막 공백을 제거한 뒤 배열로 반환한다.
- 이 문제의 핵심은 '배열로 표현한 이진 트리를 순회하는 코드를 구현하라'이다. 아서 배열로 트리를 표현할 때 루트 노드가 인덱스 0이 될 수도, 인덱스 1이 될 수도 있지만 1을 자주 쓴다고 했다.
  여기서는 1이 아닌 0을 쓰는 경우를 보여주기 위해 루트 노드 인덱스를 0으로 하였다.


#### [시간 복잡도 분석하기]
N은 노드의 개수이다. 전위, 중위, 후위 연산 모두 각 노드를 한 번씩 방문하므로 시간 복잡도는 O(N)이다.