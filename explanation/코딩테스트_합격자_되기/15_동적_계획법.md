# 15. 동적 계획법

<br/>

---
## 1. 동적 계획법 개념

동적 계획법(dynamic programming)을 간단히 정의하면 전체 문제를 한 번에 해결하는 것이 아니라 작은 부분 문제들을 해결하고, 이것들을 활용하여 전체 문제를 해결하는 방법이라고 할 수 있다.
하지만 부분 문제를 활용하여 전체 문제를 해결했다고 해서 반드시 동적 계획법이 효율적인 것은 아니다. 동적 계획법을 효율적으로 활용하려면 아래 두 가지 조건을 만족해야 한다.

- 큰 문제를 작은 문제로 나누었을 때 동일한 작은 문제가 반복돼서 등장해야 한다.
- 큰 문제의 해결책은 작은 문제의 해결책의 합으로 구성할 수 있어야 한다.

정의에서 **큰 문제를 작은 문제로 나누었을 때 동일한 작은 문제가 반복해서 등장해야 된다**는 말의 의미가 쉽게 와닿지 않을 수 있다.
또 어떤 사람은 'divide and conque 전략인 건 아닐까?'라는 생각을 할 수도 있다. 다음 그림을 보자.

<br/>

<img src="https://github.com/user-attachments/assets/cbbd519d-cb38-4241-a2e2-f356c4937675" width="400"><br/>

<br/>

A, B, C, D는 부분 문제이다. 이것들을 해결하여 합쳐 전체 문제를 해결한 것을 나타낸 그림이다. 다만 이 작은 문제들은 서로 완전히 다르다. 앞서 동적 계획법은 작은 문제가 반복되어야 한다고 했다.
지금 이 그림은 작은 문제가 반복되는 형태가 아니므로 큰 문제를 작은 문제로 나누기는 했지만 결국 연산 횟수는 동일할 것이므로 효율적이라 보기는 어렵다.

그림으로 표현하자면 아래와 같은 구조가 되어야 한다. 작은 문제의 구성을 보면 동일한 작은 문제 A가 반복된다.

<br/>

<img src="https://github.com/user-attachments/assets/f67d19c3-a3fc-4b66-bd01-cacd1321c4e4" width="470"><br/>

<br/>

이처럼 동적 계획법의 핵심은 단순히 작은 문제를 조합해서 큰 문제를 해결한다가 아니다. **이 작은 문제들이 같아야 하고 반복되어야 한다**. 그 점이 분할 정복과 다르다.
이 반복되는 작은 문제들을 해결하여 합하면 자연스럽게 큰 문제를 해결할 수 있어야 한다.

- 작은 문제의 해결책의 합으로 큰 문제를 해결할 수 있는 구조를 **최적 부분 구조(optimal substructure)** 라고 한다.
- 큰 문제를 나누었을 때 작은 문제가 여러 개 반복되는 문제를 **중복 부분 문제(overlapping subproblem)** 라고 한다.

<br/>

### 🥎 점화식 세우기와 동적 계획법
동적 계획법으로 문제를 해결하는 절차는 다음과 같다.

> 1. 문제를 해결하는 해가 이미 있다고 가정한다.
>
> 2. 종료 조건을 설정한다.
>
> 3. 과정 1, 2를 활용해 점화식을 세운다.


절차만 보면 감이 잘 잡히지 않을 것이다. 팩토리얼을 동적 계획법으로 해결하는 과정에 이 절차를 이해해보자.
물론 팩토리얼은 앞서 언급한 중복 부분 문제 조건에는 맞지 않지만, 부분 문제로 전체 문제를 해결하는 동적 계획법의 큰 결을 이해하는 데는 좋은 예이다.

**[1단계]** Fact(N)이라는 팩토리얼 값을 반환하는 함수가 있다고 가정하자. 뭔가 구체화한 것은 없지만 일단 있다고 가정하자.

**[2단계]** 그림을 그려 Fact(N)의 종료 조건을 알아낸다. 팩토리얼은 N부터 N - 1, N - 2, ..., 1까지 곱한 값이므로 다음 그림을 그려 종료 조건을 생각해본다.
여기서 집중해서 봐야할 것은 팩토리얼의 일반 계산식을 Fact(N) 함수를 이용하여 어떻게 표현했고, 이 함수를 어디까지 쪼개다가 종료하는지이다.

<br/>

<img src="https://github.com/user-attachments/assets/508642ac-4ab1-40e7-8979-4dfefc167e61" width="550"><br/>

<br/>

그림을 보면 Fact(N)부터 시작하여 팩토리얼 계산식을 쪼갠다. 예를 들어 N!는 Fact(N - 1)과 N의 곱으로 쪼갠다. 그러나 Fact(N - 1)도 Fact(N - 2)과 N - 1의 곱으로 쪼갤 수 있다.
계속해서 쪼개다보면 Fact(1)까지 가서야 더 쪼갤 수 없는 상태에 도달한다.

**[3단계]** 그림을 통해 어떻게 팩토리얼을 쪼갤 수 있는지 확인했으므로 점화식을 세운다.
- Fact(N) = Fact(N - 1) * N &nbsp;&nbsp;&nbsp;(N > 1)
- Fact(1) = 1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N = 1)

점화식을 보면 N이 1보다 크면 위의 식을 통해 다음 식으로 쪼갠다. 그러다가 N이 1이 되면 쪼개는 과정을 종료한다. 앞에서 본 그림을 식으로 표현했다 생각하면 된다.

<br/>

### 🥎 점화식 구현 : 재귀 활용
그럼 점화식을 어떻게 구현할지도 보겠다. 여기서는 재귀를 활용하여 점화식을 구현하는 방법을 설명한다. 재귀는 재귀 함수의 반환값을 활용한다는 특징이 있다.
팩토리얼을 재귀로 구현하기 위해 어떻게 해야 할지 잠시 그림과 함께 생각해보자. 우선 점화식을 재귀로 표현한 의사 코드는 다음과 같다.

```java
int fact(int N) {
  if(N이 1이면) 1 반환  // 종료 조건
  else fact(N - 1) * N 반환  // 일반항
}
```

**[1단계]** fact(5)는 fact(4) * 5를 반환하며 fact(4)를 재귀 호출한다.

**[2단계]** 그러면 fact(4)는 fact(3) * 4를 반환하며 fact(3)을 재귀 호출한다.

**[3단계]** 그 이후들도 마찬가지이다. 종료 조건을 만나기 전까지는 계속해서 재귀 호출한다. 그러다가 fact(1)을 만나면 1을 반환하여 종료한다.

<img src="https://github.com/user-attachments/assets/be15b2a2-7502-4d35-977c-0be5c51ac212" width="200"><br/>

재귀 방식으로 점화식을 구현하는 방법을 알아보았다. 다만 이 방식은 함수를 계속하여 재귀 호출하므로 스택 메모리에 재귀 호출한 함수들이 모두 쌓이는 부담이 있다.
예를 들어 fact(N)을 호출하면 N개의 함수 호출 정보가 스택 메모리에 쌓인다.

<br/>

<img src="https://github.com/user-attachments/assets/0528fb27-9c75-45be-8344-5a44fe013294" width="250"><br/>

<br/>

호출한 함수가 많으면 많을수록 스택 메모리에 함수 호출 정보가 많이 쌓일 것이다. 그래서 입력값이 크다면 정답은 맞을 지언정 메모리 한계로 런타임 오류가 발생할 수 있다.
그래서 재귀 호출을 사용하기 전에는 항상 메모리 한계에 대한 생각을 하고 이 문제가 발생하지 않도록 하는 것이 중요하다. 재귀 호출을 해서 문제가 생겼거나, 생길 것 같을 때 취할 수 있는 방법은 다음과 같다.

> 1. 재귀 호출 자체를 쓰지 않는 법 → 반복문
>
> 2. 재귀 호출의 횟수를 줄이는 법 → 메모이제이션

<br/>

### 🥎 재귀 호출의 횟수를 줄여주는 메모이제이션
여기서는 재귀 호출의 횟수를 줄이는 방법인 메모이제이션을 알아보자. 메모이제이션은 이미 계산한 값을 저장해두었다가 이후 쓸 일이 있을 때 활용하는 개념이다.
예를 들어 fact(5)를 계산하는 과정에서 중간에 호출한 fact(4), fact(3), ...의 해를 메모이제이션한다면 이후에는 같은 연산이 있을 때 반복하지 않아도 된다.

<br/>

<img src="https://github.com/user-attachments/assets/60c5f765-78ac-41b1-9af5-1da31a263a44" width="530"><br/>

<br/>

그림에서 보듯 메모이제이션으로 fact(1)부터 fact(5)까지 해를 저장해두면 N이 5 이하인 경우에 대해서는 fact()의 추가 연산을 하지 않아도 된다.
위 그림에서 fact(6)은 fact(5)를 다시 호출하는 것이 아니라 메모이제이션한 값을 활용하여 계산하고 있다. 이렇게 메모이제이션은 반복 연산 횟수를 줄여 알고리즘의 성능을 올려준다.

#### [팩토리얼은 최적 부분 구조이지만 중복 부분 문제는 아니다]
팩토리얼은 엄밀히 말해 최적 부분 구조이기는 하지만 중복 부분 문제는 아니다. 아마 팩토리얼 문제를 메모이제이션으로 푸는 과정을 그림으로 표현한 것을 보고 메모이제이션의 효율이 크게 느껴지진 않았을 것이다.
왜냐하면 팩토리얼을 구하는 과정에서 각 숫자를 한 번씩만 곱하므로 중복 문제가 발생하지 않기 때문이다. 따라서 팩토리얼을 구하는 과정에서 중복 부분 문제는 해결할 일이 없다.
그럼에도 팩토리얼을 예로 든 이유는 설명의 편의 때문이다. 연산 자체가 간단하고 동적 계획법에서 부분 문제를 활용해서 전체 문제를 해결하는 과정과 메모이제이션의 개념을 쉽게 설명할 수 있었기 때문이다.
혹시라도 의문을 가진 독자가 있다면 그 의문을 이 글을 통해 해소하기 바란다.

<br/>
이제 기본기를 어느 정도 갖추었으므로 한 걸음 나아가보자. 이번에 풀 문제는 피보나치 수 구하기이다.
**피보나치 수 구하기 문제**는 최적 부분 구조이면서 중복 부분 문제에 해당하므로 동적 계획법의 효율을 크게 느낄 수 있는 문제일 것이다.

<br/>

### 🥎 점화식 구현 : 재귀 + 메모이제이션 활용
여기서는 재귀와 메모이제이션의 활용을 잘 보여줄 수 있는 피보나치 수열을 이용하여 설명한다. 다음과 같이 재귀에 메모이제이션을 조합해보자.

> 1. 메모이제이션을 위한 저장소 생성 : 이미 구한 해를 저장할 공간을 생성한다.
>
> 2. 재귀 함수 정의 : 점화식을 재귀로 표현할 함수를 정의한다. 이때 함수의 세부 구현은 고려하지 않는다.
>
> 3. 재귀 함수의 종료 조건을 정의 : 예를 들어 피보나치 수의 첫 번째, 두 번째 수는 1로 정해져 있으므로 메모이제이션 저장소에 해를 미리 넣어두고 종료 조건으로 생각한다.
>
> 4. 재귀 함수의 일반 연산 처리 : 보통 동적 계획법에서는 점화식으로 나머지 문제를 처리한다. 그 과정에서 구한 결괏값은 메모이제이션 저장소에 저장한다.

<br/>

우선 점화식을 재귀와 메모이제이션으로 어떻게 구현할지에 대한 의사코드를 작성한다.

```java
fibodata[N]  // 메모이제이션을 위한 배열 선언, 0으로 초기화
        (메서드를 정의)
int fibo(int N) {
  if(fibodata[N] != 0) fibodata[N] 반환  // 메모이제이션 활용
  if(N이 2 이하이면) fibodata[N]에 1 삽입  // 메모이제이션, 종료 조건
  else fibodata[N]에 fibo(N - 1) + fibo(N - 2) 삽입  // 메모이제이션, 일반항
}
fibo(N) 호출
fibodata[N] 반환
```

**[1단계]** 의사 코드에 작성한 대로 배열을 선언하고 값을 초기화한다. 설명의 편의를 위해 fibodata[0]에는 아무 값도 할당하지 않았다.

<img src="https://github.com/user-attachments/assets/8cdbe027-fd45-4d94-8f73-9c64aa6d5b7c" width="220"><br/>

**[2단계]** fibo(5)를 호출한다. fibo(4) + fibo(3)을 fibodata[5]에 저장하며 두 함수를 재귀 호출한다.

<img src="https://github.com/user-attachments/assets/8236c748-caff-4c22-9b30-429b78ddced9" width="380"><br/>

**[3단계]** fibo(4)도 마찬가지이다. 다시 fibo(3) + fibo(2)를 fibodata[4]에 저장하며 두 함수를 재귀 호출한다. 그다음은 fibo(3)이다.
fibo(3)도 마찬가지이다. fibodata[3]에 fibo(2) + fibo(1)을 저장하며 재귀 호출한다. 여기부터 메모이제이션이 시작된다.
fibo(2), fibo(1)은 각각 fibodata[2], fibodata[1]에 1을 메모이제이션한다.

<img src="https://github.com/user-attachments/assets/80a99639-944f-4d1d-95a1-92a1b996111e" width="550"><br/>

**[4단계]** 그러면 fibodata[2], fibodata[1]의 값이 정해졌으므로 fibodata[3]에 값을 저장할 수 있다.

<img src="https://github.com/user-attachments/assets/0745b702-e240-43f1-91ee-031b2aab6bfc" width="540"><br/>

**[5단계]** ❶ fibo(4)도 이제 값을 fibodata[4]에 저장할 수 있게 되었다. fibo(5)도 메모이제이션을 끝낸 fibodata[4], fibodata[3]으로 계산할 수 있다.
❷ 이때 fibo(2), fibo(3)의 경우 이미 메모이제이션을 했으므로 따로 연산하지 않는다. 이것이 메모이제이션의 유용함이다.
만약 메모이제이션을 하지 않았다면 재귀호출을 반복해서 이전에 구한 피보나치 값들을 구했어야 할 것이다.

<img src="https://github.com/user-attachments/assets/1780ce7b-4c1d-4bea-9613-cc862f28f921" width="580"><br/>

지금까지 팩토리얼과 피보나치 수열을 통해 동적 계획법으로 문제를 해결하는 방법을 알아보았다. 지금까지 문제를 해결한 과정은 다음과 같다.

- 점화식 작성(가정한다)
- 재귀 방식으로 풀어보기(반복한다)
- 동적 계획법으로 재귀 + 메모이제이션으로 구현(기억한다)

점화식으로 문제를 작은 문제로 나눠서 접근하는 과정을 공부했고(최적 부분 구조), 메모이제이션으로 반복되는 작은 문제에 연산 횟수를 효율적으로 줄일 수 있다는 것을 알았다(중복 부분 문제).
그리고 코딩 테스트에서는 배열을 활용하여 메모이제이션하기를 추천한다. 그러면 동적 계획법을 응용해보기 좋은 몇몇 문제들을 조금 더 함께 고민해보겠다. 먼저 볼 내용은 최장 증가 부분 수열이다.

<br/>

### 🥎 최장 증가 부분 수열
최장 증가 부분 수열을 이해하려면 부분 수열이 무엇인지 알아야 한다. 그러니 부분 수열부터 설명하겠다.

#### [부분 수열이란?]
부분 수열이란 주어진 수열 중 일부를 뽑아 새로 만든 수열을 말한다. 이때 각각의 원소는 전후 관계를 유지해야 한다. 이를테면 다음과 같은 수열에서 2, 3, 1, 7을 뽑으면 이것이 부분 수열이 된다.
잘 보면 원소를 뽑을 때 5를 건너뛰었지만 1과 7의 순서가 바뀌거나 하지 않았다.

<br/>

<img src="https://github.com/user-attachments/assets/8c01b43d-234b-4a0e-9578-18ac160f5d03" width="300"><br/>

<br/>

#### [최장 증가 부분 수열이란?]
최장 증가 부분 수열(long increasing subsequence)이란 부분 수열의 원소가 오름차순을 유지하면서도 길이가 가장 긴 수열을 말한다.
앞서 본 수열에서 1, 2, 3, 5, 7을 뽑으면 최장 증가 부분 수열이 된다. 최장 증가 부분 수열이라는 말이 너무 기므로 앞으로는 LIS라고 부르겠다.
- 최장 증가 부분 수열은 엄격하게 증가하는 오름차순이어야 한다. 예를 들어 1, 1, 3, 5는 같은 값이 존재하므로 최장 증가 부분 수열이 아니다.

<br/>

<img src="https://github.com/user-attachments/assets/deca4a5a-c64f-4ce4-b317-ef6cc236c09d" width="300"><br/>

<br/>

#### [LIS의 길이 동적 계획법으로 구하기]
**동적 계획법으로 LIS의 길이를 구해보자.** LIS를 처음 공부하는 사람에게는 이 문제가 조금 어렵게 느껴질 수 있다. 왜냐하면 LIS는 수열의 숫자 크기와 위치를 동시에 고려해야 하는 문제이기 때문이다.
그런데 가만 생각해보면 LIS에는 이런 특징이 있다.

- 숫자가 점점 증가함
- 원소 간의 전후 관계는 유지함

**이제 우리가 고민할 문제는 가장 긴 증가 부분 수열을 어떻게 찾는지이다.** 동적 계획법을 활용하려면 문제를 좀 더 작은 문제로 쪼갤 필요가 있다. 우리는 다음과 같이 문제를 쪼갤 수 있다.

<br/>

<img src="https://github.com/user-attachments/assets/de7dc33b-453f-4b11-bb52-2b2f47a893a2" width="600"><br/>

<br/>

그림을 보면 전체 수열의 LIS 길이를 구하는 문제는 각 숫자로 끝나는 LIS 길이 중 최댓값을 구하는 문제로 바꾼 것임을 알 수 있다(최적 부분 구조).
그리고 점선 화살표를 보면 각 숫자로 끝나는 LIS를 구할 때 이전 LIS 길이를 참조하고 있다. 예를 들어 그림에서 5로 끝나는 LIS 길이를 구할 때는 이전에 이미 구한 1로 끝나는 LIS의 길이를 참조한다.
2로 끝나는 LIS 길이를 구할 때는 1, 5로 끝나는 LIS 길이를 참조한다(중복 부분 문제). 그러니 특정 숫자로 끝나는 LIS 길이를 안다면 LIS 길이를 구할 수 있을 것이다.

그렇다면 특정 숫자로 끝나는 LIS 길이는 어떻게 구할 수 있을까? 앞에서 찾은 특정 원소로 끝나는 LIS 길이 중 가장 큰 것에 1을 더하면 된다.

<br/>

<img src="https://github.com/user-attachments/assets/a4d974d7-f724-4082-883f-2058d0b37d1e" width="600"><br/>

<br/>

단, 앞의 원소는 자기보다 작아야 한다. 왜냐하면 최종 LIS는 점점 원소가 커지는 방향이어야 하기 때문이다. 예를 들어 위 그림에서 가리키는 3으로 끝나는 LIS 길이는 2로 끝나는 LIS 길이에 1을 더하면 된다.
**이때 4로 끝나는 LIS 길이도, 2로 끝나는 LIS 길이와 마찬가지로 2이다. 하지만 3으로 끝나는 LIS를 구할 때는 3보다 4는 크므로 4는 선택하면 안 된다.**
이 말은 LIS 길이를 구하기 위해 이전 LIS 길이를 활용한다는 것과 같다. 이제 점화식을 세울 수 있다.

여기서는 메모이제이션을 위한 dp 배열에 각 원소로 끝나는 LIS의 길이를 저장하고 마지막에 dp 배열에 있는 값 중 가장 큰 값을 최종 LIS의 길이로 생각한다.
정리하면 dp는 다음과 같다.

- dp[N] = arr[N]을 마지막 원소로 하는 LIS의 길이

이를테면 dp[1]은 수열 arr의 1번째 원소에서 끝나는 LIS의 길이이므로 1이고, dp[3]은 수열 arr의 3번째 원소에서 끝나는 LIS의 길이이므로 2이다.

<br/>

<img src="https://github.com/user-attachments/assets/03385c61-2198-4724-924c-60c1e56a39de" width="300"><br/>

<br/>

dp로 점화식을 세우면 아래와 같다.

- dp[N] = max(dp[K]) + 1(단, K는 1 <= K < N, arr[K] < arr[N])
- dp[1] = 1(종료 조건)

점화식에서 첫 번째 식의 조건이 난해하게 느껴질 수 있다. 점화식을 자세히 뜯어보자. 우선 max(dp[K])는 dp[K] 중 최댓값을 의미한다.
이때 1 <= K < N과 arr[K] < arr[N]을 만족해야 하므로 N = 6인 경우 K는 여기서만 max(dp[K])를 찾아야 한다.

<br/>

<img src="https://github.com/user-attachments/assets/5eeedc5e-99ef-4713-a815-f90a8e6c5c01" width="300"><br/>

<br/>

쉽게 말해 dp[K]는 K를 마지막 원소로 하는 LIS의 길이이므로 앞에서 계산한 dp 중 가장 큰 값을 고르되, LIS를 유지할 수 있도록 arr[K] < arr[N]이어야 한다는 것이다.
점화식이 실제 동작하는 과정을 보자. 이 과정을 보면 좀 더 확실히 이해가 될 것이다.

**[1단계]** dp[1] = 1이므로 다음과 같이 dp를 초기화한다.

<img src="https://github.com/user-attachments/assets/8bcce44f-2e28-4262-99d6-024b8d6f6b11" width="300"><br/>

**[2단계]** dp[2]를 채워보자. 현재 K < 2이면서 arr[K] < arr[2]를 만족하는 가장 큰 arr[K]를 찾아야 한다. 지금은 비교 대상이 하나뿐이므로 K = 1이다. dp[1] + 1로 dp[2]를 갱신한다.

<img src="https://github.com/user-attachments/assets/40355d51-6526-44b2-bdce-fccd6c8b14b2" width="300"><br/>

**[3단계]** dp[3]도 채워보자. 그림을 보면 arr에서 뒤로 가며 arr[K] < arr[3]을 만족하는 K를 우선 찾고, 그다음에 dp[K]를 확인하여 가장 큰 값인지 확인한 다음 dp[3]을 갱신한다.

<img src="https://github.com/user-attachments/assets/2427e28f-2362-4c89-9f8e-a10f017fb10c" width="300"><br/>

**[4단계]** dp[4]도 채워보자. 지금은 arr[3]이 arr[4]보다 작고, dp 중 dp[3]이 가장 큰 값이므로 여기에 1을 더해 dp[4]를 갱신했다.

<img src="https://github.com/user-attachments/assets/9be1ef5a-1182-4fa9-910b-5b99350c1514" width="300"><br/>

**[5단계]** dp[5]는 다음과 같이 한다. dp[5]는 arr에서 만족하는 K가 1이다. 그래서 dp[1]에 1을 더해 갱신한다.

<img src="https://github.com/user-attachments/assets/c20504c1-890b-4998-b646-96705dbedc16" width="300"><br/>

**[6단계]** 나머지 모든 단계를 완료하면 dp는 다음과 같이 채워진다.

<img src="https://github.com/user-attachments/assets/54372dd4-53c5-4d25-9995-4f37039a4159" width="570"><br/>

**[7단계]** 이제 마지막으로 dp에서 가장 큰 값을 고르면 LIS의 길이를 구할 수 있다. 실제로 1, 2, 3, 5, 7이 LIS이어야 하므로 정답이 잘 맞는다.

<img src="https://github.com/user-attachments/assets/7badf1f2-59bf-401a-8f62-889dd9209041" width="300"><br/>

### 🥎 최장 공통 부분 수열
**최장 공통 부분 수열**은 LCS(longest common subsequence)라고 부른다.
부분 수열(subsequence)이라는 용어를 보고 단순히 '숫자의 나열이구나'라고 생각하기 쉽지만 수학적인 의미로는 '특정 순서로 숫자를 나열한 것'이라고 생각해야 한다.
다만 컴퓨터 과학에서는 수열의 의미를 조금 더 폭넓게 해석해야 한다. 컴퓨터 과학에서 수열은 특정 순서로 나열한 객체를 의미한다.
즉, 객체는 문자, 숫자 등의 자료형이므로 컴퓨터 과학에서 부분 수열은 특정 순서로 객체를 나열한 것이라고 생각해야 한다.
**따라서 최장 공통 부분 수열이라느 두 수열이 어떤 기준에 따라 양쪽에서 공통으로 발견할 수 있는 가장 긴 부분 수열을 의미한다.**
그리고 앞서 언급했듯이 부분 수열은 원소 사이의 순서만 유지하면 되고 반드시 연속할 필요는 없다. 일단 문장으로는 이 정도로 설명하고 그림을 통해 최장 공통 부분 수열이 무엇인지 이해해보자.
그리고 이후부터는 최장 공통 부분 수열은 LCS라 하겠다.

**[1단계]** 두 부분 문자열을 보자. 색칠한 부분응ㄹ 보면 문자열 1은 A, D, E, F이고 문자열 2는 A, D, E, F로 순서와 길이가 같으므로 공통 부분 수열이다.
그리고 공통으로 찾을 수 있는 가장 긴 부분 수열(길이가 4)이므로 LCS이다. 다만 다른 LCS가 있을 수도 있다.

<img src="https://github.com/user-attachments/assets/20f9412e-3df7-4197-b005-7e939d7a5e07" width="350"><br/>

**[2단계]** 이렇게 색칠해서 보면 A, C, E, F도 길이가 4인 LCS이다.

<img src="https://github.com/user-attachments/assets/36c0951e-157b-4084-85dc-4cf0d8a10fae" width="350"><br/>

#### [LCS 길이 찾는 방법?]
여기서는 입력값을 작게 하여 반복하여 풀 수 있는 작은 문제가 나오는지에 집중하자.

**[1단계]** 두 문자열의 길이가 1인 경우를 생각해보면 LCS의 길이는 문자의 값이 같은지에 따라 결정된다. 문자가 같으면 1 아니면 0이다.

**[2단계]** 이제 좀 더 긴 문자열을 보자. 문자열 x의 첫 번째 ~ 마지막 문자를 하나씩 짚어가면서 문자열 y의 문자들을 모두 비교하여 같은 것이 있는지 확인한다.

<img src="https://github.com/user-attachments/assets/dda0e631-7baf-4999-9115-89c4dc5d5832" width="170"><br/>

**[3단계]** x[1]과 y 문자열을 모두 비교했지만 같은 문자가 없다. 다음 문자로 넘어가 비교한다.

<img src="https://github.com/user-attachments/assets/e1782211-4874-4a44-8afc-bbb6c2a50b83" width="170"><br/>

**[4단계]** x[2]와 비교하니 동일한 문자가 있다. 다음을 또 보니 C가 같다. 직관적으로 B가 같고 그다음 위치에서 C가 같으므로 최장 공통 부분 수열은 B, C이며 길이는 2임을 알 수 있다.

<img src="https://github.com/user-attachments/assets/773c750e-7eea-4820-9f38-3bf680c7b8e1" width="370"><br/>

**[5단계]** 만약 문자의 순서가 역방향이라면 LCS는 B, C가 될 수 없었을 것이다.

<img src="https://github.com/user-attachments/assets/3ab9decd-0245-413a-a3d8-91cbeb721c84" width="170"><br/>

이점을 잘 기억하면서 LCS의 길이를 찾는 점화식도 생각해보자.

#### [LCS의 길이 점화식 생각하기]
앞에서 살펴본 대로 LCS의 길이를 구할 때는 2가지 조건을 검사해야 함을 알 수 있다.

- 두 문자열의 특정 문자가 같은지
- 같다면 찾은 두 문자의 위치가 이전에 찾은 문자의 다음에 있는지

**[1단계]** 이걸 어떻게 해야 동적 계획법에 사용할 수 있을까? 우선은 최장 공통 부분 수열의 길이를 반환하는 LCS() 함수를 다음과 같이 정의하자.

- LCS(i, j) = x[1 ... i]와 y[1 ... j]의 LCS의 길이

**[2단계]** 그러면 다음 그림에서 LCS(2, 3)에 1을 더하면 LCS(3, 4)가 됨을 알 수 있다.

<img src="https://github.com/user-attachments/assets/1eb7c42a-efcb-403b-819b-43e7a1817704" width="380"><br/>

**[3단계]** [2단계]는 C가 같아서 식이 성립했지만 만약 다르면 어떨까? 다음은 x[3]과 y[4]가 같지 않은 경우이다.

<img src="https://github.com/user-attachments/assets/b75954d9-31c6-4ba0-95c5-68b7f33dce06" width="170"><br/>

**[4단계]** 그러면 이 두 값 x[3], y[4]는 포함하지 않는 LCS의 길이를 찾아야 한다.
다시 말해 각 문자열에서 C이나 X를 뺀 가장 많은 문자열을 포함하는 LCS의 길이는 LCS(3, 3)이거나 LCS(2, 4)일 것이다.
다만 지금은 LCS(3, 3)도 1, LCS(2, 4)도 1이므로 아무거나 선택하면 된다. 이런 과정을 일반화하면 다음과 같을 것이다.

- x[i]와 y[j]가 다르면 LCS(i, j) = LCS(i - 1, j)와 LCS(i, j - 1)을 비교하여 큰 값으로 함

  <img src="https://github.com/user-attachments/assets/d1d53ac2-c72a-4e5e-9ebe-12019f1c9de1" width="380"><br/>

**[5단계]** 그림 LCS(i, j)의 점화식은 이렇게 정의할 수 있다.

- LCS(0, 0) = 0
- x[i] == y[j]이면 LCS(i - 1, j - 1) + 1
- x[i] != y[j]이면 max(LCS(i - 1, j), LCS(i, j - 1))

#### [LCS 길이 동적 계획법으로 찾기]
이제 동적 계획법으로 LCS의 길이를 찾아보자.

**[1단계]** 초기 문자열은 다음과 같다.

**[2단계]** 메모이제이션 2차원 배열 dp를 선언하고 모두 0으로 초기화한다. 2차원 배열의 열은 x, 행은 y를 의미하므로 dp[i, j]는 x[1 ... i]와 y[1 ... j]의 LCS의 길이를 저장하는 곳이다.

<img src="https://github.com/user-attachments/assets/dd39c303-16ab-4401-934f-023615b0e73b" width="450"><br/>

**[3단계]** 앞서 세운 점화식에 의해 dp[1, 1]을 채워보자. 점화식에서 dp[1, 1]을 구하려면 dp[0, 0], dp[1, 0], dp[0, 1]이 필요했다. 지금은 모두 0이므로 x[1]과 y[1]이 같은지 보자.
같지 않으므로 dp[0, 0]은 쓰지 않고 dp[1, 0], dp[0, 1]만 비교하여 큰 값을 dp[1, 1]으로 생각한다. 지금은 모두 0이므로 아무거나 골랐다.

<img src="https://github.com/user-attachments/assets/17df547b-bc25-4aeb-8fee-70e399ce82ed" width="460"><br/>

**[4단계]** dp[1, 2]도 보자. 이번에는 문자가 같다. dp[0, 1] + 1으로 값을 채운다.

<img src="https://github.com/user-attachments/assets/9c5bf0df-06b2-440c-b94d-94fd4ce5eba6" width="460"><br/>

**[5단계]** 이후 과정도 같다. 나머지 값을 채우면 다음과 같이 dp가 채워질 것이다. 이 중 가장 큰 값이 LCS의 길이이다. 정답은 4이다.

<img src="https://github.com/user-attachments/assets/47c441fc-51b9-408a-a85b-892b6dfe1d58" width="460"><br/>

#### [LCS 길이 알고리즘 분석]
총 연산 횟수는 dp를 채우는 것과 같으므로 O(N * M)이다.

<br/>

## 2. 몸풀기 문제

### [문제 67] LCS 길이 계산하기
- 권장 시간 복잡도 : O(M * N)

> 주어진 두 개의 문자열 str1과 str2에 대해 최장 공통 수열의 길이를 계산하는 solutino() 함수를 구현하세요.

#### [제약 조건]
- 각 문자열 str1과 str2의 길이는 1 이상 1,000 이하이다.
- 문자열은 알파벳 대문자, 소문자로만 구성되어 있다.

#### [입출력의 예]

|str1|str2|return|
|:---:|:---:|:---:|
|"ABCBDAB"|"BDCAB"|4|
|"AGGTAB"|"GXTXAYB"|4|

#### [문제 분석하고 풀기]
LCS의 길이 구하기 문제는 앞에서 모두 공부했던 내용이므로 바로 코드를 작성하여 풀어보겠다.

```java
class Solution {
  private static int solution(String str1, String str2) {
    // (1) 두 문자열의 길이를 저장
    int m = str1.length();
    int n = str2.length();

    // (2) LCS를 저장할 테이블 초기화
    int[][] dp = new[m + 1][n + 1];

    // (3) 동적 프로그래밍을 통해 LCS 길이 계산
    for (int i = 1; i <= m; i++) {
      for (int j = 1; j <= n; j++) {
        // (4) 현재 비교하는 문자가 같으면
        if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
          dp[i][j] = dp[i - 1][j - 1] + 1;
        }
        // (5) 현재 비교하는 문자가 같지 않으면
        else {
          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
        }
      }
    }

    // (6) LCS 길이 반환
    return dp[m][n];
  }
}
```
- (1) str1, str2의 길이를 구하여 각각 m과 n에 저장한다.
- (2) 그런 다음 (m + 1) ✕ (n + 1) 크기의 2차원 배열 dp를 생성하여 0으로 초기화한다.
  그리고 앞에서 LCS를 설명할 때는 str1과 str2가 0이 아니라 1에서 시작했지만 코드에서는 0부터 시작함에도 주의하자.

- (3) 이중 반복문으로 LCS의 길이를 계산한다. 바깥쪽 반복문은 i를 1 ~ m까지, 안쪽 반복문은 j를 1 ~ n까지 반복한다.
- (4) 만약 두 문자가 같다면 이전 LCS의 길이 dp[i - 1][j - 1]에 1을 더한 값을 dp[i][j]에 저장한다.
- (5) 두 문자가 다르면 이전까지의 LCS의 길이 dp[i - 1][j]와 dp[i][j - 1]을 비교하여 더 큰 값을 dp[i][j]에 저장한다.
- (6) 반복이 완료되면 dp[m][n]에 최장 공통 부부 수열의 길이가 저장된다.

#### [시간 복잡도 분석하기]
M과 N은 각각 문자열의 길이이다. dp 배열의 크기는 M * N이고 이를 초기화하는데 필요한 시간 복잡도는 O(M * N)이다. 이후 반복문은 M*N번 수행하므로 시간 복잡도는 O(M * N)이다.

### [문제 68] LIS 길이 계산하기
- 권장 시간 복잡도 : O(N^2)

> 정수 배열 nums에서 LIS의 길이를 찾는 함수를 작성하세요.

#### [제약 조건]
- nums는 최대 길이 1,000의 정수 배열이다.
- nums의 각 요소는 -1,000 이상 1,000 이하의 정수이다.

#### [입출력의 예]

|nums|return|
|:---:|:---:|
|[1, 4, 2, 3, 1, 5, 7, 3]|5|
|[3, 2, 1]|1|

#### [문제 분석하고 풀기]
LIS의 길이 구하기 문제는 앞에서 모두 공부했던 내용이므로 바로 코드를 작성하여 풀어보겠다. 동적 계획법으로 다음과 같이 구현하면 된다.

```java
import java.util.Arrays;

class Solution {
  private static int lis(int[] nums) {
    int n = nums.length;
    // (1) dp[i]는 nums[i]를 마지막으로 하는 LIS의 길이를 저장하는 배열
    int[] dp = new int[n];
    Arrays.fill(dp, 1);

    for (int i = 1; i < n; i++) {
      for (int j = 0; j < i; j--) {
        // (2) num[i]와 num[j]를 비교하여, num[i]가 더 큰 경우에만 처리
        if (nums[i] > nums[j]) {
          // (3) nums[i]를 이용하여 만든 부분 수열의 길이와
          // nums[j]를 이용하여 만든 부분 수열의 길이 + 1 중 최댓값을 저장
          dp[i] = Math.max(dp[i], dp[j] + 1);
        }
      }
    }

    // (4) dp 배열에서 최댓값을 찾아 최장 증가 부분 수열의 길이를 반환
    return Arrays.stream(dp).max().getAsInt();
  }
}
```
- (1) dp 배열은 수열의 각 원소를 마지막으로 하는 LIS의 길이를 저장할 것이다. 즉 dp[i]는 num[i]를 마지막으로 하는 lis의 길이이다. num[i]의 초깃값은 전부 1로 한다.
- (2) num[i]를 마지막으로 하는 lis의 길이를 구하려면 lis에서 num[i]가 가장 큰 값이어야 한다. 따라서 num[i]보다 작은 원소들이 후보이다.
- (3) 후보에 포함되는 num[j]에 대한 lis 길이인 dp[j] 중 가장 큰 값을 1에 더한 값이 dp[i]가 된다.
- (4) dp 배열에서 가장 큰 값을 반환하면 정답이다.

#### [시간 복잡도 분석하기]
N은 nums의 길이이다. dp 배열을 초기화할 때 필요한 시간 복잡도는 O(N), 이중 반복문을 통해 바깥은 N번 수행, 안쪽은 최대 N번이므로 반복문의 시간 복잡도는 O(N^2)이다.
따라서 최종 시간 복잡도는 O(N^2)이다.

### [문제 69] 조약돌 문제
- 권장 시간 복잡도 : O(N)

> 3열 N행의 가중치가 있는 배열 arr이 주어진다. 이 배열에 다음 규칙을 준수하면서 조약돌을 놓을 때 최대 가중치의 합을 반환하는 solution() 함수를 구현하세요.

#### [제약 조건]
- 각 열에 조약돌은 적어도 하나는 놓아야 한다.
- 각 조약돌에 바로 인접한 위치에 조약돌을 놓을 수 없다.
  - 인접 기준은 상하좌우이다.

#### [입출력의 예]

|arr|return|
|:---:|:---:|
|[[1, 3, 3, 2], [2, 1, 4, 1], [1, 5, 2, 3]]|19|
|[[1, 7, 13, 2, 6], [2, -4, 2, 5, 4], [5, 3, 5, -3, 1]]|32|

첫 번째 입출력 예를 보자. 입력을 기준으로 최대 가중치의 합을 반환하도록 조약돌을 놓는 경우는 다음과 같이 2 + 8 + 4 + 5 = 19이다.

<img src="https://github.com/user-attachments/assets/7e740153-b741-4d09-ac52-4fdadb38277b" width="160"><br/>

두 번쨰 입출력 예는 다음과 같다. 6 + (-4) + 18 + 5 + 7 = 36이다.

<img src="https://github.com/user-attachments/assets/0122dec3-038c-4428-995f-3070e87bc339" width="200"><br/>

#### [문제 분석하고 풀기]
이 문제를 동적 계획법으로 푸는 방법은 각 열에서 4가지 조약돌 배치 패턴에 대해 가중치를 계산하고 이 중에서 최대 가중치를 선택하는 것이다. 4가지 조약돌 배치 패턴은 다음과 같다.

<img src="https://github.com/user-attachments/assets/7ff712f6-e2fb-48d1-a64d-5bd5b44fb3f8" width="200"><br/>

이렇게 패턴을 배치했을 때 되는 패턴과 안 되는 패턴은 아래와 같다.

<img src="https://github.com/user-attachments/assets/4d91cd61-468b-4cda-9d73-c0a41bdeeb9a" width="200"><br/>

이점에 유의하여 조약돌을 첫 번째 열부터 마지막 열까지 배치하면서 이전 열에서 최대 가중치를 현재 열에서의 가중치 계산에 활용하는 것이 핵심이다. 코드에서는 이 배치 패턴으로 dp[0] 코드를 작성해보자.

```java
class Solution {
  private static int solution(int[][] arr) {
    // (1) 입력 배열의 열의 개수를 저장
    int n = arr[0].length;
    // (2) dp 배열을 초기화. 4행 n열의 2차원 배열
    int[][] dp = new int[4][n];
    // 각 열에서 선택 가능한 4가지 조약돌 배치 패턴에 대해 첫 번째 열의 가중치를 초기화
    // (3) 0: 상단, 1: 중앙, 2: 하단, 3: 상단과 하단
    dp[0][0] = arr[0][0];
    dp[1][0] = arr[1][0];
    dp[2][0] = arr[2][0];
    dp[3][0] = arr[0][0] + arr[2][0];

    // (4) 두 번째 열부터 마지막 열까지 각 열에서 선택 가능한 4가지 조약도로 배치 패턴에 대해
    // 최대 가중치를 계산
    for (int i = 1; i < n; i++) {
      // 패턴 0이 선택된 경우, 이전은 패턴 {1, 2} 가능
      dp[0][i] = arr[0][i] + Math.max(dp[1][i - 1], dp[2][i - 1]);
      // 패턴 1이 선택된 경우, 이전은 패턴 {0, 2, 3} 가능
      dp[1][i] = arr[1][i] + Math.max(dp[0][i - 1], dp[2][i - 1], dp[3][i - 1]);
      // 패턴 2가 선택된 경우, 이전은 패턴 {0, 1} 가능
      dp[2][i] = arr[2][i] + Math.max(dp[0][i - 1], dp[1][i - 1]);
      // 패턴 3이 선택된 경우, 이전은 패턴 {1} 가능
      dp[3][i] = arr[3][i] + dp[1][i - 1];
    }

    // (5) 마지막 열에서 선택 가능한 4가지 조약돌 배치 패턴 중 최대 가중치를 반환
    return Math.max(Math.max(dp[0][n - 1], dp[1][n - 1]), Math.max(dp[2][n - 1], dp[3][n - 1]));
  }
}
```
- (1) 입력 배열의 열의 수 n을 얻어온다. 이 값은 메모이제이션을 위한 dp 배열을 초기화할 때 사용한다.
- (2) dp 배열은 4행 n열의 2차원 배열로 구성한다. 각 행은 위, 가운데, 아래, 그리고 위-아래에 놓은 조약돌 배치를 의미한다. 값은 조약돌 배치 패턴의 최대 가중치를 저장한다.
- (3) 첫 번째 열의 조약돌 가중치를 dp에 초기화한다. 이 초기화 과정은 첫 번째 열에서 각 조약돌 패턴을 적용했을 때 가중치를 나타낸다.
  이 첫 번째 열을 활용해서 마지막 열까지 순회하며 최대 가중치를 가지는 조약돌 패턴을 구할 것이다.
- (4) 두 번째 열부터 마지막 열까지 순회하며 각 열에서 선택할 수 있는 조약돌 배치 패턴의 최대 가중치를 계산하고 dp에 저장한다.
  이 계산 과정에서는 이전 열의 조약돌 배치 패턴 가중치를 참조하며 상하좌우로 인접한 조약돌을 선택하지 않는 패턴 중 최댓값을 넣는다.
- (5) 반복문에서 빠져나오면 마지막 열의 가중치 4개 중 최대 가중치를 반환하면 정답이다.

#### [시간 복잡도 분석하기]
N은 arr의 열의 개수이다. dp 배열을 초기화할 때의 시간 복잡도 O(N)이다. 이후 각 열의 최대 가중치를 계산할 때의 시간 복잡도는 O(4 * N)이지만 상수는 제외하므로 O(N)이다.
따라서 최종 시간 복잡도는 O(N)이다.