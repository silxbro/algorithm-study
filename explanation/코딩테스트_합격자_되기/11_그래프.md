# 11. 그래프

<br/>

---

## 1. 그래프의 개념
그래프는 노드(vertex)와 간선(edge)을 이용한 비선형 데이터 구조이다. 보통 그래프는 데이터 간의 관계를 표현하는 데 사용한다. 데이터를 노드로, 노드 간의 관계나 흐름을 간선으로 표현한다.
간선은 방향이 있을 수도 있고 없을 수도 있다. 만약 관계나 흐름에서 정도를 표현할 필요가 있다면 가중치라는 개념을 추가하여 표현한다. 노드, 간선, 가중치라는 용어를 예와 함께 알아보자.

### 🥎 그래프 용어 정리
예를 들어 도시 간의 인구 이동을 그래프로 표현하면 다음과 같다.

<img src="https://github.com/user-attachments/assets/f2a09716-09de-44d3-8c08-26a25e60e9b7" width="300"><br/>

그림에서 동그라미로 표현한 것이 노드, 화살표로 표현한 것이 간선, 간선 위에 숫자로 표현한 것이 가중치이다. 노드에는 어떤 데이터가 들어 있다. 그리고 노드 사이에 있는 것이 간선이다.
인구 이동의 경우 어디서 얼마나 이동했는지 표시할 필요가 있으므로 간선에 가중치를 표현했다.

### 🥎 그래프의 특징과 종류
그래프는 방향성, 가중치, 순환 특성에 따라 종류를 구분할 수 있다.

#### [흐름을 표현하는 방향성]
간선은 방향을 가질 수도 있고 없을 수도 있다. 방향이 있는 간선을 포함하면 방향 그래프(directed graph), 방향이 없는 간선을 포함하면 무방향 그래프(undirected graph)라고 한다.

<img src="https://github.com/user-attachments/assets/b34c0e14-e9f2-4953-8a4e-a8af251e8a2c" width="600"><br/>

이때 방향 그래프는 어느 한쪽으로만 간선이 있는 것이 아니라 서로 반대를 가리키는 간선이 있을 수도 있다.

<img src="https://github.com/user-attachments/assets/be769b81-463a-44b3-95aa-7dab6c509072" width="250"><br/>

#### [흐름의 정도를 표현하는 가중치]
두 번째 특성은 가중치이다. 어떤 데이터는 흐름의 방향뿐 아니라 양도 중요할 수 있다. 그런 정도를 간선에 표현할 때 이를 가중치라고 한다. 가중치가 있는 그래프를 가중치 그래프(weight graph)라고 한다.

<img src="https://github.com/user-attachments/assets/003c89a0-6674-48be-9e1b-a358f4bd1e2e" width="450"><br/>

#### [시작과 끝의 연결 여부를 보는 순환]
마지막 특성은 순환이다. 순환은 특정 노드에서 시작해 간선을 따라 다시 돌아오는 경로가 있는 것을 말한다.
순환이 존재하는 그래프를 순환 그래프(cycle graph)라 하고, 순환이 존재하지 않는 그래프를 비순환 그래프(acyclic graph)라고 한다.

<img src="https://github.com/user-attachments/assets/9f7a3097-10b6-4283-a6ab-12d3353e0393" width="450"><br/>

앞서 언급했듯이 특정 노드에서 시작해 간선을 따라 다시 돌아오면 순환 그래프이다.
다음의 경우 2 → 4 → 3 → 2 이므로 그래프의 일부분이 순환한다. 1, 2, 3은 모두 연결되어 있긴 하지만 순환하진 않는다.

또, 그래프는 간선의 방향 유무에 따라 방향 그래프와 비방향 그래프로 나눌 수 있다.

<img src="https://github.com/user-attachments/assets/c247b3e2-fb40-442d-bc5d-9c57420ad412" width="500"><br/>

### 🥎 그래프 구현
예를 들어 서울에서 부산으로 유동 인구가 8,000명 발생했다는 내용을 그래프로 표현한다고 해보자. 그러면 그래프의 노드, 간선, 방향, 가중치와 문장의 의미를 이렇게 연결하여 정리해볼 수 있다.
- 데이터를 담고 있는 **노드**(서울, 부산)
- 노드를 잇는 **간선**(서울과 부산의 연결 유무)
- 간선의 **방향**(서울에서 부산 방향으로)
- 간선의 **가중치**(유동 인구 8,000명)

그래프의 구현 방식에는 인접 행렬(adjacency matrix)과 인접 리스트(adjacency list)가 있다. 두 방법으로 구현해보자.

#### [인접 행렬 그래프 표현]
인접 행렬은 배열을 활용하여 구현하는 경우가 많다.
이때 배열의 인덱스는 노드, 배열의 값은 노드의 가중치로 생각하고, 인덱스의 세로 방향을 출발 노드, 가로 방향을 도착 노드로 생각하면 자연스럽게 그래프를 표현할 수 있다.
다음은 서울에서 부산으로 향하는 간선이 있는 그래프이다.

<img src="https://github.com/user-attachments/assets/c89a1adb-63fa-42a1-9118-1d186ffb74a3" width="200"><br/>

이것을 인접 행렬로 표현하면 다음과 같다. 인접 행렬의 세로 방향 인덱스를 출발, 가로 방향 인덱스를 도착으로 하니 서울(0) -> 부산(1)으로 향하는 가중치가 400(km)인 그래프가 표현되었다.
그리고 -로 표현한 가중치는 실제 코드에서는 굉장히 큰 값을 넣거나 -1로 정한다.

<img src="https://github.com/user-attachments/assets/bd8b6980-19c8-4c9c-8f9a-8585e7b41dda" width="370"><br/>

#### [인접 리스트 그래프 표현]
인접 리스트로 그래프를 표현하려면 우선 다음과 같이 적절한 노드를 정의해야 한다. 그림에서 보듯 값(v), 가중치(w)를 묶어 관리한다.

<img src="https://github.com/user-attachments/assets/505a71e3-d62a-4700-9c72-35c618ba0a37" width="170"><br/>

인접 리스트 그래프 표현 방식은 다음과 같은 과정으로 동작한다.
- (1) 우선은 노드 개수만큼 배열을 준비한다.
- (2) 배열의 인덱스는 각 시작 노드를 의미하며 배열의 값에는 ArrayList를 연결한다.

이제 동작하는 과정을 자세히 살펴보자.

**[1단계]** 우선은 노드 개수만큼 배열을 준비한다.

<img src="https://github.com/user-attachments/assets/32a630f0-9a12-4fce-ad35-4bec42f4afc8" width="330"><br/>

**[2단계]** 이 상태에서 1 -> 2 (가중치 3) 을 표현해보자.

<img src="https://github.com/user-attachments/assets/05f8b419-a49b-48b6-823b-68f0739144a1" width="430"><br/>

**[3단계]** 이어서 2 -> 1 (가중치 6)을 표현해보자.

<img src="https://github.com/user-attachments/assets/9746129b-826a-4c9a-8b05-11a4d575381d" width="450"><br/>

**[4단계]** 정의한 노드의 다음 노드가 연결되는 모습도 살펴보자. 2 -> 3 (가중치 5)을 표현해보면, ArrayList[2]에 2 -> 3 (가중치 5)을 표현한 간선을 추가한다.

<img src="https://github.com/user-attachments/assets/3f1203fa-36a5-4820-b85d-cb4d03b157a4" width="520"><br/>

**[5단계]** 위와 같은 방식으로 그래프를 연결하면 다음과 같이 인접 리스트를 완성할 수 있다. 눈으로만 보고 넘어가지 말고 반드시 손으로 그려가며 꼭 그래프 전체를 표현해보기 바란다.

<img src="https://github.com/user-attachments/assets/db29f375-d20c-4d95-ab38-8972291a9ae6" width="530"><br/>


#### [인접 행렬과 인접 리스트의 장단점]
두 방식으로 그래프를 표현할 때 어느 한쪽이 매우 뛰어나거나 하지 않는다. 모두 장단점이 있다.

#### (1) 인접 행렬의 장단점
인접 행렬은 크게 두 가지 단점이 있다. 첫 번째 단점은 인접 행렬로 희소 그래프를 표현하는 경우이다. 희소 그래프란 노드 수에 비해 간선 수가 매우 적은 그래프를 말한다.
인접 행렬은 크기가 고정되어 있으므로 최악의 경우를 고려해서 크기를 결정해야 한다. 따라서 노드가 N개 있을 때 모든 간선이 연결되는 최악의 경우를 고려해서 N ✕ N 크기의 인접 행렬이 필요하다.
이럴 때 간선 수가 적으면 이렇게 확보한 N ✕ N 크기의 인접 행렬 공간 중 대부분의 공간은 실제로 사용하지 않으므로 비효율적이다.
두 번째 단점은 노드들의 값의 차이가 매우 큰 그래프를 표현하는 경우이다.
예를 들어 노드값이 순차적으로 증가하지 않고 1, 2, 3, 999와 같이 간격이 크면 가장 큰 노드의 값인 999를 기준으로 인접 행렬의 크기를 잡아야 한다.

인접 행렬의 장점은 간선의 정보를 확인할 때의 시간 복잡도가 O(1)로 좋다. 인접 행렬에서는 인덱스 임의 접근으로 노드 간 간선 정보를 바로 확인할 수 있기 때문이다.
예를 들어 2에서 93이 연결되어 있는지 탐색하려면 array[2][93]에 가중치가 있는지만 확인하면 된다. 구현 난이도가 낮다는 것도 인접 행렬의 장점이다.

#### (2) 인접 리스트의 장단점
인접 리스트는 정점 A에 연결된 간선의 정보를 빠르게 알 수 있다는 장점이 있다.
인접 행렬로 구현했다면 정점 A에 연결한 간선 정보를 알기 위해 [A, 0], [A, 1], ..., [A, N]과 같이 모든 간선을 탐색해야 하므로 시간 복잡도는 O(N)이다.
하지만 인접 리스트에서는 ArrayList[A]만 확인하면 되므로 연결된 간선만 빠르게 체크할 수 있다.

또한 인접 리스트는 인접 행렬과 비교했을 때 공간 복잡도 측면에서도 이득이다. 인접 행렬은 공간 복잡도가 O(E^2)이지만, 인접 리스트는 O(E + V)이다(E는 간선의 수, V는 정점의 수).
따라서 일반적으로 정점이 10만 개 이상이면 인접 행렬은 메모리 초과가 발생한다.
다만 인접 행렬은 A에서 B로 연결된 간선을 O(1)만에 [A, B]로 접근하여 확인할 수 있는 반면, 인접 리스트는 ArrayList[A]에 연결된 간선을 전부 확인해야 하므로 이 점에서는 조금 더 시간이 걸린다는 단점이 있다.

이런 이유로 코딩테스트에서는 인접 행렬보다는 인접 리스트를 더 자주 사용한다. 다익스트라와 같은 알고리즘을 구현할 때도 인접 행렬은 효율이 좋지 않아 인접 리스트를 사용한다.

표로 정리한 인접 행렬과 인접 리스트의 장단점은 다음과 같다.

||메모리 사용|시간 복잡도<br/>(A->B로 연결된 간선을 찾을 때)|시간 복잡도<br/>(모든 정점에 대해서 연결된 간선을 찾을 때)|
|:---:|:---:|:---:|:---:|
|인접 행렬|O(E^2)|O(1)|O(V^2)|
|인접 리스트|O(E + V)|O(E)<br/>(*모든 간선이 하나의 정점에 연결되어 있는<br/>Worst 케이스에서만/ 평균적으로는 O(E/V)|O(V + E)|

<br/>

## 2. 그래프 탐색
자료구조에서 데이터를 어떻게 구축할지 고민한다면, 알고리즘에서는 자료구조에서 어떤 순서와 방식으로 탐색할지를 고민한다.
그래프에서 경로를 찾는다고 할 때 경로를 찾는 방법은 다음과 같이 크게 2가지가 있다.
- 더 이상 탐색할 노드가 없을 때까지 일단 가본다. 그러다가 더 이상 탐색할 노드가 없으면 최근에 방문했던 노드로 되돌아간 다음 가지 않은 노드를 방문한다(깊이 우선 탐색).
- 현재 위치에서 가장 가까운 노드부터 모드 방문하고 다음 노드로 넘어간다. 그 노드에서 또 다시 가장 가까운 노드부터 모두 방문한다(너비 우선 탐색).

글로만 보면 단번에 이해하기 어려울 것이다. 이 두 방법으로 A부터 E까지 탐색하는 과정을 그림으로 나타냈다.

**우선 깊이 우선 탐색부터 살펴보자.**

**[1단계]** 노드 A에서 노드 D까지 차례대로 방문한다. 노드 D까지 방문하면 더 방문할 곳이 없다(막힘).

<img src="https://github.com/user-attachments/assets/d3ad287b-cbce-4bb5-b8ee-3226e21bf18e" width="180"><br/>

**[2단계]** 노드 D에서 B로 돌아온다. 여기서 다시 끝까지 간다. 즉, 노드 E까지 간다.

<img src="https://github.com/user-attachments/assets/bea2e083-621c-415c-924e-1e657f1b30cf" width="180"><br/>

**[3단계]** 다시 노드 E -> B -> A 순으로 돌아온다. 그다음 끝까지, 노드 C까지 간다. A -> B -> D -> E -> C 순서로 모든 노드를 방문했다.

<img src="https://github.com/user-attachments/assets/e85e189c-d95c-4a8c-aae4-09f66f66c143" width="180"><br/>


**다음은 너비 우선 탐색이다.**

**[1단계]** 노드 A에서 가장 가까운 노드 B, C를 방문한다.

<img src="https://github.com/user-attachments/assets/6910e09d-9293-4f70-b939-b330599eca9a" width="180"><br/>

**[2단계]** 노드 B에서 가장 가까운 노드 D, E를 방문한다. A -> B -> C -> D -> E로 모든 노드를 방문했다. 그럼 대략적인 탐색 방식을 살펴봤으니 각각의 방식을 제대로 공부해보자.

<img src="https://github.com/user-attachments/assets/9d228fda-e4f4-4108-a24d-220cc6421258" width="190"><br/>

### 🥎 깊이 우선 탐색
깊이 우선 탐색(depth-first search, DFS)는 앞서 본 것처럼 시작 노드부터 탐색을 시작하여 간선을 따라 최대 깊이 노드까지 이동하며 차례대로 방문한다.
최대 깊이 노드까지 방문한 다음에는 이전에 방문한 노드를 거슬러 올라가며 해당 노드와 연결된 노드 중 방문하지 않은 노드로 다시 최대 깊이까지 차례대로 방문한다.

탐색을 하려면 일단 시작 노드를 정하고, 스택에 시작 노드를 push한다. 스택에 있는 노드는 아직 방문하지 않았지만 방문할 예정인 노드이다. 시작 노드를 push했으면 다음 과정을 반복한다.

**[진행 1]** 스택이 비었는지 확인한다. 스택이 비었다는 건 방문할 수 있는 모든 노드를 방문했음을 의미한다. 따라서 스택이 비었으면 탐색을 종료한다.

**[진행 2]** 스택에서 노드를 pop한다. pop한 원소는 최근에 스택에 push한 노드이다.

**[진행 3]** pop한 노드의 방문 여부를 확인한다. 아직 방문하지 않았다면 노드를 방문 처리한다.

**[진행 4]** 방문한 노드와 인접한 모든 노드를 확인한다. 그리고 그중에서 아직 방문하지 않은 노드를 스택에 push한다.
스택은 FILO 구조이므로 방문 순서를 오름차순으로 고려한다면 역순으로 노드를 push해야 한다.

이 과정을 코드로 구현할 때 다음 세 가지 사항을 고려해야 한다.

**[고려 1]** 탐색할 노드가 없을 때까지 간선을 타고 내려갈 수 있어야 한다.

**[고려 2]** 가장 최근에 방문한 노드를 알아야 한다.

**[고려 3]** 이미 방문한 노드인지 확인할 수 있어야 한다.

깊이 우선 탐색의 핵심은 **'가장 깊은 노드까지 방문한 후에 더 이상 방문할 노드가 없으면 최근 방문한 노드로 돌아온 다음, 해당 노드에서 방문할 노드가 있는지 확인한다'** 이다.

<img src="https://github.com/user-attachments/assets/f7681257-5bf4-458a-bfd4-272611992b1f" width="350"><br/>

탐색하고 있는 방향의 역방향으로 되돌아가는 동작을 백트래킹(back tracking)이라고 한다.
스택은 최근에 push한 노드를 pop할 수 있으므로 특정 노드를 방문하기 전에 최근 방문 노드를 pop 연산으로 쉽게 확인할 수 있다.
이런 스택의 특성을 활용하여 백트래킹 동작을 쉽게 구현한 것이다. 스택을 활용하여 깊이 우선 탐색을 구현해보는 방법을 알아보자.

#### [스택을 활용한 깊이 우선 탐색]
선입후출의 특성을 가진 스택으로 가장 최근에 방문한 노드를 확인할 수 있다. 자세한 내용은 그림과 함께 봐야 이해하기 쉽다. 스택을 활용한 깊이 우선 탐색 과정을 살펴보자.

**[1단계]** 스택에는 방문 예정인 노드를 푸시한다. 시작 노드는 당연히 방문해야 할 노드이므로 1을 스택에 넣는다. 스택에 푸시한 노드는 빨간색, 방문한 노드는 회색으로 색칠하도록 한다.
아직 1은 방문하지 않았고, 방문할 예정이기만 하므로 그래프는 아무것도 색칠하지 않았다.

<img src="https://github.com/user-attachments/assets/cb47f954-85da-4aa6-882f-771de60d6cbe" width="500"><br/>

**[2단계]** 이제 1에 방문할 차례이다. 1을 팝한 후에 1이 방문한 상태인지 확인한다. 1은 아직 방문하지 않은 노드이므로 이제 방문 처리를 한다(그래프의 노드 1을 색칠한다).
방문 처리를 한 후에는 1과 인접하면서 방문하지 않은 노드 4, 5를 5 -> 4 순서로 푸시하여 이후 4 -> 5 순서로 방문 처리할 수 있게 한다.
- 이렇게 스택에 역순으로 푸시하면 의도한 대로 방문 처리를 할 수 있다.

<img src="https://github.com/user-attachments/assets/38a1c7a6-c9e8-48b5-9179-1718cceffcf7" width="450"><br/>

**[3단계]** 이제 같은 방식으로 팝, 푸시를 진행한다. 스택에서 4를 팝한 다음, 4가 방문한 상태인지 확인한다. 4는 아직 방문하지 않았으므로 방문 처리한다.
그런 다음 4와 인접한 2, 3을 3 -> 2 순서로 푸시한다.

<img src="https://github.com/user-attachments/assets/484e519a-beb0-4a5f-b8fc-9ccb7b3ea178" width="450"><br/>

**[4단계]** 2를 팝한다. 2는 방문하지 않았으므로 2를 방문 처리한다. 그런 다음 2와 인접하면서 방문하지 않은 노드 3을 푸시한다.

<img src="https://github.com/user-attachments/assets/78aebe86-6a47-4259-a2b9-c5579663aa31" width="450"><br/>

**[5단계]** 이후 작업도 마찬가지이다. 3을 팝하고 방문 처리한다. 3과 인접한 노드는 없으니 아무것도 푸시하지 않는다.

<img src="https://github.com/user-attachments/assets/b6ea9408-f5b5-4c53-8ab7-d79d31b17640" width="450"><br/>

**[6단계]** 또 다시 3을 팝할 때는 이미 방문 처리를 했으므로 아무 작업도 하지 않는다.

<img src="https://github.com/user-attachments/assets/1081c0f8-c33d-4031-9f2d-11cd7a347b25" width="450"><br/>

**[7단계]** 5를 팝하고, 5를 방문 처리한다. 스택이 비었으므로 작업이 끝났다.

<img src="https://github.com/user-attachments/assets/1cb2e999-9570-4caa-a7c1-acf7446bf787" width="450"><br/>

#### [재귀 함수를 활용한 깊이 우선 탐색]
스택을 직접 사용하지 않고도 깊이 우선 탐색을 구현할 수도 있다. 바로 재귀 함수를 활용하는 것이다.
재귀 함수를 호출할 때마다 호출한 함수는 시스템 스택이라는 곳에 쌓이므로 깊이 우선 탐색에 활용할 수 있는 것이다.
호출할 함수는 dfs()라 선언하고 dfs(N)을 호출하면 다음 동작을 하도록 구현했다고 가정한다.
- 여기서는 인접한 노드를 방문할 때 숫자가 낮은 노드부터 탐색하는 방식으로 설명했다.
- dfs(N): N번 노드를 방문 처리하고 N번 노드와 인접한 노드 중 아직 방문하지 않은 노드를 탐색

**[1단계]** 시작 노드는 1번 노드이므로 dfs(1)을 호출한다. dfs(1)이 실행되면 1을 방문 처리하고 내부적으로 dfs(4)를 재귀 호출한다.
아직 dfs(1)은 dfs(4)를 호출한 상태이므로 종료되지 않는다. 따라서 스택에 dfs(1)이 쌓인다.

<img src="https://github.com/user-attachments/assets/f9f759a2-d750-49e3-bfdc-e44727b7c79d" width="500"><br/>

**[2단계]** dfs(4)가 실행되므로 4는 방문 처리하며, 내부적으로 dfs(4)는 dfs(2)를 호출한다. 같은 이유로 dfs(4)는 스택에 쌓인다.

<img src="https://github.com/user-attachments/assets/92173218-80cc-4710-acba-c0dda6842e4e" width="500"><br/>

**[3단계]** dfs(2)를 실행한다. 2를 방문 처리하고 dfs(2)는 dfs(3)을 재귀 호출한다.

<img src="https://github.com/user-attachments/assets/cf290a2f-5795-4647-a2a1-24ecd66ea7e2" width="480"><br/>

**[4단계]** dfs(3)을 실행한다. 3은 인접 노드가 없으므로 추가로 재귀 호출을 하지 않고 함수를 종료한다. 여기서 처음으로 스택에서 빠져나오는 함수가 생긴다. 그림을 자세히 보기 바란다.

<img src="https://github.com/user-attachments/assets/66d8bb70-fbb1-4c6e-98fd-36a7f21bc7fc" width="520"><br/>

**[5단계]** 스택 특성에 의해 dfs(2)로 돌아가 다음 실행 스텝을 진행한다. 그러나 2는 인접한 노드가 없으므로 종료된다.

<img src="https://github.com/user-attachments/assets/1af8b3c2-f19d-4839-b92f-c6b56b47eae4" width="500"><br/>

**[6단계]** dfs(4)로 돌아가 다음 실행 스텝을 진행한다. 2의 다음 노드인 3이 인접하므로 탐색을 시도해보지만, 3은 이미 방문한 노드이다. 인접한 모든 노드를 방문했기 때문에 해당 함수가 종료된다.

<img src="https://github.com/user-attachments/assets/88102af6-1dda-4625-8673-4aab4fc3eed1" width="500"><br/>

**[7단계]** dfs(1)의 다음 실행 스텝을 진행한다. 1은 5와 인접해 있으므로 dfs(5)를 재귀 호출한다.

<img src="https://github.com/user-attachments/assets/ec16c68a-e857-4f73-a058-7b875e3cc9b9" width="470"><br/>

**[8단계]** dfs(5)를 실행한다. 5를 방문 처리하고 5와 인접한 노드가 없으므로 dfs(5)를 종료한다. dfs(1)도 이어 종료한다.

<img src="https://github.com/user-attachments/assets/8c1864f7-802c-46f6-9938-cff506a1564d" width="500"><br/>

### 🥎 너비 우선 탐색
너비 우선 탐색(breadth first search, BFS)은 시작 노드와 거리가 가장 가까운 노드를 우선하여 방문하는 방식의 알고리즘이다. 여기서 말하는 거리는 시작 노드와 목표 노드까지의 차수이다.
간선 가중치의 합이 아닌 것에 주의하자. 탐색을 하려면 일단 시작 노드를 정하고, 큐에 시작 노드를 add한다. 시작 노드를 큐에 add하면서 방문 처리를 한다.
큐에 있는 노드는 이미 방문 처리했고, 그 노드와 인접한 노드는 아직 탐색하지 않은 상태라고 생각하면 된다. 이후 다음 과정을 반복한다.

**[진행 1]** 큐가 비었는지 확인한다. 큐가 비었다면 방문할 수 있는 모든 노드를 방문했다는 의미이다(탐색 종료).

**[진행 2]** 큐에서 노드를 poll한다.

**[진행 3]** poll한 노드와 인접한 모든 노드를 확인하고 그중 아직 방문하지 않은 노드를 큐에 add하여 방문 처리한다.

이 과정을 코드로 구현할 때 다음 두 가지 사항을 고려해야 한다.

**[고려 1]** 현재 방문한 노드와 직접 연결된 모든 노드를 방문할 수 있어야 한다.

**[고려 2]** 이미 방문한 노드인지 확인할 수 있어야 한다.

너비 우선 탐색 방식을 보면 시작 노드부터 인접한 노드를 모두 방문한 후 그 다음 단계의 인접 노드를 방문한다. 즉, 먼저 발견한 노드를 방문한다.
이러한 특성 때문에 너비 우선 탐색을 할 때는 큐를 활용한다. 이 역시 구체적인 내용은 그림을 보며 이해해보자.
그림으로 제시한 그래프는 깊이 우선 탐색과 같고, **스택이 아닌 큐로 구현하는 점에만 주목하자.**

#### [큐를 활용한 너비 우선 탐색]
**[1단계]** 시작 노드 1을 큐에 add하고 방문 처리한다.

<img src="https://github.com/user-attachments/assets/47a97fa5-1af2-490e-bd81-f792378e15b6" width="500"><br/>

**[2단계]** 1을 poll한 후 인접한 4와 5를 본다. 아직 방문하지 않았으므로 방문 처리하고 4, 5 순서로 큐에 add한다.

<img src="https://github.com/user-attachments/assets/ea5664f3-c0b5-4db0-b254-9eaa337e3a38" width="560"><br/>

**[3단계]** 4를 poll한 후 인접한 2와 3을 본다. 아직 방문하지 않았으므로 방문 처리하고 2, 3 순서로 큐에 add한다.

<img src="https://github.com/user-attachments/assets/ed329417-74ba-44b7-872e-b18e37393bba" width="550"><br/>

**[4단계]** 5를 poll한 후 인접한 1과 4를 본다. 이미 방문했으므로 아무것도 하지 않는다. 큐의 나머지 노드들도 자신과 인접한 노드들을 모두 방문했으므로 아무것도 하지 않고 poll한다.
큐가 비면 탐색을 마무리한 것이다.

<img src="https://github.com/user-attachments/assets/3908691b-dc9a-4746-a65e-72df8af9af61" width="560"><br/>

<img src="https://github.com/user-attachments/assets/26081c9b-3db0-45df-b9ec-199dd786b111" width="600"><br/>

### 🥎 깊이 우선 탐색과 너비 우선 탐색 비교
깊이 우선 탐색과 너비 우선 탐색은 모두 탐색 알고리즘이므로 겉으로 봤을 때는 차이가 없는 것 같다고 느끼기 쉽지만 두 알고리즘의 차이는 분명하다.
**깊이 우선 탐색은 깊게 탐색 후 되돌아오는 특성이 있고, 너비 우선 탐색은 가중치가 없는 그래프에서 최단 경로를 보장한다.** 이 차이를 확실하게 알아야 코딩테스트에서 요긴하게 써먹을 수 있다.

#### [깊이 탐색 후 되돌아오는 깊이 우선 탐색]
깊이 우선 탐색은 가장 깊은 곳을 우선하여 탐색하고, 더 이상 탐색할 수 없으면 백트래킹하여 최근 방문 노드부터 다시 탐색을 진행한다는 특징이 있어서
모든 가능한 해를 찾는 백트래킹 알고리즘을 구현할 때나 그래프의 사이클을 감지해야 하는 경우 활용할 수 있다.
코딩테스트에서는 탐새을 해야 할 때, 최단 경로를 찾는 문제가 아니면 깊이 우선 탐색을 우선 고려해보는 것이 좋다.

#### [최단 경로를 보장하는 너비 우선 탐색]
앞서 깊이 우선 탐색과는 반대로 너비 우선 탐색은 찾은 노드가 시작 노드로부터 최단 경로임을 보장한다. 왜냐하면 시작 노드로부터 직접 간선으로 연결된 모든 노드를 먼저 방문하기 때문이다.
쉽게 말해 문제에 대한 답이 많은 경우 너비 우선 탐색은 이 답 중에서도 가장 가까운 답을 찾을 때 유용하다.
그래서 너비 우선 탐색은 미로 찾기 문제에서 최단 경로를 찾거나, 네트워크 분석 문제를 풀 때 활용할 수 있다.

#### [방문 처리 시점이 다른 이유]
깊이 우선 탐색과 너비 우선 탐색 과정을 읽으면서 방문 처리 시점이 다른 것이 이상하다고 생각했을 수도 있다.
깊이 우선 탐색은 스택에서 pop하며 방문 처리를 했고, 너비 우선 탐색은 큐에 add하며 방문 처리를 했다. 이는 탐색 방식이 다르기 때문이다.
깊이 우선 탐색 과정에서는 스택에 **다음에 방문할 인접한 노드를 push한다.** 즉, 스택에 push할 노드는 방문 예정인 노드이므로 pop하며 방문 처리를 해야 한다.
반면 너비 우선 탐색 과정에서는 **지금 방문할 노드를 add한다.** 그래야 인접한 노드부터 탐색할 수 있기 때문이다.

<br/>

## 3. 그래프 최단 경로 구하기
최단 경로(shortest path)는 그래프의 종류에 따라 그 진의가 다르게 해석될 수도 있는 주제이다.
가중치가 없는 그래프에서는 간선 개수가 가장 적은 경로가 최단 경로이지만 가중치가 있는 그래프에서는 일반적으로 시작 노드에서 끝 노드까지 이동할 때 거치는 간선의 가중치의 총합이 최소가 되는 것을 말한다.
이를테면 다음 그래프는 간선에 가중치가 있으므로 최단 경로의 기준은 간선의 가중치의 총합이다.

<img src="https://github.com/user-attachments/assets/aa9c67f6-f0e8-401c-806b-a9310ae2803c" width="250"><br/>

노드 1에서 5까지의 최단 경로를 구한다고 했을 때, 간선 개수를 기준으로 하면 1 → 5는 간선의 개수가 1개로 가장 적으니 이것이 최단 경로가 된다.
하지만 가중치의 합을 기준으로 하면 1 → 5는 가중치가 49이고, 1 → 2 → 5는 가중치가 24이므로 이것이 최단 경로가 된다.
여기서는 최단 경로를 구하는 대표적인 알고리즘인 다익스트라 알고리즘, 벨만-포드 알고리즘을 차례로 알아본다.

### 🥎 다익스트라 알고리즘
다익스트라(dijkstra) 알고리즘은 1959년 에츠허르 데이크스트라(adsger wybe dijkstra)가 발표한 최단 경로를 구하는 알고리즘이다.
가중치가 있는 그래프의 최단 경로를 구하는 문제는 대부분 다익스트라 알고리즘을 사용한다고 보면 될 정도로 중요한 알고리즘이다(또는 데이크스트라 알고리즘이라고도 한다).
다익스트라 알고리즘은 다음과 같은 과정으로 동작한다.
- 다익스트라 알고리즘을 고안한 에츠허르 데이크스트라는 네덜란드 사람이다.
  네덜란드 발음으로 dijkstra는 데이크스트라가 맞지만 우리나라에서는 다익스트라라고 부르는 경우가 많으므로 여기서도 다익스트라라고 하겠다.
  <br/>

- (1) 시작 노드를 설정하고 시작 노드로부터 특정 노드까지의 최소 비용을 저장할 공간과 직전 노드를 저장할 공간을 마련한다.
  - 최소 비용을 저장할 공간은 모두 매우 큰 값으로 초기화한다. 여기서는 무한대(infinite)를 의미하는 약자 INF로 표현한다. 직전 노드를 저장할 공간도 INF로 초기화한다.
  - 시작 노드의 최소 비용은 0, 직전 노드는 자신으로 한다.
- (2) **해당 노드를 통해 방문할 수 있는 노드 중, 즉 아직 방문하지 않은 노드 중 현재까지 구한 최소 비용이 가장 적은 노드를 선택한다.**
  - 해당 노드를 거쳐서 각 노드까지 가는 최소 비용과 현재까지 구한 최소 비용을 비교하여 작은 값을 각 노드의 최소 비용으로 갱신한다.
  - 이때 직전 노드도 같이 갱신한다.
- (3) 노드 개수에서 1을 뺀 만큼 반복한다.

글로만 보면 난해하게 느껴질 수 있다. 다익스트라 알고리즘의 동작을 그림과 함께 차분하게 알아보자.

**[1단계]** 시작 노드 A의 최소 비용은 0, 직전 노드는 A로 초기화한다.

<img src="https://github.com/user-attachments/assets/98cc9eb4-041e-4abd-8a06-290652a4a50c" width="550"><br/>

**[2단계]** 방문하지 않은 노드 중 최소 비용이 가장 적은 노드 A를 선택한다. 이후 해당 노드를 거쳐서 각 노드까지 가는 비용과 기존에 구한 각 노드의 최소 비용을 비교한다.
노드 A에서 노드 B, C, E의 가중치는 각각 4, 4, 1이다. 현재까지 해당 노드의 최소 비용은 모두 INF이므로 B의 최소 비용을 4, C의 최소 비용을 4, E의 최소 비용을 1로 갱신한다.
이때 최소 비용이 갱신된 노드의 직전 노드를 A로 갱신한다.

<img src="https://github.com/user-attachments/assets/f1ddde93-6236-4927-a78e-725d5de66352" width="550"><br/>

**[3단계]** **방문하지 않은 노드 중 최소 비용이 가장 적은 노드 E를 선택한다.** 선택한 노드를 거쳤을 때 최소 비용을 갱신할 수 있는지 확인한다.
노드 C의 현재 최소 비용은 4이고, E를 거쳤을 때의 비용은 E의 최소 비용(1)과 E → C의 가중치(2)를 합친 값 3이다.
현재까지 구한 최소 비용보다 이 값이 더 작으므로 C의 최소 비용을 3, 직전 노드를 E로 수정한다.

<img src="https://github.com/user-attachments/assets/977c66cc-c841-483d-a7c8-1fc13f378308" width="550"><br/>

**[4단계]** 방문하지 않은 노드 중 최소 비용이 가장 적은 노드 C를 선택한다. 선택한 노드를 거쳤을 때 최소 비용을 갱신할 수 있는지 확인한다.
노드 D의 경우 기존 최소 비용이 INF(경로가 없음)이지만, C를 거치면 C의 최소 비용(3) + C → D의 가중치(8)를 합쳐 11이 되어 더 작다. 최소 비용을 11로, 직전 노드를 C로 갱신한다.

<img src="https://github.com/user-attachments/assets/fae69ad6-7f39-4700-bfb4-062a8e261e5a" width="550"><br/>

**[5단계]** 방문하지 않은 노드 중 최소 비용이 가장 적은 노드 B를 선택한다. 선택한 노드를 거쳤을 때 최소 비용을 갱신할 수 있는지 확인하다만, 지금은 최소 비용을 갱신할 필요가 없다.

<img src="https://github.com/user-attachments/assets/febfd8bf-47b1-4e37-868b-3af801a71808" width="550"><br/>

**[6단계]** 방문하지 않은 노드 중 최소 비용이 가장 적은 노드 D를 방문한다. 여기서도 같은 작업을 반복한다. 최소 비용은 갱신하지 않는다.

<img src="https://github.com/user-attachments/assets/0a5d6446-2aae-49d1-82f3-5dd198cdfbd4" width="550"><br/>

**[7단계]** 모든 곳에 방문하였다. 각 노드까지의 최소 비용과 직전 노드를 갱신했다. 특정 노드로부터 직전 노드가 시작 노드가 될 때까지 거슬러 올라가면 최소 비용을 구성하는 세부 경로도 알 수 있다.
예를 들어 노드 C의 경우 최소 비용은 3이며, (1) 직전 노드 E, (2) A를 거슬러 올라가 세부 경로가 A -> E -> C임을 알 수 있다.

<img src="https://github.com/user-attachments/assets/84b9e894-ff20-4c52-851b-3305ab7c7959" width="600"><br/>

#### [음의 가중치가 있는 그래프에서 다익스트라 알고리즘은 어떨까?]
**결론부터 말하면 다익스트라 알고리즘은 양의 가중치만 있는 그래프에서만 동작하므로 음의 가중치가 있는 그래프에서 제대로 동작하지 않는다.**
다익스트라 알고리즘은 시작 노드에서 각 노드까지의 최소 비용을 갱신하는 과정을 반복한다. 현재까지 구한 각 노드의 최소 비용 중 가장 작은 노드를 선택하여 움직인다.
알고리즘 기법 중에 각 단계에서 가장 좋은 것을 선택하는 전략을 가진 그리디 알고리즘과 원리가 같다. 그런데 다익스트라 알고리즘은 한 번 방문한 노드는 다시 방문하지 않는다.
그러니 음의 가중치가 있는 그래프에서 제대로 동작하지 않는다. 이런 그림을 생각해보면 된다.

<img src="https://github.com/user-attachments/assets/e1caba0f-1167-4fb3-89dd-41ab6528b77d" width="250"><br/>

그럼에도 다익스트라 알고리즘을 많이 사용하는 이유는 대부분의 경우 음의 가중치를 갖는 경우가 없고, 성능이 매우 뛰어나기 때문이다.
- 매 순간마다 좋아보이는 선택을 하는 것을 그리디(greedy)하다라고 한다. 그리디를 우리말로 '탐욕'으로 번역한다.

### 🥎 벨만-포드 알고리즘
벨만-포드(bellman-ford) 알고리즘 역시 다익스트라 알고리즘과 마찬가지로 노드에서 노드까지의 최소 비용을 구한다는 점에서는 같다.
**하지만 벨만-포드 알고리즘은 매 단계마다 모든 간선의 가중치를 다시 확인하여 최소 비용을 갱신하므로 음의 가중치를 가지는 그래프에서도 최단 경로를 구할 수 있다.**
벨만-포드 알고리즘은 다음과 같이 동작한다.

- (1) 시작 노드를 설정한 다음 시작 노드의 최소 비용은 0, 나머지 노드는 INF로 초기화한다. 이후 최소 비용을 갱신할 때 직전 노드도 갱신한다.
- (2) 노드 개수 - 1만큼 다음 연산을 반복한다.
  - 시작 노드에서 갈 수 있는 각 노드에 대하여 전체 노드 각각을 거쳐갈 때 현재까지 구한 최소 비용보다 더 적은 최소 비용이 있는지 확인하여 갱신한다.
    최소 비용을 갱신할 때, V의 직전 노드 값도 같이 갱신한다.

- (3) 과정 2를 마지막으로 한 번 더 수행하여 갱신되는 최소 비용이 있는지 확인한다. **만약 있다면 음의 순환이 있음을 의미한다.**

벨만-포드 알고리즘은 글로만 읽으면 쉽게 와닿지 않는다. 아마도 '노드 개수 - 1만큼 연산을 반복하라'는 말과 과정 3의 '한 번 더 수행하라'는 말이 쉽게 와닿지 않을 것이다.
우선은 벨만-포드 알고리즘이 동작하는 과정을 자세히 살펴보고 그 이후에 왜 그렇게 하는지에 대해 설명해보겠다.

**[1단계]** 우선 시작 노드를 A로 정하고 최소 비용을 0, 직전 노드를 A, 나머지 노드는 INF로 초기화한다.

<img src="https://github.com/user-attachments/assets/e15c7809-de39-4b26-9e4a-2e6e2c013456" width="550"><br/>

**[2단계]** 노드 A에서 A를 거쳐 각 노드 B, C, D, E까지 가는 비용 중 현재까지 구한 최소 비용보다 적은 값이 있는지 확인하고 현재까지 구한 최소 비용보다 비용이 적다면 갱신한다.
이때 비교와 갱신 과정을 보기 편하도록 해당 정점의 최소 비용은 **최소_비용(A)(숫자)**, 가중치가 있는 간선은 **간선(A, B)(숫자)** 와 같이 표시한다.
또한 간선이 없는 경우는 INF로 계산한다는 점에도 주의한다.
- A에서 A를 거친다라고 표현한 이유는 A가 시작 노드이기 때문이다. A에서 시작하면 A를 거치는 것으로 생각해도 된다.

```
- 최소_비용(A)(0)    == 최소_비용(A)(0) + 간선(A,A)(0)   : 갱신하지 않음
- 최소_비용(B)(INF)  >  최소_비용(A)(0) + 간선(A,B)(4)   : 최소_비용(B)를 INF에서 4로 갱신
- 최소_비용(C)(INF)  >  최소_비용(A)(0) + 간선(A,C)(3)   : 최소_비용(C)를 INF에서 3으로 갱신
- 최소_비용(D)(INF)  == 최소_비용(A)(0) + 간선(A,D)(INF) : 갱신하지 않음
- 최소_비용(E)(INF)  >  최소_비용(A)(0) + 간선(A,E)(-6)  : 최소_비용(E)를 INF에서 -6으로 갱신
```
<img src="https://github.com/user-attachments/assets/557d5e42-c300-407c-91fd-046b5d54aecb" width="550"><br/>

**[3단계]** 다음도 해보자. 노드 A에서 B를 거쳐 각 노드까지 가는 최소 비용도 갱신해보자.

```
- 최소_비용(A)(0)   <  최소_비용(B)(4) + 간선(B,A)(INF)  : 갱신하지 않음
- 최소_비용(B)(4)   == 최소_비용(B)(4) + 간선(B,B)(0)    : 갱신하지 않음
- 최소_비용(C)(3)   <  최소_비용(B)(4) + 간선(B,C)(INF)  : 갱신하지 않음
- 최소_비용(D)(INF) >  최소_비용(B)(4) + 간선(B,D)(5)    : 9로 갱신
- 최소_비용(E)(-6)  <  최소_비용(B)(4) + 간선(B,E)(-6)   : 갱신하지 않음
```
<img src="https://github.com/user-attachments/assets/ec30ae36-cace-4fd9-bb15-7f4e5fd50389" width="550"><br/>

**[4단계]** 이제 슬슬 갱신하는 패턴이 눈에 익을 것이다. 노드 A에서 C를 거쳐 각 노드까지 가는 최소 비용도 갱신하자.
예를 들어 노드 C를 거쳐서 B로 가는 새 경로는 기존의 B의 최소 비용보다 크므로 갱신하지 않는다.

```
- 최소_비용(A)(0)   <  최소_비용(C)(3) + 간선(C,A)(INF)  : 갱신하지 않음
- 최소_비용(B)(4)   <  최소_비용(C)(3) + 간선(C,B)(2)    : 갱신하지 않음
- 최소_비용(C)(3)   == 최소_비용(C)(3) + 간선(C,C)(0)    : 갱신하지 않음
- 최소_비용(D)(9)   <  최소_비용(C)(3) + 간선(C,D)(INF)  : 갱신하지 않음
- 최소_비용(E)(-6)  <  최소_비용(C)(3) + 간선(C,E)(INF)  : 갱신하지 않음
```  
<img src="https://github.com/user-attachments/assets/549b9e96-c5b5-419c-acb5-d9ed4e2a8447" width="550"><br/>

**[5단계]** 노드 A에서 D를 거쳐가는 방법은 없으므로 갱신하지 않는다.

**[6단계]** 노드 A에서 E를 거쳐 각 노드까지 가는 최소 비용도 갱신한다. 모든 최단 경로에 대해 노드의 최소 비용을 체크했으므로, 벨만-포드 알고리즘의 첫 번째 반복이 끝났다.

```
- 최소_비용(A)(0)   <  최소_비용(E)(-6) + 간선(E,A)(INF)  : 갱신하지 않음
- 최소_비용(B)(4)   >  최소_비용(E)(-6) + 간선(E,B)(2)    : -4로 갱신
- 최소_비용(C)(3)   == 최소_비용(E)(-6) + 간선(E,C)(0)    : 갱신하지 않음
- 최소_비용(D)(9)   <  최소_비용(E)(-6) + 간선(E,D)(INF)  : 갱신하지 않음
- 최소_비용(E)(-6)  <  최소_비용(E)(-6) + 간선(E,E)(INF)  : 갱신하지 않음
```  
<img src="https://github.com/user-attachments/assets/d1342849-b17d-4ebe-8e51-6781c3356620" width="550"><br/>

**[7단계]** 이제 첫 번째 반복이 끝났다. 위에서 했던 과정을 '노드 개수 - 1'번 반복한다고 했으므로 **1단계 ~ 6단계** 를 4번 더 반복하면 된다.

<img src="https://github.com/user-attachments/assets/c091f958-bbf1-4ac6-8a4b-2c983408df71" width="550"><br/>

**[8단계]** 하나만 해보자. 노드 A에서 A를 거쳐 각 노드까지 가는 비용을 갱신한다. 첫 번째 과정과 마찬가지 과정을 반복하면 된다. 앞 과정에서 최소 비용을 갱신했으므로 또 다른 갱신이 진행될 것이다.

```
- 최소_비용(A)(0)   ==  최소_비용(A)(0) + 간선(A,A)(0)  : 갱신하지 않음
- 최소_비용(B)(4)   == 최소_비용(A)(0) + 간선(A,B)(4)   : 갱신하지 않음
- 최소_비용(C)(-4)  <  최소_비용(A)(0) + 간선(A,C)(3)   : 갱신하지 않음
- 최소_비용(D)(9)   <  최소_비용(A)(0) + 간선(A,D)(INF) : 갱신하지 않음
- 최소_비용(E)(-6)  == 최소_비용(A)(0) + 간선(A,E)(-6)  : 갱신하지 않음
```  
이제 벨만-포드 알고리즘이 어떤 식으로 최단 거리를 알아내는지 알았을 것이다. 그럼 앞서 말끔하게 풀지 못했던 다음 두 가지 궁금증을 해결하며 벨만-포드 알고리즘 설명을 마치겠다.

#### [왜 정점 개수 -1만큼 반복하는가? 매 연산마다 최단 경로가 1개씩 확정되므로!]
아래와 같은 그래프에서 시작 노드가 1일 때 최단 경로를 구하는 상황을 생각해보자. 벨만-포드 알고리즘이 연산을 K번 반복하면 K개의 간선에 대한 최단 경로를 구할 수 있다.
예를 들어 첫 번째 반복 과정에서는 노드 2에 대한 최단 경로가, 두 번째 반복 과정에서는 노드 3에 대한 최단 경로가 결정된다.
이런 식으로 N - 1 번 연산을 반복하면 노드 N에 대한 최단 경로가 결정되어 벨만-포드 알고리즘이 끝나는 것이다. 그래서 노드 개수 -1만큼 벨만-포드 알고리즘의 연산을 반복했던 것이다.

<img src="https://github.com/user-attachments/assets/05c6f97d-18a0-4613-9b7f-2f4ebabb1a51" width="550"><br/>

#### [왜 한 번 더 연산을 반복하는가? 음의 순환을 찾기 위해!]
그런데 위 그림에서 노드 N의 최단 경로를 구성하는 간선 개수가 N개 이상이면 최단 경로의 간선 개수는 최대 N - 1이어야 하므로 뭔가 잘못된 것을 의미한다.
즉, 음의 순환이 있는 것이다. 지금 보고 있는 그래프에 노드 N에서 노드 N - 1으로 향하는 가중치가 -100인 간선을 추가했다고 생각해보자.

<img src="https://github.com/user-attachments/assets/8003eaa3-06e1-4548-acdd-53e82031c34f" width="550"><br/>

그러면 음의 순환인 N → (N - 1) 구간을 반복하면 계속해서 최소 비용(가중치의 합)은 점점 줄어든다. 그렇다는 건 최단 경로를 구할 수 없다는 것이다.
이 음의 순환을 계속해서 돌면 최소 비용은 무한히 작아질 것이니 말이다.

#### [음의 순환에 빠지는 건 벨만-포드 알고리즘의 한계다?]
흔히 벨만-포드 알고리즘의 한계점으로 '음의 순환이 있을 때 최단 경로를 구하지 못한다'를 자주 말한다.
**이 말을 듣고 '벨만-포드 알고리즘은 음의 순환이 있을 때 최단 경로를 구하지 못하는 좋지 못한 녀석'이라고 오해하기 쉬운데 그렇게만 이해하면 안된다.**

사실 **엄밀히 말하면 그래프에 음의 순환이 있으면 어떤 알고리즘도 최단 경로를 구할 수 없다.** 다만 음의 가중치를 다루는 최단 경로 알고리즘은 음의 순환에 빠질 수 있는 것이다.
다시 말해 벨만-포드 알고리즘은 음의 가중치가 있는 그래프에서 최단 경로를 찾을 수 있는 대신 음의 순환에 빠질 수 있고, 다익스트라 알고리즘은 음의 가중치가 있는 그래프에서 동작하지 못하므로
아예 언급되지 않는 것이다.

<img src="https://github.com/user-attachments/assets/39db6e97-009a-4078-b03b-dbea07a38cc1" width="600"><br/>

그러니 음의 순환에 빠지는 벨만-포드 알고리즘의 특징을 알고리즘의 한계로 보면 안된다. 오히려 음의 순환을 감지할 수 있는 것이다.

#### [플로이드-워셜 알고리즘]
플로이드-워셜(floyd-warshall) 알고리즘은 노드에 대하여 각 노드부터 나머지 노드까지의 최단 경로를 모두 구하는 알고리즘이다. 출제 빈도가 낮아 소개하지 않는다.

지금까지 다익스트라 알고리즘, 벨만-포드 알고리즘을 알아봤다. 각 알고리즘의 목적은 최단 경로, 최소 비용을 찾는다는 점에서 같다.
하지만 세세하게 들여다보면 장단점과 구체적인 목표가 달랐다. 표로 정리하며 마무리하겠다.

||목적|장단점 및 특징|시간 복잡도|
|:---|:---|:---|:---|
|다익스트라<br/>알고리즘|출발 노드로부터 도착 노드<br/>들까지의 최단 경로 찾기|음의 가중치를 가지는 그래프에서<br/>최단 경로를 구할 수 없음(그리디 방식)|O(V^2)<br/>우선순위 큐로 개선하면 O(E*logV)|
|벨만-포드<br/>알고리즘|출발 노드로부터 도착 노드<br/>들까지의 최단 경로 찾기|음의 가중치를 가지는 그래프에서<br/>최단 경로를 구할 수 있고, 음의 순환도<br/>감지할 수 있음|O(V*E)|

<br/>

## 4. 몸풀기 문제
### [문제 34] 깊이 우선 탐색 순회
- 권장 시간 복잡도 : O(N+E)

> 깊이 우선 탐색으로 모든 그래프의 노드를 순회하는 함수 solution()을 작성하세요. 시작 노드는 start로 주어집니다. graph는 [출발 노드, 도착 노드] 쌍들이 들어 있는 리스트입니다.
> 반환값은 그래프의 시작 노드부터 모든 노드를 깊이 우선 탐색으로 진행한 순서대로 노드가 저장된 리스트입니다.

#### [제약 조건]
- 노드의 최대 개수는 100개를 넘지 않는다.
- 시작 노드부터 시작해서 모든 노드를 방문할 수 있는 경로가 항상 있다.
- 그래프의 노드는 문자열이다.

#### [입출력의 예]
|graph|start|n|return|
|:---|:---:|:---:|:---|
|['1', '2'], ['2', '3'], ['3', '4'], ['4', '5']|'1'|5|['1', '2', '3', '4', '5']|
|['1', '2'], ['1', '3'], ['2', '4'], ['2', '5'], ['3', '6'], ['5', '6']|'1'|6|['1', '2', '4', '5', '6', '3']|
- 이 문제는 탐색 순서에 따라 정답이 여러 개일 수 있다.

#### [문제 분석하고 풀기]
앞서 공부한 깊이 우선 탐색을 구현하고, 순회한 결과를 출력하는 문제이다. 입출력 예를 보면 [출발 노드, 도착 노드]의 쌍이 리스트로 들어온다.

첫 번째 graph를 그림으로 표현하면 다음과 같다.

<img src="https://github.com/user-attachments/assets/ee705487-d418-4c36-a401-39d66f214e2f" width="280"><br/>

graph로 주어진 값을 인접 리스트로 변환하여 그래프를 저장하기만 하면 깊이 우선 탐색을 쉽게 구현할 수 있다. 코드는 다음과 같다.

```java
import java.util.ArrayList;

class Solution {

  // 인접 리스트로 저장할 ArrayList 배열
  private static ArrayList<Integer>[] adjList;

  // 방문 여부를 저장할 boolean 배열
  private static boolean[] visited;
  private static ArrayList<Integer> answer;

  private static int[] solution(int[][] graph, int start, int n) {
    // (1) 인접 리스트 초기화
    adjList = new ArrayList[n + 1];
    for (int i = 0; i < adjList.length; i++) {
      adjList[i] = new ArrayList<>();
    }

    // (2) 그래프를 인접 리스트로 변환
    for (int[] edge : graph) {
      adjList[edge[0]].add(edge[1]);
    }

    // DFS를 순회한 결과를 반환
    visited = new boolean[n + 1];
    answer = new ArrayList<>();
    dfs(start);  // (7) 시작 노드에서 깊이 우선 탐색 시작

    // (8) DFS 탐색 결과 반환
    return answer.stream().mapToInt(Integer::intValue).toArray();
  }

  // (3) DFS 탐색 메서드
  private static void dfs(int now) {
    visited[now] = true;  // (4) 현재 노드를 방문했음을 저장
    answer.add(now);  // (5) 현재 노드를 결과 리스트에 추가
    for (int next : adjList[now])
      if (!visited[next]) {
        dfs(next);
      }
  }
}
}
```
- (1) adjList 변수는 ArrayList[n + 1]로 노드의 수 + 1개만큼 배열을 생성하고, 각 배열의 인덱스마다 ArrayList 객체를 생성했다.
- (2) 그런 다음 adjList[u]에 v를 add하는 방식으로 문제에서 주어진 그래프를 인접 리스트로 만들었다.
- (3) 깊이 우선 탐색을 수행할 dfs() 메서드를 정의한다.
- (4) 이 메서드는 현재 노드 now를 방문한 다음 해당 노드에 대한 방문 여부를 visited 배열에 저장한다.
- (5) 현재 노드를 answer 리스트에 추가하고 (6) 인접한 노드를 하나씩 확인하면서 아직 방문하지 않은 노드라면, 해당 노드를 다음 노드로 하여 dfs() 메서드를 재귀 호출한다.
  이제 dfs() 메서드에 대한 설명을 마쳤다. solution() 메서드는 (7) 시작 노드인 start부터 깊이 우선 탐색 알고리즘을 수행한다.
- (8) 깊이 우선 탐색을 끝내면 answer 리스트를 배열로 변환하여 반환한다.

#### [시간 복잡도 분석하기]
노드의 개수를 N, 간선의 개수를 E라고 하면 인접 리스트를 생성할 때는 간선 개수만큼 연산하므로 시간 복잡도는 O(E)가 되고, 탐색 시 모든 노드를 1회 방문하므로 N번 방문한다.
따라서 깊이 우선 탐색의 시간 복잡도는 O(N + E)이다.

### [문제 35] 너비 우선 탐색 순회
- 권장 시간 복잡도 : O(N+E)

> 너비 우선 탐색으로 모든 노드를 순회하는 함수 solution()을 작성하세요. 시작 노드는 매개변수 start로 주어집니다. graph는 (출발 노드, 도착 노드) 쌍들이 들어 있는 리스트입니다.
> 반환값은 그래프의 시작 노드부터 모든 노드를 너비 우선 탐색으로 진행한 순서대로 노드가 저장된 리스트입니다.

#### [제약 조건]
- 노드의 최대 개수는 100개이다.
- 시작 노드부터 시작해서 모든 노드를 방문할 수 있는 경로가 항상 있다.
- 그래프의 노드는 숫자이다.

#### [입출력의 예]
|graph|start|n|return|
|:---|:---:|:---:|:---|
|[[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [5, 8], [6, 9], [7, 9]]|1|9|[1, 2, 3, 4, 5, 6, 7, 8, 9]|
|[[1, 3], [3, 4], [3, 5], [5, 2]]|1|5|[1, 3, 4, 5, 2]|
- 이 문제는 탐색 순서에 따라 정답이 여러 개일 수 있다.

#### [문제 분석하고 풀기]
깊이 우선 탐색과 같은 종류의 문제이다. 지금까지 공부한 내용이면 충분히 이 문제를 풀 수 있을 것이다. 바로 코드를 구현해보자.

```java
import java.util.ArrayDeque;
import java.util.ArrayList;

class Solution {
  // 인접 리스트 저장할 ArrayList 배열
  private static ArrayList<Integer>[] adjList;

  // 방문 여부를 저장할 boolean 배열
  private static boolean[] visited;
  private static ArrayList<Integer> answer;

  private static int[] solution(int[][] graph, int start, int n) {
    adjList = new ArrayList[n + 1];
    for (int i = 0; i < adjList.length; i++) {
      adjList[i] = new ArrayList<>();
    }

    for (int[] edge : graph) {
      adjList[edge[0]].add(edge[1]);
    }

    // (1) 방문 여부를 저장할 배열
    visited = new boolean[n + 1]];
    answer = new ArrayList<>();
    bfs(start);  // (8) 시작 노드에서 너비 우선 탐색 시작

    return answer.stream().mapToInt(Integer::intValue).toArray();
  }

  // BFS 탐색 메서드
  private static void bfs(int start) {
    // (2) 탐색 시 맨 처음 방문할 노드를 add하고 방문 처리
    ArrayDeque<Integer> queue = new ArrayDeque<>();
    queue.add(start);
    visited[start] = true;

    // (3) 큐가 비어 있지 않은 동안 반복
    while (!queue.isEmpty()) {
      // (4) 큐에 있는 원소 중 가장 먼저 추가된 원소를 poll하고 정답 리스트에 추가
      int now = queue.poll();
      answer.add(now);
      // (5) 인접한 이웃 노드들에 대해서
      for (int next : adjList[now]) {
        if (!visited[next]) {  // (6) 방문하지 않은 인접한 노드인 경우
          // (7) 인접한 노드를 방문 처리함
          queue.add(next);
          visited[next] = true;
        }
      }
    }
  }
}
```
adjList는 주어진 그래프를 인접 리스트로 표현하기 위한 변수이다. 인수로 받은 그래프의 각 간선 정보를 활용해서 인접 리스트를 만든다. 너비 우선 탐색 구현 부분은 다음과 같다.
- (1) visited의 목적은 한 번 방문한 노드를 체크해서 다시 방문하지 않도록 하는 것이다.
- (2) 시작 노드부터 너비 우선 탐색을 할 수 있도록 큐에 시작 노드를 넣고 방문 처리한다. ArrayDeque의 add() 메서드와 poll() 메서드를 이용하면 큐(queue)와 동일하게 사용할 수 있다.
- (3) 시작 노드를 기준으로 너비 우선 탐색을 진행한다. 큐가 비는 시점, 즉 방문할 수 있는 모든 노드에 방문할 때까지 탐색을 진행한다.
- (4) 현재 poll한 노드를 answer 리스트에 add하고, 인접 노드들을 방문할 것이다.
- (5) node와 인접한 노드들을 순회하면서 (6) 인접한 노드 중 방문하지 않은 노드가 있다면 (7) 해당 노드를 방문 처리하고 add한다. 여기까지가 너비 우선 탐색 동작이다.
- (8) 시작 노드부터 너비 우선 탐색을 하도록 bfs(start)와 같이 호출한다.

#### [시간 복잡도 분석하기]
노드의 개수를 N, 간선의 개수를 E라고 하면 인접 리스트를 생성할 때는 간선 개수만큼 연산하므로 시간 복잡도는 O(E)가 되고, 탐색 시 모든 노드를 1회 방문하므로 N번 방문한다.
따라서 너비 우선 탐색의 시간 복잡도는 O(N + E)이다.

### [문제 36] 다익스트라 알고리즘
- 권장 시간 복잡도 : O((N+E)logN)

> 주어진 그래프와 시작 노드를 이용하여 다익스트라 알고리즘을 구현하는 solution() 함수를 작성하세요. 인수는 graph, start 총 2개입니다.
> graph는 배열로 주어지며 노드의 연결 정보와 가중치가 저장되어 있습니다.
> 예를 들어 [[1, 3, 2], [2, 3, 4]]이면 1번 노드에서 3번 노드는 가중치 2로 연결되어 있고, 2번 노드에서 3번 노드는 가중치 4로 연결되어 있는 것입니다.
> start는 정수형으로 주어지며 출발 노드를 의미합니다. n은 정수형으로 주어지며 노드의 개수입니다. 반환값은 시작 노드부터 시작 노드를 포함한 모든 노드까지의 최단 거리를 순서대로 저장한 배열입니다.

#### [제약 조건]
- 그래프의 노드 개수는 최대 10,000개이다.
- 각 노드는 0 이상의 10,000 이하 정수로 표현한다.
- 모든 가중치는 0 이상의 정수이며 10,000을 넘지 않는다.

#### [입출력의 예]
|graph|start|n|return|
|:---|:---:|:---:|:---:|
|[[0, 1, 9], [0, 2, 3], [1, 0, 5], [2, 1, 1]]|0|3|[0, 4, 3]|
|[[0, 1, 1], [1, 2, 5], [2, 3, 1]]|0|4|[0, 1, 6, 7]|

예를 들어 첫 번째 입력에 대한 결과를 그림으로 나타내면 다음과 같다. 반환값을 분석하면 시작 노드를 기준으로 1의 최소 비용은 4이고, 최단 경로는 0 → 2 → 1이다.

<img src="https://github.com/user-attachments/assets/e6770b08-1343-4ff2-9aab-683958568a95" width="420"><br/>

#### [문제 분석하고 풀기]
이 문제에서는 우선순위 큐(heap) 자료구조로 최단 거리를 관리한다.
```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.PriorityQueue;

class Solution {
  // 노드의 정보(노드 번호와 거리)를 쌍으로 저장할 클래스 생성
  private static class Node {
    int dest, cost;

    public Node(int dest, int cost) {
      this.dest = dest;
      this.cost = cost;
    }
  }

  public static int[] solution(int[][] graph, int start, int n) {
    // (1) 인접 리스트를 저장할 ArrayList 배열 초기화
    ArrayList<Node>[] adjList = new ArrayList[n];
    for (int i = 0; i < adjList.length; i++) {
      adjList[i] = new ArrayList<>();
    }

    // (2) graph 정보를 인접 리스트로 저장
    for (int[] edge : graph) {
      adjList[edge[0]].add(new Node(edge[1], edge[2]);
    }

    int[] dist = new int[n];
    // (3) 모든 노드의 거리 값을 무한대로 초기화
    Arrays.fill(dist, Integer.MAX_VALUE);

    // (4) 시작 노드의 거리 값은 0으로 초기화
    dist[start] = 0;

    // (5) 우선순위 큐를 생성하고 시작 노드를 삽입
    PriorityQueue<Node> pq = new PriorityQueue<>((o1, o2) -> Integer.compare(o1.cost, o2.cost));
    pq.add(new Node(start, 0));

    while (!queue.isEmpty()) {
      // (6) 현재 가장 거리가 짧은 노드를 가져옴
      Node now = queue.poll();

      // (7) 만약 현재 노드의 거리 값이 큐에서 가져온 거리 값보다 크면, 해당 노드는 이미 방문한 것이므로 무시
      if (dist[now.dest] < now.cost) {
        continue;
      }

      // (8) 현재 노드와 인접한 노드들의 거리 값을 계산하여 업데이트
      for (Node next : adjList[now.dest]) {
        // (9) 기존에 발견했던 거리보다 더 짧은 거리를 발견하면 거리 값을 갱신하고 큐에 넣음
        if (dist[next.dest] > dist[now.dest] + next.cost) {
          dist[next.dest] = dist[now.dest] + next.cost);
          pq.add(new Node(next.dest, dist[next.dest]);
        }
      }
    }

    // (10) 최단 거리를 담고 있는 배열을 반환
    return dist;
  }
}
```
- (1) adjList는 graph의 정보를 인접 리스트 형태로 저장할 배열이다. 반드시 for문을 통해서 각 배열의 인덱스마다 ArrayList 객체를 생성해서 할당해야 한다.
- (2) graph의 정보를 인접 리스트 형태로 저장한다. graph처럼 간선의 정보가 리스트 형태로 저장된 것을 간선 리스트라고 한다.
  간선 리스트는 어떤 노드 A에 연결된 간선 정보를 알기 위해 O(N)의 시간이 걸리기 때문에 다익스트라 알고리즘에 적용하기에 적합하지 않다. 따라서 인접 리스트로 데이터를 가공해야 사용한다.
- (3) 모든 노드의 최단 거리 값을 무한대로 초기화한다.
- (4) 시작 노드의 최단 거리는 0으로 저장한다. 시작 노드에서 시작 노드까지는 비용이 0임을 의미한다.
- (5) 발견한 경로의 정보를 저장할 우선순위 큐를 생성하고 시작 노드를 삽입한다.
- (6) 현재 기준에서 거리가 가장 짧은 노드를 우선순위 큐에서 꺼낸다. 우선순위 큐는 거리가 짧은 노드일수록 우선순위가 높으므로 큐에서 꺼내는 순간 해당 노드까지의 최단 거리를 확정한다.
  그 이후 더 짧은 경로로 동일한 노드에 도달하는 상황은 없다.
- (7) 따라서 만약 현재 노드의 최단 거리 값이 큐에서 가져온 거리 값보다 크면 해당 경로는 더 먼 길로 돌아온 경우이므로 무시한다.
- (8) 현재 노드에 연결된 간선들을 전부 확인한다.
- (9) 기존에 발견했던 최단 거리보다 더 짧은 거리를 발견하면 최단 거리 값을 갱신하고 우선순위 큐에 넣는다.
- (10) 최단 거리를 담고 있는 dist 배열을 반환한다.

  - (3)의 Integer.MAX_VALUE는 int형이 저장할 수 있는 최댓값인 2,147,483,647을 저장하고 있는 상수이다.
    이 코드에서와 같이 무한대를 표현해야 되는 상황에서 Integer.MAX_VALUE를 사용하면 유용하다. Integer.MAX_VALUE에 1이라도 더하면 오버플로가 발생하여 음수가 된다.
    이러한 경우 오답이 나올 수 있으니 더하기 연산이나 곱하기 연산을 가정한 상황에서는 사용에 유의해야 한다.

  - 무한대를 표현하는 다른 방법으로는 987,543,321 자체를 상수로 선언해서 사용하는 방법도 있다.
    이 방법은 덧셈 연산에 대해 오버플로가 발생하지 않으면서, 실제 int형의 최댓값과 큰 차이가 없어 근사값으로 사용할 수 있을 뿐만 아니라 기억하기도 쉽기 때문에 자주 사용된다.

  - 추가로 long형의 최댓값이 필요하다면 Long.MAX_VALUE를 사용하면 된다.


#### [시간 복잡도 분석하기]
노드의 개수를 N, 간선의 개수를 E라고 하자. dist 배열을 초기화할 때의 시간 복잡도는 O(N)이다.
반복문을 보면 현재 노드의 거리가 우선순위 큐에서 가져온 거리보다 작으면 무시하고 이 연산은 최대 N번 수행하므로 시간 복잡도는 O(N * logN)이다.
이후 최단 거리를 갱신하는 동작은 최대 E번을 수행하므로 시간 복잡도는 O(E * logN)이다. 여기까지가 다익스트라 알고리즘 동작이고, 시간 복잡도를 종합하여 계산하면 O((N+E)logN)이다.

사실 다익스트라 알고리즘은 방문 여부를 저장하는 배열을 따로 두고 방문한 노드 또는 정점은 방문 체크를 하고, 방문하지 않은 노드에 대해서만 탐색하는 방식으로 구현하는 것이 일반적이다.
따라서 다음과 같은 코드로 구현하지만, 여기서는 공부할 코드의 양을 줄이기 위해 최단 거리를 저장하는 배열의 값을 사용하였다.

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.PriorityQueue;

class Solution {
  private static class Node {
    int dest, cost;
    public Node(int dest, int cost) {
      this.dest = dest;
      this.cost = cost;
    }
  }

  public static int[] solution(int[][] graph, int start, int n) {
    ArrayList<Node>[] adjList = new ArrayList<>();
    for (int i = 0; i < adjList.length; i++) {
      adjList[i] = new ArrayList<>();
    }

    for (int[] edge : graph) {
      adjList[edge[0]].add(new Node(edge[1], edge[2]));
    }

    int[] dist = new int[n];
    Arrays.fill(dist, Integer.MAX_VALUE);
    boolean[] visited = new boolean[n];  // 방문 여부를 저장할 배열

    PriorityQueue<Node> pq = new PriorityQueue<>((o1, o2) -> Integer.compare(o1.cost, o2.cost));
    dist[start] = 0;
    pq.add(new Node(start, 0));

    while (!queue.isEmpty()) {
      Node now = queue.poll();

      if (visited[now.dest]) {  // 이미 방문한 노드면 건너 뜀
        continue;
      }

      visited[now.dest] = true;  // 현재 노드 방문 처리

      for (Node next : adjList[now.dest]) {
        if (dist[next.dest] > dist[now.dest] + next.cost) {
          dist[next.dest] = dist[now.dest] + next.cost;
          pq.add(new Node(next.dest, dist[next.dest]));
        }
      }
    }

    return dist;
  }
}
```