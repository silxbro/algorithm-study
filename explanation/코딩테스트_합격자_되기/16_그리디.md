# 16. 그리디

<br/>

---
## 1. 그리디 개념
그리디(greedy)는 '탐욕스러운' 또는 '욕심이 많은'이라는 뜻이다. 그리디 알고리즘은 문제 해결 과정에서 결정 순간마다 눈앞에 보이는 최선의 선택을 하며 선택은 번복하지 않는다.

이런 특성으로 '그리디 알고리즘은 지역 최적해를 추구한다'고 말하기도 한다. 부분적으로는 최적해를 구한다고 할 수 있어도 전체적응로 최선의 해를 구했는가에 대해서는 확실히 그렇다라고 말할 수 없다.
예를 들어 물건을 사고 거스름돈을 내어주는 상황을 그리디 알고리즘으로 풀어보면 어떨까?
<br/>
<br/>
### 🥎 그리디 알고리즘으로 거스름돈 내어주기
손님에게 8원을 거슬러줘야 하는데 동전 종류가 5, 4, 1원만 있는 상황을 생각해보자. 이때 동전 개수를 가장 적게 만들기 위해 그리디 알고리즘을 활용해보자.

**[1단계]** 전략은 가장 값이 큰 동전부터 주기이다. 그리디 알고리즘은 현재 상황에서 최선의 선택을 하니 값이 가장 큰 동전부터 준다고 생각하는 것이다. 그러니 5원부터 생각해보자.
5원을 주면 3원을 거스름돈으로 더 줘야한다.

<img src="https://github.com/user-attachments/assets/7654881e-91b5-4ca1-a8b1-b09fceb91c75" width="260"/><br/>

**[2단계]** 나머지 3원은 1원 3개를 주는 방법 밖에는 없다. 그러면 총 4개의 동전으로 거스름돈을 주었다.

<img src="https://github.com/user-attachments/assets/cc6eab2a-089f-4299-9183-0820acf720ba" width="270"/><br/>

**[3단계]** 그렇지만 이건 최선이 아니다. 눈으로 딱 봐도 4원 2개를 주는 것이 더 좋다. 하지만 그리디 알고리즘은 8원을 줘야 하는 상황에서 가장 큰 값의 동전을 고를 수밖에 없다.
그래서 그리디 알고리즘이 항상 최적의 해를 보장하진 못한다고 했던 것이다.
<br/>
<br/>
### 🥎 그리디 알고리즘이 최적해를 보장하려면?
하지만 그리디 알고리즘은 특정한 상황에서 최적해를 보장하므로 이를 활용하면 문제를 잘 해결할 수 있다. 특정한 상황이란 다음 2가지를 말한다.
- 최적 부분 구조(optimal substructure) : 부분해를 푸는 과정이 최적해를 구하는 과정과 일치
- 그리디 선택 속성(greedy selection property) : 선택 과정이 다른 과정에 영향을 주지 않음

그리디 알고리즘이 최적 부분 구조에 어긋나는 이유는 부분해를 푸는 것이 전체해를 푸는 데에 도움을 주지 않는다는 것이다.
방금 거스름돈 문제에서 8원을 거스름돈으로 주는 상황에서 5원 동전을 먼저 선택하면 그다음에는 4원 동전을 선택할 수 없다.
5원 동전을 먼저 선택한 것이 제약이 되어 동전 개수를 최소로 할 수 없게 만드는 것이다. 이렇게 그리디 알고리즘은 선택에 제약을 주어 최적의 해를 구하지 못하기도 한다.
5원을 거슬러 주는 선택은 이후 거스름돈을 주는 선택에 영향을 준다고 했던 말을 기억하자.

이런 그리디 알고리즘의 특징은 항상 최적해를 도출하지 못한다는 한계를 보여준다. 그러나 그리디 알고리즘이 무용지물은 아니다.
그리디 알고리즘은 빠른 시간 내에 근사해를 제공하는 효율적인 방법 중 하나이므로 문제의 특성과 알고리즘 선택 기준을 잘 이해하면 매우 유용하게 활용될 수 있다.
지금부터 그리디 알고리즘을 쓰면 좋은 상황을 하나씩 알아보자.

<br/>

## 2. 최소 신장 트리
최소 신장 트리는 그리디 알고리즘을 사용하는 대표적인 트리 형태의 자료구조이다. 이것을 알려면 신장 트리가 무엇인지부터 알아야한다.
<br/>
<br/>
### 🥎 신장 트리란?
신장 트리(spanning tree)는 모든 정점이 간선으로 연결되어 있고 간선 개수가 정점 개수보다 하나 적은 그래프를 말한다. 다음 그림을 보자.

<img src="https://github.com/user-attachments/assets/764af68d-836f-4c5b-9377-198217ea2741" width="380"/><br/>

그림을 보면 왼쪽 그래프는 정점이 6개, 간선이 5개이다. 오른쪽 그래프도 마찬가지이다. 그러니 두 그래프는 모두 신장 트리라고 말해도 된다. 이런 그래프는 신장 트리가 아니다.

<img src="https://github.com/user-attachments/assets/10533ee6-a120-456a-b68d-b67bfb38dd8c" width="380"/><br/>

왼쪽은 정점, 간선 개수 조건은 만족하지만 모든 정점이 연결되어 있지는 않고, 오른쪽은 간선이 많다. 신장 트리는 어려운 개념이 아니므로 이 정도면 쉽게 이해할 수 있을 것이다.
<br/>
<br/>
### 🥎 최소 신장 트리란?
신장 트리 중 간선의 가중치 합이 최소면 최소 신장 트리(minimum spanning tree)라고 한다. 경우에 따라 최소 신장 트리는 하나가 아닐 수도 있다.
최소 신자아 트리는 영어 표현에서 앞 글자만 따와 MST라 부르는 경우가 많으므로 여기서도 앞으로는 MST라고 부르겠다. MST는 실생활에서도 굉장히 많이 사용한다.
예를 들어 항공기의 운항 경로를 최적화할 때 MST를 활용한다. 네트워크 분야에서도 많이 활용한다.

#### [최소 신장 트리를 구하는 그리디 알고리즘]
최소 신장 트리를 구하는 대표적인 그리디 알고리즘은 프림 알고리즘과 크루스칼 알고리즘이다. 다음 그래프를 놓고 프림 알고리즘과 크루스칼 알고리즘으로 최소 신장 트리를 구하면서 각 알고리즘에 대해 알아보자.

<img src="https://github.com/user-attachments/assets/48da28bf-3323-4daa-a81c-edf55ed3eab0" width="250"/><br/>

#### ▼ 프림 알고리즘으로 최소 신장 트리 구하기
**프림 알고리즘(prim`s algorithm)** 은 로버트 프림이 만든 알고리즘으로 다음과 같다. 각 단계별로 프림 알고리즘을 통해 최소 신장 트리를 구하는 과정을 살펴보자.

- [1] 임의의 정점 하나를 선택해서 최소 신장 트리에 추가한다.
- [2] 최소 신장 트리와 연결되어 있는 정점 중 가장 가중치가 적은 정점을 최소 신장 트리에 추가한다(이 부분이 그리디적 선택이다). 단, 순환을 형성하지 않는 정점을 추가해야 한다.
- [3] 과정 [2]를 신장 트리 조건에 만족할 때까지 반복한다.

**[1단계]** 1을 최소 신장 트리에 추가한다.

<img src="https://github.com/user-attachments/assets/bc8288fa-fbe2-49b2-ab51-b4fe5d5da359" width="230"/><br/>

**[2단계]** 현재는 최소 신장 트리가 1이므로 1과 인접한 정점 중 가중치가 적은 4를 선택하여 최소 신장 트리에 추가한다.

<img src="https://github.com/user-attachments/assets/cdbe2c61-3723-46d5-a126-f2e07194df26" width="230"/><br/>

**[3단계]** 이제 최소 신장 트리 1 - 4에 연결된 정점 중 가중치가 적은 5를 선택하여 최소 신장 트리에 추가한다.

<img src="https://github.com/user-attachments/assets/1e880baf-41d9-46aa-9146-fa3ac3afb48f" width="230"/><br/>
- 점선으로 최소 신장 트리 1 - 4에 연결된 후보 간선을 표시했다.

**[4단계]** 나머지 과정도 같다. 이때 순환이 생기지 않도록 유의한다.

<img src="https://github.com/user-attachments/assets/5e5ed0d4-bf54-4a3f-a0ef-b30f45e688f7" width="230"/><br/>

#### ▼ 크루스칼 알고리즘으로 최소 신장 트리 구하기
크루스칼 알고리즘(kruskal algorithm)은 다음과 같다.

- [1] 그래프의 모든 간선을 가중치 기준으로 오름차순 정렬한다.
- [2] 가중치가 낮은 간선부터 최소 신장 트리에 하나씩 추가한다(이 부분이 그리디적 선택이다). 단, 순환을 형성하지 않아야 한다.
- [3] 과정 [2]를 신장 트리 조건에 만족할 때까지 반복한다.

크루스칼 알고리즘은 모든 간선을 가중치 기준으로 오름차순 정렬한다는 점만 빼면 나머지 규칙은 프림 알고리즘과 같다. 바로 단계별 알고리즘 진행을 살펴보자.

**[1단계]** 아래 표를 보면 가중치를 오름차수능로 정리하고 그 가중치 양 끝에 있는 정점을 시작, 도착으로 표시했다.

<img src="https://github.com/user-attachments/assets/f8904f07-a53c-42b3-afa0-c63760b375f6" width="400"/><br/>

**[2단계]** 가중치가 가장 낮은 2 - 3을 최소 신장 트리에 추가한다.

<img src="https://github.com/user-attachments/assets/c1edecd3-66a8-4e0e-8051-f663f39a58a2" width="400"/><br/>

**[3단계]** 다음도 순환이 생기지 않는다면 추가한다. 이렇게 가중치 오름차순 순서대로 따라가며 순환 생성 여부에 따라 최소 신장 트리에 포함시키면 된다.
- 경우에 따라 신장 트리 중 간선의 가중치 합이 최소인 경우는 하나가 아닐 수 있으므로 최소 신장 트리는 하나 이상일 수도 있다.

<img src="https://github.com/user-attachments/assets/dc311f34-4d15-4cb0-b69c-4c4e86591622" width="400"/><br/>

#### [프림 알고리즘과 크루스칼 알고리즘의 비교]

||프림|크루스칼|
|:---:|:---:|:---:|
|**알고리즘 목적**|최소 신장 트리|최소 신장 트리|
|**시간 복잡도 (정점 V, 간선 E)**|O(E * logV)<br/>(인접 행렬 활용 시 O(N^2))|O(E * logE)<br/>|
|**탐색 방법**|임의 정점에서 최소 인접 가중치를 가지는<br/>정점을 찾아 확장하는 방식|최소 가중치를 가지는 간선부터 하나씩<br/>추가하는 방식|

- E는 간선, V는 정점의 개수이다.

<br/>

## 3. 배낭 문제
배낭에 담을 수 있는 최대 무게가 존재하고, 무게와 가치가 다른 짐들이 있다.
이 짐들을 잘 조합해서 배낭의 무게를 초과하지 않으면서 담은 가치를 최대로 하는 문제를 배낭 문제(knapsack problem)이라고 한다.
실제로 배낭 문제는 배낭과 짐을 정의하여 설명한다. 다음 그림을 보자.
- 배낭 문제를 냅색 문제라고 부르는 사람도 많다.

<img src="https://github.com/user-attachments/assets/6e11195b-65c7-454c-b3c1-964bb4597570" width="320"/><br/>

왼쪽의 A, B, C는 짐이고 오른쪽은 배낭이다. 짐에는 무게와 가치, 배낭에는 짐을 넣을 수 있는 총 무게가 표시되어 있다. 이 그림을 놓고 배낭 문제 두 종류를 설명하려고 한다.
배낭 문제의 목표는 모두 '최대한 배낭에 높은 가치의 짐을 넣는다'이지만 짐을 쪼갤 수 있는지 없는지에 따라 부분 배낭 문제와 0/1 배낭 문제로 나뉜다.
이 조건에 따라 문제에 접근하는 방식이 달라지므로 두 방법을 모두 알아보자.
<br/>
<br/>
### 🥎 짐을 쪼갤 수 있는 부분 배낭 문제
먼저 부분 배낭 문제(fractional knapsack problem)이다. 부분 배낭 문제를 해결하려면 무게당 가치가 높은 짐을 최대한 많이 넣는 그리디 알고리즘을 사용하면 된다.

- [1] 짐별로 무게당 가치를 구한다.
- [2] 무게당 가치가 높은 짐부터 넣을 수 있는 만큼 배낭에 넣는다.
    - [2-1] 배낭 용량이 짐 무게보다 크면 짐을 쪼개서 넣는다.
- [3] 과정 [2]를 배낭이 허용하는 용량이 0이 될 때까지 수행한다.

실제로 그렇게 하면 어떻게 되는지 단계별로 살펴보자.

**[1단계]** 무게당 가치를 계산한다.

<img src="https://github.com/user-attachments/assets/5190dc78-5b13-42b2-a368-5a4bf1ca4142" width="280"/><br/>

**[2단계]** 무게당 가치가 높은 짐은 A이므로 이것을 먼저 배낭에 넣는다. 배낭의 용량은 15kg이므로 모두 넣을 수 있다.

<img src="https://github.com/user-attachments/assets/4ec5e747-17d2-477b-b0a3-ef34e150b291" width="380"/><br/>

**[3단계]** 그다음에 가치가 높은 짐은 C이다. 가용 용량이 5kg이므로 C는 5kg만 넣는다.

<img src="https://github.com/user-attachments/assets/23a184e2-0be9-46c2-9300-1d697d4a0fbc" width="380"/><br/>

**[4단계]** 그러면 A, C를 배낭에 넣지만 C는 1kg이 남는다.

<img src="https://github.com/user-attachments/assets/d3383fae-97e9-45ec-93d0-b1acbf0e81b0" width="380"/><br/>

이렇게 그리디 알고리즘으로 부분 배낭 문제를 풀 수 있다. 실제로 매 순간 짐을 선택하는 방식은 무게당 가치가 높은 짐이므로 최적 부분 구조를 만족한다.
그리고 짐을 쪼갤 수 있으니 앞에서 선택한 짐이 다른 짐 선택에 영향을 주지도 않으므로 그리디적 선택 요소에도 만족한다. 따라서 이 방식은 최적해를 보장한다고 할 수 있다.
<br/>
<br/>
### 🥎 짐을 쪼갤 수 없는 0/1 배낭 문제
이제 0/1 배낭 문제(0/1 knapsack problem)이다. 이 문제는 짐을 쪼갤 수 없어서 지금 선택한 짐이 다음 짐 선택에 영향을 준다. 그래서 그리디 알고리즘을 적용하면 최적의 해를 구할 수 없다.
최적의 해를 구하려면 동적 계획법으로 접근해야 한다. 실제로 그리디 알고리즘으로 풀 수 없는 이유도 알아보자. 여기서도 부분 배낭 문제에서 세운 그리디 알고리즘을 적용한다.
- 그래서 0/1 배낭 문제는 그리디 알고리즘으로 근사해를 구할 수 있다고 이야기하기도 한다.

**[1단계]** 무게당 가치가 높은 짐부터 넣는다. A를 넣어야 하므로 가용 용량은 5kg가 남는다. 이 상태에서는 짐을 쪼갤 수 없으므로 더 이상 넣을 수 있는 짐이 없다.

<img src="https://github.com/user-attachments/assets/babbaa9d-338a-45a7-af49-b8d51bf8b587" width="380"/><br/>

**[2단계]** 현재 배낭에 넣은 짐의 가치는 19이다. 하지만 B, C를 넣었다면 더 높은 가치로 짐을 넣을 수 있었을 것이다.

<img src="https://github.com/user-attachments/assets/854fc463-acfc-4e2f-948e-49d26f684f82" width="380"/><br/>

이처럼 0/1 배낭 문제는 그리디 알고리즘으로 최적화 해를 구할 수 없다. 앞서 언급했듯 0/1 배낭 문제는 현재 짐의 선택이 다음 짐 선택에 영향을 주므로 그리디 알고리즘으로 풀 수 없기 떄문이다.
다음은 두 문제를 비교한 표이다. 배운 내용을 표로 정리하고 넘어가기 바란다.

||부분 배낭 문제|0/1 배낭 문제|
|:---:|:---:|:---:|
|**알고리즘 목적**|배낭 속 짐들의 가치의 합이 최대가 되도록 함|배낭 속 짐들의 가치의 합이 최대가 되도록 함|
|**문제 특징**|짐을 쪼갤 수 있음|짐을 쪼갤 수 없음|
|**시간 복잡도 (짐의 개수 N, 가치 W)**|O(N * logN)|O(N * W)|
|**그리디 적용 가능 여부**|O|X|