# 10. 집합

<br/>

---

## 1. 집합과 상호배타적 집합의 개념
### 🥎 집합의 개념
집합은 순서와 중복이 없는 원소들을 갖는 자료구조를 말한다.
예를 들어 어떤 A라는 그룹의 원소 구성이 {1, 6, 6, 6, 4, 3}이면 이는 집합으로 생각할 때 중복을 제외해 {1, 6, 4, 3}으로 생각해야 한다.
물론 순서를 따지지 않으니 {6, 1, 3, 4}와 같이 생각해도 된다.

#### [집합의 종류]
집합은 특성에 따라 부르는 말이 다양하다. 원소 개수가 유한하면 유한 집합, 무한하면 무한 집합, 아무런 원소도 없으면 공집합 등 다양하다.
이 외에도 여러 집합이 있지만 이 책에서는 상호배타적 집합에 집중한다.

#### [상호배타적 집합이란?]
앞으로 집합이라 말하는 것은 상호배타적 집합이라고 생각하면 된다. 상호배타적 집합은 교집합이 없는 집합 관계를 말한다. 교집합이 없다는 말부터 이해해보자.
그림으로 보면 좀 더 직관적이다. 다음 그림을 보자.

<img src="https://github.com/user-attachments/assets/aac05a0e-7c28-4734-a7ae-79ba1067a9a2" width="350"><br/>

A = {1, 2, 3}이고 B = {4, 5, 6, 7}이다. 이렇게 집합 A와 집합 B의 원소 중 겹치는 원소가 없으면 교집합이 없다고 할 수 있고 이를 상호배타적 집합이라고 한다.
반대로 다음은 상호배타적 집합이 아니다. 왜냐하면 집합 A의 원소 5는 집합 B에도 있기 때문이다.

<img src="https://github.com/user-attachments/assets/2f1f91fd-ee32-4991-8df5-3fd83be16fe3" width="350"><br/>

### 🥎 상호배타적 집합의 특성을 활용하는 분야
코딩테스트에서 상호배타적 집합을 배워야 하는 가장 현실적인 이유는 그래프 알고리즘에서 많이 활용하기 때문이다.
그래프 알고리즘에서는 흔히 사이클을 확인하는 일이 많은데, 그 작업에 상호배타적 집합 개념을 활용한다. 이 외에도 상호배타적 집합 개념을 활용하는 알고리즘은 다양하다.

- **이미지 분할** : 이미지를 서로 다른 부분으로 나누는 데 사용한다. 예를 들어 사람과 배경을 겹치지 않게 분할하는 데 사용될 수 있다.
- **도로 네트워크 구성** : 도로를 구축할 때 각 도로를 서로 교차하지 않도록 설계하는 데 사용할 수 있다. 이를 통해 교차로의 혼잡을 줄일 수 있다.
- **최소 신장 트리 알고리즘 구현** : 최소 신장 트리 알고리즘을 구현해서 간선을 추가할 때마다 사이클을 형성하는지 여부를 체크할 때 사용한다.
- **게임 개발** : 캐릭터의 동작을 자연스럽게 구현할 수 있다. 예를 들어 플레이어와 적군이 충돌할 때 두 캐릭터가 겹치지 않도록 하는 데 사용할 수 있다.
- **클러스터링 작업** : 각 작업이 서로 겹치지 않도록 구성할 수 있다. 이렇게 작업 간의 의존 관계가 없으면 동시에 여러 작업을 진행할 수 있다.

<br/>

## 2. 집합의 연산
집합을 표현하는 방법과 관련 연산들을 알아보자. 보통 집합은 트리로 표현하며 대표적인 연산은 합치기와 탐색이 있다. 이 둘을 순서대로 알아보자.

### 🥎 배열을 활용한 트리로 집합 표현하기
집합은 배열을 활용한 트리로 구현한다. 각 집합에는 대표 원소가 있어야 하므로 대표 원소가 무엇인지부터 알아보자.

#### [대표 원소란?]
대표 원소는 집합의 원소 중 집합을 대표하는 역할을 한다. 다만 여기서는 집합의 형태를 트리로 표현할 것이므로 이후 대표 원소는 루트 노드라고 부르겠다.
- 개념적으로 집합의 대표 원소와 트리의 루트 노드는 같다.

#### [배열로 집합을 표현하는 것이란?]
집합을 배열로 표현한다는 것은 하나의 배열로 상호배타적 관계를 가지는 집합을 모두 표현한다는 것을 의미한다. 그리고 집합을 트리 형태로 표현할 때는 다음을 기억하면 된다.
- 배열의 인덱스는 자신을, 배열값은 부모 노드를 의미한다.

예를 들어 disjoint_set[9] = 3이면 노드 9의 부모 노드는 3임을 의미한다. 루트 노드는 말 그대로 집합의 대표이므로 부모가 없고, 부모 노드가 자기 자신이다.
다시 말해 루트 노드는 값 자체가 배열의 인덱스와 동일하다. 다음 그림을 보면 쉽게 이해할 수 있을 것이다.

<img src="https://github.com/user-attachments/assets/48f7280f-f9f7-41c5-8b0f-c9f2c33a5d98" width="600"><br/>

그렇다면 집합을 표현하는 데 사용하는 배열의 크기는 어때야 할까? 배열의 인덱스가 모든 집합의 원소를 표현할 수 있으면 된다.
예를 들어 앞서 본 그림은 값이 가장 큰 원소가 9이므로 배열의 크기는 10으로 잡아야 한다. 왜냐하면 배열의 인덱스는 0부터 시작하는데 보통 집합을 배열로 표현할 때 0은 사용하지 않기 때문이다.

#### [집합 표현 완벽 정리하기]
그럼 다른 예를 보면서 집합 개념을 완벽히 정리하고 넘어가자. 오른쪽 그림을 보면, 위와 같은 집합을 앞서 본 것처럼 disjoint_set 배열을 활용한 트리로 나타내면 다음 특성을 가지게 된다.

<img src="https://github.com/user-attachments/assets/316d7cae-3ee7-496f-89ac-4d08acd1641a" width="250"><br/>

1. 각 집합의 루트 노드는 1과 4이다. 이를 disjoint_set 배열에 표현하면 disjoint_set[1] = 1, disjoint_set[4] = 4이다. 즉, 인덱스와 값이 같다.
2. disjoint_set[3] = 2, disjoint_set[2] = 1을 해석해보면 집합 A의 원소 3의 부모는 2, 집합 B의 원소 2의 부모는 1이라는 뜻이다.
   - 그리고 원소 3은 disjoint_set[3] = 2, disjoint_set[2] = 1, disjoint_set[1] = 1이므로 '원소 3은 원소 1이 루트 노드인 집합에 속한다'라고 이야기할 수 있다.
3. 집합 A와 집합 B를 표현할 배열의 크기를 10으로 한다
4. 두 집합은 하나의 배열(disjoint_set)로 표현할 수 있다.

- 집합의 개수는 로트 노드의 개수를 보면 된다. 즉, 배열의 인덱스와 값이 같은 경우가 몇 번인지 확인하면 된다.

#### [집합을 배열로 구현하기]
이제 배열을 활용한 트리로 집합을 표현한다는 것이 무엇인지 감을 잡았을 것이다. 집합을 실제로 구현하면 어떻게 될지도 살펴보자.

**[1단계]** 앞서 그림으로 본 집합을 배열로 표현하면 초기 상태는 다음과 같다.

<img src="https://github.com/user-attachments/assets/e0242ac2-ee53-4877-a352-e64334a6b2a2" width="400"><br/>

초기 각 노드는 자기 자신을 루트 노드로 하였고, 집합에 없는 인덱스의 값은 -1로 하였다. 아직 1, 2, 3, 4, 5, 8, 9는 누구와도 연결되지 않았으므로 자기 자신을 부모 노드로 한다.

**[2단계]** 이제 집합이 완성되었을 때 그림이다. 그림을 보면 2개의 집합이 있다. 집합 A는 {1, 2, 3, 5, 9}이고 집합 B는 {4, 8}이다.
루트 노드는 음영 처리한 1과 4이다. 그리고 점선으로 노드 9의 루트 노드를 찾는 과정을 표시했다. 9 -> 3 -> 2 -> 1 순서로 이동한다.

<img src="https://github.com/user-attachments/assets/192cbdf3-ebd2-4499-978a-412f58776a77" width="400"><br/>

### 🥎 유니온-파인드 알고리즘
집합 알고리즘에 주로 쓰이는 연산은 합치기와 탐색이다. 보통 합치기는 유니온(union), 탐색을 파인드(find)라고 하므로 이 둘을 묶어 유니온-파인드(union & fin) 알고리즘이라고 한다.
유니온-파인드 알고리즘의 이름 순서로는 유니온 연산이 먼저 나오지만 유니온 연산보다 파인드 연산을 먼저 아는 것이 유니온-파인드 알고리즘을 이해하기가 더 좋으므로 파인드 연산부터 설명하겠다.

#### [파인드 연산]
파인드 연산은 특정 노드의 루트 노드가 무엇인지 탐색하는 방법이다. 보통 파인드 연산은 특정 노드가 같은 집합에 있는지 확인할 때 사용한다.
예를 들어 A, B 두 노드가 있는데 이 노드의 루트 노드가 서로 같다면 같은 집합에 속한 것이다. 그리고 찾기 연산은 앞서 배열로 집합을 설명할 때 점선 화살표로 그 과정을 간접적으로 설명하였다.
특정 노드부터 재귀로 거슬로 올라가며 루트 노드를 찾았던 과정 말이다. 그 과정을 정리하면 대략 다음과 같다.

1. 현재 노드의 부모 노드를 확인한다. 부모 노드를 확인하다가 부모 노드가 루트 노드이면 찾기 연산을 종료한다.
2. 1에서 찾기 연산이 종료되지 않으면 1을 반복한다.

그럼 이 과정을 실제 예와 함께 단계별로 보겠다.

**[1단계]** 찾기 연산을 설명하는 데 사용할 집합을 정의한다. 노드 7의 루트 노드를 찾는 과정을 알아보겠다. 이를 find(7)로 표현할 수 있다.

<img src="https://github.com/user-attachments/assets/442aa558-4c4f-4069-9801-0e091ce84732" width="550"><br/>

**[2단계]** 노드 7의 루트 노드를 찾는다. 현재 노드와 부모 노드가 같을 때까지 탐색 과정을 반복한다.
(1) 노드 7의 부모 노드는 6이다. 현재 노드와 부모 노드가 같지 않으므로 현재 노드를 부모 노드인 6으로 변경한다. (2) 현재 노드 6의 부모 노드는 2이므로 현재 노드를 6에서 2로 변경한다.
(3) 다음도 마찬가지이다. 현재 노드 2의 부모 노드는 1이므로 현재 노드를 1로 한다. 현재 노드 1의 부모 노드는 1이다. (4) 현재 노드와 부모 노드가 같으므로 루트 노드이다. 루트 노드 1을 찾았다.

<img src="https://github.com/user-attachments/assets/302bdd1b-17f6-4684-853f-75000b6d0959" width="550"><br/>

이와 같은 탐색 연산은 재귀 함수로 구현한다. 루트 노드를 현재 노드와 부모 노드가 같을 때까지 재귀 함수를 실행해 최종값을 반환하면 된다.
구현은 간단하지만 이 연산은 최악의 경우 시간 복잡도가 O(N)일 수 있다. 다음 그림을 보자.

<img src="https://github.com/user-attachments/assets/3783f7b7-07c4-49cb-8619-b04d6e6ed804" width="200"><br/>

그림에서 find(4)를 실행하면 모든 노드를 거쳐야 루트 노드를 찾을 수 있다. 파인드 연산에서 목표로 하는 것은 '루트 노드 찾기'지 '부모 노드 찾기'가 아니므로 부모 노드를 거치는 과정은 비효율적이다.
좀 더 빨리 루트 노드를 찾을 수 있는 방법이 없을까? 이를 개선하기 위해 경로 압축을 활용할 수 있다.

#### [파인드 연산의 연산 비용 문제, 경로 압축으로 해결하자]
좀 더 효율적으로 파인드 연산을 하기 위해서는 집합 형태를 유지하면서도 트리 높이를 줄이면 된다 트리의 높이를 줄이므로 앞서 언급한 파인드 연산의 부모 노드를 거치는 과정을 줄일 수 있다.
경로 압축 후의 찾기 연산은 다음과 같이 매우 간략해진다.

<img src="https://github.com/user-attachments/assets/88d9cca0-544d-4caf-8196-664736671594" width="600"><br/>

경로 압축 전후의 트리를 비교하면 트리 깊이가 다르다. 트리 깊이가 낮아지면 최악의 경우 수행해야 할 연산 횟수가 줄어듬을 의미한다.
경로 압축 이후 find(2), find(3), find(4) 연산이 모두 한 번에 수행될 수 있음을 알 수 있다.
- 경로 압축은 집합을 구성하는 트리를 평평하게(flatten) 만들어서 찾기 연산을 효율적으로 할 수 있게 한다.

#### [합치기 연산]
합치기 연산은 두 집합을 하나로 합치는 연산이다. '두 집합을 합친다'는 것은 두 집합의 루트 노드를 같게 하는 것이다. 이때 루트 노드는 두 집합의 루트 노드 중 하나가 되면 된다.
과정을 정리하면 다음과 같다.

1. 두 집합에서 찾기 연산을 통해 루트 노드를 찾는다.
2. 찾은 두 루트 노드의 값을 비교한다.
3. 두 집합을 합친다. 합치는 방법은 간단하다. 두 집합의 루트 노드를 같게 하는 것이다. 이때 루트 노드는 두 집합 중 어떤 루트 노드로 해도 상관 없다.

합치기 연산 과정을 예를 들어 이해해보자.

**[1단계]** 집합 A와 B가 있다. 집합 A의 노드는 {1, 3, 5}이고 집합 B의 노드는 {2, 7, 9}이다.

<img src="https://github.com/user-attachments/assets/d3172bad-3f10-4c95-8464-39b6345d29e5" width="400"><br/>

**[2단계]** 집합 A와 B의 말단 노드 중 임의의 노드 5와 7의 루트 노드를 찾는다고 해보자. 찾기 연산을 수행하면 노드 5가 속한 집합의 루트 노드는 1이고, 노드 7의 루트 노드는 2이다.

<img src="https://github.com/user-attachments/assets/d6844358-f913-4a63-a4a6-dfe7c870586d" width="480"><br/>

**[3단계]** 루트 노드가 2인 집합의 루트 노드를 1로 바꾼다. 이렇게 하면 그림에서 보는 것처럼 자연스럽게 두 집합을 합칠 수 있게 된다.

<img src="https://github.com/user-attachments/assets/b0bf68d9-6187-4abf-a9ab-b769380a29be" width="420"><br/>

**[4단계]** 집합이 잘 합쳐졌는지 확인해보자. 집합 A는 변경된 것이 없다. 집합 B는 루트 노드의 부모 노드가 2에서 1로 바뀌었다. 9에서 부모 노드를 쫓아가면 1이 나온다. 즉, 잘 합쳐졌다.

<img src="https://github.com/user-attachments/assets/e352aaf4-259c-4d36-8771-52bb426eb7bd" width="420"><br/>

#### [합치기 연산의 연산 비용 문제, 랭크로 해결하자]
합치기 연산이 잘 이해됐을 것이다. 그런데 여기서 소개한 방식의 합치기 연산은 조금 생각하면 찾기 연산처럼 트리의 깊이가 깊어지면 깊어질수록 연산 비용이 커진다는 단점이 있다.
이를 개선하려면 랭크라는 개념이 필요하다.
- 랭크 개념을 도입하는 목적은 '트리의 균형을 유지하기 위함'이다.

#### [랭크란?]
랭크란 현재 노드를 기준으로 하였을 때 가장 깊은 노드까지의 경로 길이를 말한다. 이 역시도 그림으로 이해해보자. 각 노드의 랭크를 표시하면 다음과 같다.

<img src="https://github.com/user-attachments/assets/edbb808f-039f-45c1-8749-8cd9f06ea276" width="180"><br/>

그림에서 보듯 1의 랭크는 노드 4까지의 경로가 가장 깊기 때문에 2이다. 노드 4, 3의 랭크는 해당 노드보다 더 깊은 노드가 없으므로 0이다.

#### [랭크 기반으로 합치기 연산하기]
이제 랭크를 기반으로 합치기 연산을 하는 방법을 알아보자. 랭크 기반의 합치기 연산은 다음 규칙을 따른다.

1. 두 노드의 루트 노드를 구한다.
2. 1에서 구한 루트 노드의 랭크를 비교한다.
   - 랭크값이 다르면 랭크값이 큰 루트 노드를 기준으로 삼는다. 즉, 랭크가 더 큰 루트 노드를 랭크가 작은 루트 노드의 부모 노드로 바꾼다.
     이때 트리의 깊이는 더 깊어지지 않으므로 랭크의 값은 변하지 않는다.
   - 랭크값이 같으면 루트 노드를 아무거나 선택해서 바꾸고 최종 루트 노드의 랭크에 1을 더한다.

앞서 계속 봐왔던 것처럼 랭크 기반 합치기 연산도 구체적인 예를 들어 알아보자.

**[1단계]** 집합을 2개 정의했다.

<img src="https://github.com/user-attachments/assets/b5c222ad-4b5a-4ad7-909b-efe547fc7cbb" width="350"><br/>

**[2단계]** 두 집합을 랭크 기반으로 합치는 모습이다. 노드 1의 랭크는 2, 노드 5의 랭크는 1이다. 노드 1의 랭크가 더 크므로 노드 5의 부모 노드를 1로 바꾼다. 이때에는 노드 1의 랭크를 바꿀 필요가 없다.
왜냐하면 집합의 랭크값을 바꾼다는 것은 트리의 깊이가 깊어진다는 것을 의미하는데 지금은 왼쪽 집합이 오른쪽 집합보다 최소 1만큼 크므로 트리가 깊어지지 않기 때문이다.

<img src="https://github.com/user-attachments/assets/f73c76e9-3a0c-4901-8265-e00ade0c19ce" width="350"><br/>

<br/>

## 3. 몸풀기 문제

### [문제 30] 간단한 유니온-파인드 알고리즘 구현하기
- 권장 시간 복잡도 : O(NlogN)

> 상호배타적 집합을 표현하고 관리하는 데 다음 두 연산이 필요합니다.
> - union(x, y): x와 y가 속한 두 집합을 합칩니다.
> - find(x): x가 속한 집합의 대표 원소를 찾습니다.
>
> operations라는 배열은 수행할 연산을 의미합니다. 연산 종류는 2개입니다.
> - [0, 1, 2]는 노드 1과 노드 2에 대해 union 연산 수행
> - [1, 1, 3]는 노드 1과 3이 같은 집합에 속해 있으면 true, 아니면 false를 반환하는 equals 연산
>
> 초기의 노드는 부모 노드를 자신의 값으로 설정했다고 가정하며, 여기서는 각 집합의 루트 노드를 기준으로 루트 노드가 작은 노드를 더 큰 노드의 자식으로 연결하는 방법을 사용합니다.
> operations에 있는 연산에 대한 결과를 연산 순서대로 담은 Boolean 배열을 반환하는 solution() 메서드를 구현해주세요.

#### [제약 조건]
- 0 <= k <= 1,000 : 노드의 개수
- 1 <= len(operations) <= 100,000
- operations[i][0]은 문자열 'u' 또는 'f' 중 하나
- 0은 union 연산, union 연산 뒤로는 두 개의 정수 x, y가 나옴
- 1은 equals 연산, equals 연산 뒤로는 두 개의 정수 x, y가 나옴
- x와 y는 0 이상 k-1 이하의 정수
- 연산은 항상 유효함
   - 즉, union, find 연산의 인수는 상호배타적 집합 내에 있는 노드 번호

#### [입출력의 예]
|k|operations|result|
|:---:|:---|:---:|
|3|[[0,0,1], [0,1,2], [1,1,2]]|[true]|
|4|[[0,0,1],[1,1,2],[0,1,2],[1,0,2]]|[false, true]|

#### [문제 분석하고 풀기]
각 상호배타적 집합을 합치고, 루트 노드를 찾은 뒤, 집합의 개수를 구하는 문제이다. 초기에는 모든 노드가 스스로를 루트 노드로 생각한다. 예를 들어 k가 3이면 다음과 같은 그림을 생각하면 된다.

<img src="https://github.com/user-attachments/assets/378d3709-aaf2-481e-9c28-0aac46de48b9" width="180"><br/>

이후 집합을 합치는 유니온 연산을 할 때는 루트 노드값을 기준으로 큰 쪽을 작은 쪽으로 붙이면 된다.

```java
import java.util.ArrayList;

class Solution {
  // 부모 저장을 위한 배열
  private static int[] parent;

  // 루트 노드를 찾는 메서드
  private static int find(int x) {
    // 만약 x의 부모가 자기 자신이면, 즉 x가 루트 노드라면 x를 반환
    if (parent[x] == x) {
      return x;
    }
    // 그렇지 않다면 x의 부모를 찾아서 parent[x]에 저장한다.
    parent[x] = find(parent[x]);
    return parent[x];  // 찾은 루트 노드를 반환
  }

  private static void union(int x, int y) {
    int root1 = find(x);  // x가 속한 집합의 루트 노드 찾기
    int root2 = find(y);  // y가 속한 집합의 루트 노드 찾기
    parent[root2] = root1;  // y가 속한 집합을 x가 속한 집합에 합침
  }

  private static Boolean[] solutino(int k, int[][] operation) {
    // 노드의 수 만큼 배열 생성
    parent = new int[k];
    // 처음에는 각 노드가 자기 자신을 부모로 가지도록 초기화
    for (int i = 0; i < k; i++) {
      parent[i] = i;
    }

    ArrayList<Boolean> answer = new ArrayList<>();

    for (int[] op : operation) {
      if (op[0] == 0) {  // 0 연산이면
        union(op[1], op[2]);
      }
      else {  // 1 연산이면
        answer.add(find(op[1]) == find(op[2]));
      }
    }

    return answer.toArray(new Boolean[0]);
  }
}
```
알고리즘 자체를 구현하는 문제라서 이해를 돕고자 코드에 주석을 달아서 설명했다.
유니온-파인드 알고리즘 자체를 구현하는 문제가 출제될 일은 거의 없겠지만 제대로 원리를 이해한다는 선에서 한 번 꼭 공부해보기 바란다.

#### [시간 복잡도 분석하기]
N은 operations의 길이이다. find() 메서드, union() 메서드의 시간 복잡도는 O(logN)이다.
다음으로 solution() 메서드에서 각 operations에 union()이나 find() 연산을 하는 부분의 시간 복잡도는 O(NlogN)이고,
마지막에 K번 find() 연산을 추가로 하므로 시간 복잡도는 O(KlogN)이다. 이를 종합하면 O(NlogN + KlogN)이지만 N이 K에 비해 상대적으로 크므로 O(NlogN)이라고 봐도 된다.