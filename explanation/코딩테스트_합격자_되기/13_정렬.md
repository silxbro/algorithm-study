# 13. 정렬

<br/>

---

## 1. 정렬 개념
**정렬**(sort)이란 사용자가 정의한 순서로 데이터를 나열하는 것을 말한다. 사용자가 정의한 순서는 오름차순이나 내림차순일 수도 있고 임의의 조건이 될 수도 있다.

### 🥎 정렬이 필요한 이유
정렬은 왜 필요할까? 데이터를 정렬하면 원하는 데이터를 쉽게 찾을 수 있다. 앞서 공부한 이진 탐색 트리가 그 예이다. 여기서 정렬이 필요한 이유를 한 번 더 확인해보기 위해 중앙값 찾기를 예로 들겠다.
다음 두 경우 중 어느 데이터에서 중앙값을 더 찾기 쉬울까?

<img src="https://github.com/user-attachments/assets/767f20c0-f052-457b-bf7e-538f9f5e5997" width="470"/><br/>

아마도 '오른쪽이 중앙값 찾기가 더 쉽다'라고 이야기할 것이다. 왜일까? 데이터를 정렬하지 않은 왼쪽에서 중앙값을 찾으려면 모든 데이터를 확인하고 비교해야 한다.
**반면 데이터를 정렬하면 데이터의 값을 보거나 비교할 필요 없이 말 그대로 데이터 전체 크기에서 중간의 값만 찾으면 그 값 자체가 중앙값이 된다.**
이처럼 정렬은 알고리즘의 효율을 크게 높여준다. 그러면 정렬 알고리즘을 하나씩 알아보자.

### 🥎 삽입 정렬
**삽입 정렬**(insertion sort)은 데이터의 전체 영역에서 정렬된 영역과 정렬되지 않은 영역을 나누고 정렬되지 않은 영역의 값을 정렬된 영역의 적절한 위치로 놓으며 정렬한다.
그림으로 표현하면 다음과 같다.
- 그림은 배열을 가정했다.

<img src="https://github.com/user-attachments/assets/b15a348b-c65a-4b3c-b9b7-0f6e538ce019" width="370"/><br/>

그림을 보면 정렬되지 않은 영역에서 맨 앞에 있는 데이터 9를 정렬된 영역의 적절한 위치로 넣으며 오름차순으로 정렬하고 있다.
정렬하지 않은 영역의 맨 앞에 있는 값을 키(key)라고 부르는데 잘 기억하기 바란다. 적절한 위치라는 표현이 애매한데 이것을 명확하게 정의하여 삽입 정렬을 설명하면 다음과 같다.
- (1) 최초에는 정렬된 영역은 왼쪽 1개, 정렬되지 않은 영역을 나머지로 한다.
- (2) 키와 정렬된 영역의 맨 끝값부터 거슬러 올라가며 다음 처리를 한다.
  - 키보다 크면 해당 값을 오른쪽으로 한 칸 밀어낸다.
  - 키보다 작거나 더 이상 비교할 값이 없으면 밀어낸 자리에 키를 넣는다.
- (3) 모든 데이터가 정렬된 영역이 될 때까지 2단계를 반복한다.

**[1단계]** 앞서 보여준 그림에서는 이 과정이 구체적으로 표현되지 않았으므로 몇 단계만 자세히 보겠다. 최초의 데이터는 무작위로 배치되어 있다.
여기서 왼쪽 1개와 나머지를 각각 정렬된 영역과 그렇지 않은 것으로 생각한다.

<img src="https://github.com/user-attachments/assets/f591211f-8cd8-471b-af77-3ad8c063be26" width="350"/><br/>

**[2단계]** 이제 정렬된 영역을 맨 끝 값부터 오른쪽에서 왼쪽 순서로 처리를 할 차례이다. 4와 11을 비교한다. (1) 11이 크므로 11을 오른쪽으로 밀어낸다.
그러면 더 이상 비교할 값이 없으므로 (2) 4를 11을 밀어낸 자리에 넣는다.

<img src="https://github.com/user-attachments/assets/b7be1173-b87a-4941-bd26-f3ee1bd14c8f" width="370"/><br/>

**[3단계]** 16도 해보자. 16은 다음 키이다. 16 위치에서 왼쪽 방향으로 이동하며 처리를 진행한다. 11은 16보다 작다. 더 밀어내거나 할 필요 없이 16을 그대로 둔다.

<img src="https://github.com/user-attachments/assets/43c18eae-94bd-4910-93c1-1ae4816cc970" width="350"/><br/>

**[4단계]** 1도 해보자. 1은 16보다 작으므로 (1) 16을 밀어낸다. (2) 11도 밀어낸다. (3) 4도 밀어낸다. (4) 더 비교할 값이 없으므로 밀어낸 자리에 1을 넣는다.

<img src="https://github.com/user-attachments/assets/16784197-295f-4963-9d5b-edee590a933f" width="370"/><br/>
<img src="https://github.com/user-attachments/assets/f96d6a8f-16e0-42d5-9021-2a54891ae54d" width="340"/><br/>

#### [삽입 정렬의 시간 복잡도]
삽입 정렬은 최악의 경우 O(N^2)이다. 최악의 경우란 처음부터 의도한 정렬과 완전히 반대로 정렬되어 있는 경우이다. 가장 최선의 경우는 O(N)으로 이미 정렬이 되어 있을 때이다.

### 🥎 병합 정렬
**병합 정렬**(merge sort)은 정렬되지 않은 영역을 쪼개서 각각의 영역을 정렬하고 이를 합치며 정렬한다.
- 이런 방식을 분할 정복(divide and conquer)이라고 한다.

병합 정렬도 그림으로 보자. 그림을 보면 정렬되지 않은 영역이 1칸이 될 때까지 반씩 쪼갠 후 다시 조합할 때 오름차순으로 정렬하며 합치고 있다.

<img src="https://github.com/user-attachments/assets/1cbbcddd-7d3a-456d-be53-7a16cb4b7c51" width="550"/><br/>

병합 정렬에서 핵심은 '병합할 때 부분 정렬하는 부분을 어떻게 구현해야 하는가?'이다. 사실은 그림에서 보는 것처럼 간단하지 않다.

- (1) 각 데이터의 첫 번째 원소를 가리키는 포인터를 만든다.
  - 포인터가 가리키는 두 값 중 작은 값을 선택해 새 저장 공간에 저장한다.
  - 값이 선택된 포인터는 다음 위치의 값을 가리킨다.
- (2) 새 저장 공간에 하나의 데이터가 완전히 저장될 때까지 과정 1을 반복한다.
  - 그러고 나서 저장할 값이 남은 데이터의 값을 순서대로 새로운 저장 공간에 저장한다.
  - 그러면 새로운 저장 공간에 두 개의 데이터가 정렬된 상태로 저장된다.
- (3) 새로운 저장소에 저장된 값의 개수와 초기에 주어진 데이터에 들어 있는 값의 개수가 같을 때까지 1, 2를 반복한다.

포인터라는 개념이 난해하게 느껴질 수 있는데, 포인터란 말 그대로 특정 배열의 원소를 가리키기 위한 화살표 같은 것이다. C 언어의 포인터가 아니므로 오해하지 말자.
화살표가 가리킨 것을 비교하여 새 저장 공간에 적절한 값을 넣는 식으로 진행하는 것이다. 글로만 보면 이해하기 어려울 수 있으므로 그림으로 설명해보겠다. 여기서는 합치는 과정 중 마지막 과정을 보여준다.

**[1단계]** 앞서 본 그림에서 합치는 과정의 마지막 단계는 1, 3, 5, 7과 2, 4, 6, 8을 합치는 것이었다. 포인터로 각 데이터의 맨 처음 원소인 1, 2를 가리킨다.

<img src="https://github.com/user-attachments/assets/6f8a77cf-067d-4c4e-8fea-0a158f97ce76" width="140"/><br/>

**[2단계]** 포인터가 가리키는 원소를 비교한다. 지금의 경우 오름차순으로 정렬하는 것이 목적이므로 (1) 1을 새 저장 공간에 저장하고, 새 저장 공간에 옮긴 (2) 포인터만 1에서 3으로 옮긴다.

<img src="https://github.com/user-attachments/assets/43884d33-e8e5-4ad1-9a5e-b770884a0c2d" width="450"/><br/>

**[3단계]** 다음은 2와 3의 비교이다. 2가 더 작으므로 (1) 2를 새 저장 공간에 저장하고 (2) 포인터를 2에서 4로 옮긴다. 이제 패턴이 보일 것이다.
이런 패턴으로 새 저장 공간에 데이터를 저장하면 자연스럽게 정렬이 완료된다.

<img src="https://github.com/user-attachments/assets/b34a76f5-088a-4df4-9662-27b96e94897d" width="450"/><br/>

**[4단계]** 다만 이렇게만 설명을 마무리하면 병합 정렬의 전체 과정을 오해하기 쉬우므로 조금만 더 설명하겠다.
병합 정렬은 한 번에 정렬을 완벽하게 하는 것이 아니라 매 단계에서 정렬을 부분 완료해가는 방식이다.
이를테면 앞서 본 그림의 1, 5 / 3, 7과 2, 6 / 4, 8도 같은 과정으로 부분 정렬을 진행하여 1, 3, 5, 7과 2, 4, 6, 8을 만든다. [3단계]에서는 그다음 과정을 본 것이다.

<img src="https://github.com/user-attachments/assets/77291ee5-7e78-4c54-8fb7-5e68cd1b6e44" width="550"/><br/>

#### [병합 정렬의 시간 복잡도]
병합 정렬의 성능은 결국 병합 횟수가 결정한다. **나누는 횟수는 logN, 이를 합치는 횟수 NlogN(N개를 병합하는 과정을 logN번 진행)이다.**
따라서 시간 복잡도는 O(NlogN)이다. 병합 정렬의 시간 복잡도는 분석 과정을 공부해두면 추후 면접에 도움이 될 수 있으므로 조금 자세히 설명하겠다.

**[1단계]** 그림의 높이 h는 몇 번 나눌지에 대한 값과 같다. 현재 그림의 높이는 3으로, 3번 나눈 것이므로 앞으로 3번 부분 정렬하여 합치는 과정이 있을 것임을 알 수 있다.

<img src="https://github.com/user-attachments/assets/cb874fa5-7a78-48a8-bba8-9ab4c0c3b669" width="550"/><br/>

**[2단계]** N개의 데이터를 1/2로 몇 번 나눠야 가장 작은 1칸이 될지 계산하는 식을 세워 정리하면 logN을 얻을 수 있다. 실제로 N = 8이므로 log8 = 3이다.
즉, 3번 나누고 이후 3번 정렬하며 합친다.

<img src="https://github.com/user-attachments/assets/8341d2ce-1937-4871-873f-72000ee253c4" width="170"/><br/>

**[3단계]** 정렬 과정에서 각 단계마다 N개의 데이터를 정렬하여 병합한다고 생각하면 NlogN으로 연산 횟수를 계산할 수 있다.

<img src="https://github.com/user-attachments/assets/1b292bac-8603-4665-9e15-fa5a85cc579f" width="570"/><br/>

### 🥎 힙 정렬
**힙 정렬**(heap sort)은 힙이라는 자료구조를 사용해 정렬한다. 따라서 힙 정렬은 힙 자료구조가 무엇인지 먼저 알아야 한다. 힙 정렬을 하기 위해서는 먼저 주어진 데이터로 힙을 구축해야 한다.
정렬되지 않은 데이터로 어떻게 힙을 구축하는지 알아보고, 이후 힙을 활용해서 정렬하는 방법을 알아보자.
- 이후 힙 자료구조는 힙이라고 부르겠다.

#### [힙이란?]
힙은 특정 규칙이 있는 이진 트리이다. 그리고 규칙에 따라 최대힙, 최소힙으로 나눈다.
**최대힙은 부모 노드가 자식 노드보다 크고, 최소힙은 부모 노드가 자식 노드보다 작다.** 아주 단순한 규칙이므로 다음 그림을 보면 최대힙과 최소힙이 무엇인지 감을 잡을 수 있을 것이다.

<img src="https://github.com/user-attachments/assets/d3f21684-2114-4eb4-b9ae-848d913a196d" width="600"/><br/>

왼쪽의 최대힙을 보면 부모 노드는 항상 자식보다 크다. 반대로 오른쪽의 최소힙은 부모 노드가 항상 자식보다 작다.

#### [힙 구축 방법: 최대힙 편]
여기서는 최대힙을 구축하는 방법을 기준으로 설명한다. 최대힙과 최소힙은 힙을 구성하는 규칙만 다르고 나머지는 모두 동일하다.
보통 힙 구축을 설명할 때는 이진 트리 그림을 놓고 설명하는 경우가 많지만 여기서는 무작위 배열이 있다고 가정하고 최대힙을 구축하는 방법을 이진 트리 그림과 함께 알아본다.
힙을 구축하는 규칙을 설명하기 전에 최대힙 구축에서 활용하는 max_heapify()라는 함수 연산에 대해 알아보겠다.
max_heapify() 함수는 특정 노드가 최대힙의 규칙을 만족하지 못하면 힙을 구축하는 과정을 아래로 내려가면서 반복하는 동작이다. 규칙은 다음과 같다.

- (1) 현재 노드와 자식 노드의 값을 비교한다.
  - 현재 노드의 값이 가장 크지 않으면 자식 노드 중 가장 큰 값과 현재 노드의 값을 바꾼다.
  - 만약 자식 노드가 없거나 현재 노드의 값이 가장 크면 연산을 종료한다.
- (2) 맞바꾼 자식 노드의 위치를 현재 노드로 하여 과정 1을 반복한다.

<img src="https://github.com/user-attachments/assets/8d4acf9c-70f1-488a-be1a-d4bbd4da26d2" width="600"/><br/>

현재 노드의 자식 노드는 8, 4이다. 둘 중 현재 노드보다 큰 노드가 있는지 확인한다. 8이 크므로 7과 8을 바꾼다. 그다음에는 자식 노드를 현재 노드로(다시 7) 생각하여 다음 연산을 진행한다.

<img src="https://github.com/user-attachments/assets/ed7ef8f3-8756-4a23-a831-9f7dcd0a689a" width="600"/><br/>

**[1단계]** 초기 상태는 다음과 같다. 최대힙은 부모 노드가 항상 자식보다 커야 하므로 지금은 최대힙 조건에 맞지 않다. 배열과 이진 트리의 노드 위치를 눈으로 잘 맞춰보기 바란다.

<img src="https://github.com/user-attachments/assets/a05b7eaf-3c5d-4980-bd59-6baf91a81473" width="450"/><br/>

**[2단계]** 배열의 마지막 원소(노드)부터 힙 구축을 시작한다. max_heapify(5)를 수행하지만 비교할 자식 노드가 없으므로 아무 동작도 하지 않는다.
- max_heapify() 함수는 배열의 인덱스로 동작한다. 노드의 값을 부르는 표현과 헷갈리지 않도록 주의하자.

<img src="https://github.com/user-attachments/assets/2d0c9bb9-63bb-472a-883d-a92e2b3ef74b" width="450"/><br/>

**[3단계]** 현재 노드를 4번 노드로 생각하여 max_heapify(4)를 수행한다.
(1) 역시 자식 노드가 없으므로 아무 동작도 하지 않고 (2) 현재 노드를 다음 3번 노드로 옮기고 max_heapify(3)을 수행한다. 그러나 3번 노드도 비교 대상이 없다. (3) 2번 노드로 옮겨간다.

<img src="https://github.com/user-attachments/assets/e48edfd6-0085-401d-b807-9b63e3957142" width="480"/><br/>

**[4단계]** 2번 노드는 자식 노드가 있다. max_heapify(2)를 수행하면 2와 3중 3이 크므로 (1) 이 둘을 바꾼다. 그런 다음 현재 노드의 위치를 값을 바꾼 5번째 노드로 가서 자식 노드를 확인해본다.
(2) 자식 노드가 없으므로 최대힙을 만족한다고 생각한다.

<img src="https://github.com/user-attachments/assets/a9066ccc-b94d-4cc6-9582-9ec221be25cf" width="230"/><br/>

**[5단계]** 마지막으로 루트 노드를 현재 노드로 생각하여 max_heapify(1)을 수행한다. (1) 노드 5가 가장 크므로 4와 바꾸고 현재 노드를 다시 3번 노드로 한다.
(2) max_heapify(3)을 호출하여 연산을 진행한다. 자식 노드가 없으므로 연산을 종료한다.
자식 노드 중 자신보다 큰 노드 중 가장 큰 노드와 교체한 다음 (3) 현재 노드를 교체한 위치로 옮겨서 또 자식 노드를 본다. 자식 노드가 없으므로 연산은 종료한다.

<img src="https://github.com/user-attachments/assets/6ddebdfc-318c-4c79-88f8-5c5397d969a4" width="480"/><br/>

#### [사실 힙 구축은 N이 아니라 N/2부터 시작해도 괜찮다]
힙을 구축할 때는 자식 노드가 없으면 아무런 동작도 하지 않으므로 N부터 힙 구축을 시작하지 않아도 된다. 현재 노드 인덱스가 N/2를 넘으면 자식 노드 인덱스가 N을 넘는다.
힙의 크기는 N이므로 실제 노드의 인덱스가 N 이상 넘어가는 일은 없으므로 고려하지 않아도 된다.

<img src="https://github.com/user-attachments/assets/5152bc17-0432-4518-9d5a-782eb2c83ed1" width="380"/><br/>

#### [힙 정렬 과정: 최대힙 편]
최대힙에서 힙 정렬은 루트 노드가 가장 큰 값이므로 루트 노드의 값을 빼서 저장하기만 하면 된다. 다만 루트 노드의 값을 뺀 이후 최대힙을 유지하는 것이 중요한데 이 과정을 알아야 한다.
루트 노드가 없는 채로 트리를 유지할 수는 없기 때문이다.
루트 노드가 빠진 다음에도 나머지 원소들이 최대힙을 유지할 수 있다면 우리는 힙에서 원소가 큰 순서대로 값을 가져올 수 있게 되므로 내림차순 정렬을 쉽게 할 수 있게 될 것이다.
힙 정렬하는 과정을 나타내면 다음과 같다.
- (1) 정렬되지 않은 데이터로 최대힙을 구축한다.
- (2) 현재 최대힙의 루트 노드와 마지막 노드를 맞바꾼다. 맞바꾼 뒤 마지막 노드는 최대힙에서 제외한다.
- (3) 현재 최대힙은 마지막 노드가 루트 노드가 되었다. 따라서 최대힙을 다시 구축해야 한다. max_heapify(1)을 진행하여 최대힙을 구축하고 과정 2를 수행한다.
  이 과정은 최대 힙의 크기가 1이 될 때까지 반복한다.

**[1단계]** (1) 루트 노드와 마지막 노드의 위치를 바꾼다. (2) 그런 다음 힙의 크기를 5에서 4로 줄이고 5는 정렬 완료한 것으로 관리한다.
(3) 그런 다음 최대힙을 만족하도록 max_heapify(1)을 진행한다.

<img src="https://github.com/user-attachments/assets/4c390325-3472-468b-ae63-4de174d86a35" width="550"/><br/>

**[2단계]** 앞서 이야기한 최대힙 구축 방법대로 (1) 다시 최대힙을 만든다. 구체적인 설명은 앞에서 했으므로 자세히 이야기하지 않겠다.
최대힙을 다시 만들었다면 (2) 루트 노드를 또 마지막 노드와 교체하고 최대힙에서 제외한다. (3) 그리고 다시 max_heapify(1)을 진행한다.

<img src="https://github.com/user-attachments/assets/bff8687f-1b98-4f1c-be15-4857d8c5de5c" width="550"/><br/>

**[3단계]** 계속해서 힙 정렬을 진행한다. 루트 노드와 마지막 노드 위치를 교체하고 힙에서 제외한 다음 max_heapify(1)을 수행한다. 마지막 노드까지 정렬된 것으로 처리하면 힙 정렬은 끝난다.

<img src="https://github.com/user-attachments/assets/85514376-200c-4c50-a291-c5b77c111d49" width="550"/><br/>

#### [힙 정렬의 시간 복잡도]
힙 정렬의 시간 복잡도를 확인하겠다. 정렬되지 않은 값 N개를 힙으로 나타내면 높이가 logN인 트리가 된다. 데이터는 N개이므로 각 데이터에 대해 힙 정렬을 수행하면 시간 복잡도는 O(N*logN)이다.

### 🥎 우선순위 큐
우선순위 큐는 우선순위가 높은 데이터부터 먼저 처리하는 큐이다. 쉽게 말해 큐는 큐인데 우선순위에 따라 poll을 하는 큐이다.
예를 들어 데이터의 값이 작을수록 우선순위가 높을 때의 우선순위 큐는 3, 1 순서로 데이터를 add하면 poll은 1, 3 순서로 한다.
우선순위 큐의 내부 동작은 힙과 매우 유사하므로 우선순위 큐를 구현할 때는 힙을 활용하는 것이 효율적이다. 여기를 다 공부하면 우선순위 큐 자체가 정렬과 연관이 있음을 알게 될 것이다.

#### [우선순위 큐가 동작하는 방식]
우선은 우선순위 큐가 동작하는 방식을 자세히 알아보자. 여기서 설명하는 우선순위 큐의 우선순위 기준은 작은 값일수록 우선순위가 높다라고 가정한다.

**[1단계]** 빈 우선순위 큐를 하나 선언한다. 형태는 큐와 같다.

<img src="https://github.com/user-attachments/assets/55d84eda-356f-49a1-9321-b2205da423d6" width="170"/><br/>

**[2단계]** 3을 삽입한다. 빈 큐이므로 별다른 우선순위를 생각하지 않고 맨 앞에 add한다.

<img src="https://github.com/user-attachments/assets/1959c97b-b641-43ad-9e2d-54c304bc4872" width="200"/><br/>

**[3단계]** 이어서 1을 삽입한다. 1은 3보다 작으므로 우선순위가 높다. 따라서 1을 3 앞으로 삽입한다. 이렇게 하면 3보다 1이 먼저 poll된다.

<img src="https://github.com/user-attachments/assets/384f7160-0f6c-45de-b3cd-21b1b76d3dbd" width="200"/><br/>

**[4단계]** poll하는 과정이다. 앞서 언급했듯이 3 앞에 1을 삽입했으므로 poll하면 1이 나온다.

<img src="https://github.com/user-attachments/assets/bf31a681-608e-411c-bdea-6af27908121a" width="220"/><br/>

우선순위 큐가 동작하는 방식은 매우 간단해서 쉽게 이해할 수 있을 것이다. 그리고 우선순위에 따라 데이터를 poll할 수 있으므로 정렬과 깊은 연관이 있다는 것도 알았을 것이다.
예를 들어 입력받은 자연수를 오름차순으로 정렬하고 싶다면 방금 살펴본 '작은 값일수록 우선순위가 높은 우선순위 큐'에 마구 자연수를 집어넣고 poll하면 원하는 정렬 결과를 얻을 수 있을 것이다.

**그러면 '우선순위 큐를 구현할 때 큐에 데이터를 add할 때마다 어떤 정렬 알고리즘을 사용하던 아무 정렬 알고리즘이나 쓰면 되는 거 아니야?라는 의문이 들 수 있다.**
하지만 효율을 생각하면 우선순위 큐는 힙으로 구현하는 것이 가장 좋다. 왜 그런지 알아보자.

#### [힙으로 우선순위 큐를 구현해야 하는 이유]
우선순위 큐의 핵심 동작은 우선순위가 높은 데이터를 먼저 poll하는 것이다. 이를 위해 앞서 언급했던 것처럼 데이터를 add할 때마다 아무 정렬 알고리즘이나 사용해서 데이터를 우선순위에 맞게 정렬해도 된다.
하지만 가만히 생각해보면 최소힙이나 최대힙은 특정 값을 루트 노드에 유지하는 특징이 있고, 이는 우선순위 큐의 핵심 동작과 맞아 떨어지므로 힙을 활용하면 우선순위 큐를 효율적으로 구현할 수 있다는 것을 알 수 있다.
게다가 자바는 힙을 PriorityQueue 클래스로 제공한다. 이를 활용하면 쉽게 우선순위 큐를 구현할 수 있다.
- PriorityQueue 클래스는 자바에서 제공하는 우선순위 큐 자료구조를 위한 표준 라이브러리이다.

#### (1) PriorityQueue로 우선순위 큐 구현하기
다음 코드를 보면 PriorityQueue를 임포트하여 add() 메서드를 이용해서 10, 5, 20, 1 순서로 데이터를 add한다.
PriorityQueue 클래스는 최소힙으로 동작하므로 결괏값은 [1, 5, 10, 20]이다.

```java
import java.util.PriorityQueue;

public class Solution {
  public static void main(String[] args) {
    // 빈 PriorityQueue 생성
    PriorityQueue<Integer> pq = new PriorityQueue<>();

    // 값을 우선순위 큐에 삽입 (add 사용)
    pq.add(10);
    pq.add(5);
    pq.add(20);
    pq.add(1);

    // 현재 우선순위 큐의 상태 출력
    System.out.println(pq);  // [1, 5, 10, 20]

    // 우선순위에서 가장 작은 요소 확인 및 제거 (poll 사용)
    System.out.println(pq.poll());  // 1
    System.out.println(pq);  // [5, 10, 20]
    System.out.println(pq.poll());  // 5
    System.out.println(pq);  // [10, 20]
  }
}
```
데이터 자체에 우선순위를 직접 정하고 싶다면 PriorityQueue 객체를 생성할 때 매개변수로 Comparator 객체를 생성하여 넘기면 된다. 예를 들어
```java
PriorityQueue<String> pq = new PriorityQueue<>(Comparator.comparingInt(o -> o.charAt(1)));
```
와 같이 코드를 작성하면 이 우선순위 큐는 add한 문자열의 두 번째 문자를 기준으로 오름차순 정렬하여 poll한다. 이 방식은 직접 구현해보기 바란다.

#### (2) 값이 클수록 우선순위가 높게 하려면?
지금까지는 값이 작을수록 우선순위가 높은 우선순위 큐를 보았다. 가끔 문제에서 값이 클수록 우선순위가 높은 우선순위 큐를 써야 할 수도 있다.
그런 경우 PriorityQueue 객체를 생성할 때 Collections.reverseOrder()를 매개변수로 넘기면 된다.
```java
// 우선순위 큐를 내림차순으로 정렬하도록 생성
PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
pq.add(10);
pq.add(5);
pq.add(20);
pq.add(1);

System.out.println(pq.poll());  // 20
        System.out.println(pq.poll());  // 10
        System.out.println(pq.poll());  // 5
        System.out.println(pq.poll());  // 1
```

#### (3) 값을 한꺼번에 우선순위 큐에 넣으려면?
앞서 배운 방식은 데이터를 우선순위 큐에 하나씩 추가할 때를 가정한 것이다. 만약 데이터가 여러 개 있으면 PriorityQueue 객체를 생성할 때 매개변수로 넘기거나 addAll() 메서드를 활요할 수도 있다.
다음은 두 가지 방법에 대한 활용 예이다.
```java
ArrayList<Integer> list = new ArrayList<>();
list.add(10);
list.add(5);
list.add(20);
list.add(1);

// 컬렉션의 모든 데이터를 우선순위 큐에 담아 생성
PriorityQueue<Integer> pq = new PriorityQueue<>(list);

System.out.println(pq.poll());  // 1
System.out.println(pq.poll());  // 5

System.out.println(pq);  // [10, 20]

// 컬렉션의 모든 데이터를 우선순위 큐에 추가
pq.addAll(list);

System.out.println(pq);  // [1, 10, 5, 20, 20, 10] ---> 우선순위 큐는 꺼내면서 정렬하므로 pq는 정렬된 상태가 아님
```

#### [우선순위 큐의 시간 복잡도]
힙 정렬의 삽입/삭제 연산의 효율과 완전히 동일하다. 원소의 개수가 N이라고 할 때 시간 복잡도는 addAll()는 O(NlogN)이고, add()/poll() 메서드 둘 다 O(logN)이다.

#### [우선순위 큐가 활용되는 분야]
우선순위 큐는 데이터의 중요성 혹은 우선순위에 따라 처리해야 하는 경우 많이 활용된다. 몇 가지 예를 들면 다음과 같다.
- **작업 스케줄링** : 운영체제에서 프로세스나 스레드의 실행 순서를 결정할 때 우선순위 큐를 활용해서 중요한 작업을 먼저 처리한다.
- **응급실 대기열** : 환자의 진료 우선순위를 결정하고, 중증의 환자를 먼저 치료한다.
- **네트워크 트래픽 제어** : 패킷 스케줄링 및 트래픽 관리에서 중요하거나 긴급한 패킷을 먼저 처리한다.
- **교통 네트워크 최적화** : 교통 체계를 분석하고 최적화하기 위한 최단 경로 알고리즘을 구현하기 위해 활용된다.

### 🥎 계수 정렬
**계수 정렬**(counting sort)은 데이터에 의존하는 정렬 방식이다. 지금까지 배운 정렬들은 사용자가 정렬한 기준에 따라 정렬했다.
반면 계수 정렬은 데이터의 빈도수로 정렬한다. 그림과 함께 계수 정렬이 무엇인지 알아보자. 다음 그림은 왼쪽의 배열에서 데이터의 빈도수를 세어 빈도수 배열에 저장한 것이다.

<img src="https://github.com/user-attachments/assets/084f8e4a-2221-4aa5-99ca-ec0ccd615861" width="430"/><br/>

그림에서 보듯 1이 2개이므로 빈도수[1] = 2이다. 나머지도 마찬가지로 빈도수를 채운다. 이렇게 빈도수를 다 채운 다음에는 우선순위가 높은 데이터부터 빈도수만큼 출력하는 것이 계수 정렬이다.
이를테면 빈도수 배열에서 인덱스 오름차순으로 각 인덱스를 빈도수만큼 출력하면 자연스럽게 오름차순으로 정렬한 배열이 나올 것이다.

<img src="https://github.com/user-attachments/assets/a7abfd6b-ed6e-47d5-8f9e-a391305f7683" width="440"/><br/>

이와 같이 계수 정렬은 콘셉트를 이해한다면 더 자세히 설명할 필요가 없을 정도로 자연스러운 정렬이다. 다만 계수 정렬은 명확한 한계가 있다.

#### [계수 정렬의 한계]
계수 정렬의 핵심 동작은 앞서 본 것처럼 빈도수를 세어 빈도수 배열에 저장하는 것이다. 그래서 빈도수 배열에 저장할 값의 범위가 듬성듬성 있거나, 음수가 있으면 계수 정렬을 하기 매우 곤란해진다.
이를테면 다음과 같이 -150, 500, 10억과 같은 값의 빈도수를 측정하여 빈도수 배열에 저장하는 건 비효율적이다.
(1) -150이라는 값은 음수이므로 배열의 인덱스로 표현할 수 없고 (2) -150과 500 사이의 공간 낭비도 그렇고 (3) 크기가 10억 이상인 배열을 만드는 것은 환경에 따라 어려울 수도 있다.
물론 다음 그림에서 가장 작은 값인 -150을 찾아서 전부 150을 더하면 계수 정렬을 활용할 수도 있겠지만 그만큼 추가 연산이 필요하기 때문에 다른 정렬을 고민해보는 것이 좋을 것이다.

<img src="https://github.com/user-attachments/assets/5a885160-f9e8-4af6-acf0-31603e2cc10c" width="500"/><br/>

#### [계수 정렬의 시간 복잡도]
값이 N개인 데이터에 대해서 계수 정렬을 한다고 가정해보자. 데이터를 세는 과정은 전체 데이터를 한 번씩 체크하면 되므로 N번 탐색한다고 생각할 수 있다.
값의 최솟값 ~ 최댓값 범위 크기가 K라면 빈도수 배열에서 K + 1만큼 탐색해야 하므로 계수 정렬의 시간 복잡도는 O(N + K)라고 생각할 수 있다.

### 🥎 위상 정렬
위상 정렬(topological sort)은 지금까지 배운 정렬 알고리즘과는 성격이 조금 다른 정렬이다. 일반적인 오름차순 정렬이나 내림차순 정렬이 아닌 특별한 그래프에서 방문 순서를 결정하는 알고리즘이다.
작업의 순서를 결정한다고 생각하면 쉽게 이해할 수 있다. 우리가 하는 일에는 대부분 순서가 있다. 예를 들어 수육을 만들어 상을 차리는 과정을 나타내면 다음과 같다.

<img src="https://github.com/user-attachments/assets/940dcfa8-a450-4915-8c46-4e0b2d27db92" width="520"/><br/>

그림을 보면 냄비에 물을 채우고 가열하면서 동시에 고기를 손질해야 한다. 이렇게 위상 정렬은 일의 순서가 중요하므로 반드시 간선의 방향이 있어야 한다.
만약 그래프에 순환이 있고 간선의 방향이 없으면 일의 방향이 없는 것이므로 방향 비순환 그래프(DAG[directed acyclic graph])에서만 사용할 수 있다.

#### [위상 정렬과 진입차수]
위상 정렬은 자신을 향한 화살표 개수를 진입차수로 정의하여 진행한다. 앞서 본 그래프에 진입차수를 표현하면 다음과 같다.

<img src="https://github.com/user-attachments/assets/795a7b0f-ee60-443d-a786-b882673c9954" width="530"/><br/>

진입차수는 자신을 향한 화살표의 개수이다. 만약 진입차수가 0이라고 하면 자신을 향한 화살표가 없다는 뜻이다. 그 말은 '선행 작업이 필요 없는, 바로 할 수 있는 일'이라는 것과 같다.
이 개념을 머릿속에 넣어두고 위상 정렬 진행 과정을 따라가보자.

#### [위상 정렬 과정]
위상 정렬은 기본적으로 바로 진행할 수 있는 일, 다시 말해 진입차수가 0인 일을 해결하고 관련된 작업의 진입차수를 1씩 낮추면서 새롭게 진입차수가 0이 된 작업들을 해결하는 식으로 진행한다.
이 **해결**이라는 행위는 큐를 활용하여 구현한다. 진입차수가 0인 작업을 일단 전부 큐에 넣고 하나씩 poll하면서 해당 작업과 연결되어 있는 작업들의 진입차수를 줄인다.
그러면서 진입차수가 0이 된 작업을 큐에 넣는다. 실제 정렬하는 과정을 살펴보겠다.

**[1단계]** 위상 정렬을 진행할 그래프는 다음과 같다. 앞서 설명한 대로 진입차수를 노드에 써두었다. 예를 들어 노드 E의 진입차수는 들어오는 화살표가 2개이므로 2이다.

<img src="https://github.com/user-attachments/assets/5e193677-d90e-44b1-95d3-e5c57b4df044" width="350"/><br/>

**[2단계]** 진입차수가 0인 노드 A, B, C를 큐에 add한다. 그런 다음 poll을 하면서 인접한 노드의 진입차수를 -1한다.
예를 들어 (1) A를 poll한 다음에는 A의 인접 노드인 (2)D의 진입차수를 -1한다. (2) B와 C도 마찬가지로 poll하며 B는 G의 진입차수를, C는 E의 진입차수를 -1한다.

<img src="https://github.com/user-attachments/assets/53b1cc2a-e996-4327-8c9c-4244927e7328" width="500"/><br/>

**[3단계]** 다음은 진입차수가 0인 D를 add할 차례이다. add 후 poll하며 작업을 완료하고 인접 노드 E의 진입차수를 -1한다.

<img src="https://github.com/user-attachments/assets/bdb36ad8-ec86-431f-b244-900333e34fa9" width="450"/><br/>

**[4단계]** 이런 방식으로 poll한 순서를 늘어놓으면 위상 정렬이 끝난다.

<img src="https://github.com/user-attachments/assets/0fdcd1f0-e361-42b2-8ca1-761cf6411bd1" width="350"/><br/>

#### [위상 정렬의 시간 복잡도]
위상 정렬은 모든 정점과 간선을 딱 한 번씩만 지나가므로 시간 복잡도는 O(|V| + |E|)가 된다.

### ✅ 정렬 알고리즘의 시간 복잡도
끝으로 정렬 알고리즘의 효율을 표로 정리하고 넘어가겠다. 가끔 면접에서 정렬 알고리즘의 시간 복잡도를 묻는 경우가 있으므로 기억해두면 유용할 것이다.

|정렬 방법|최악의 경우|최선의 경우|특이점|
|:---|:---|:---|:---|
|삽입 정렬|O(N^2)|O(N)|데이터가 거의 정렬되어 있을 때는 최고의 성능을 발휘한다.|
|병합 정렬|O(NlogN)|O(NlogN)|인정적인 성능으로 정렬할 수 있다.<br/>병합 과정에서 추가적인 메모리가 필요하다.|
|힙 정렬|O(NlogN)|O(NlogN)|안정적인 성능으로 정렬할 수 있다.<br/>데이터를 삽입과 동시에 빠르게 정렬할 수 있다.|
|계수 정렬|O(N + K)|O(N + K)|데이터에 의존적이므로 항상 사용 가능한 것은 아니다.|
|위상 정렬|O(V + E)|O(V + E)|작업의 순서가 존재할 때 사용되는 알고리즘이다.|
- N은 원소의 길이, K는 원솟값의 범위, V는 정점, E는 간선의 개수이다.

#### [정렬의 최대 성능과 한계, 하한]
알고리즘에서 하한(lower bound)이란 알고리즘이 도달할 수 있는 최대 성능 또는 한계를 말한다. 즉, 해당 알고리즘을 계속 연구해서 성능을 개선한다고 해도 알고리즘의 하한보다 성능이 좋아질 수는 없다.
정렬은 크게 **비교 정렬**(comparison sort)과 **비비교 정렬**(non-comparison sort)로 분류할 수 있다. 비교 정렬은 원소 간의 대소 관계 값을 비교하며 진행하는 정렬이다.
따라서 데이터에 의존하지 않고 정렬할 수 있다. 앞에서 배운 삽입 정렬, 병합 정렬, 힙 정렬이 비교 정렬에 해당한다. 이러한 비교 기반의 정렬 알고리즘의 성능 하한은 O(NlogN)이 된다.
비비교 정렬이란 데이터에 의존하는 정렬을 말한다. 앞서 계수 정렬이 그러했다. 계수 정렬은 데이터에 의존하므로 적용 범위가 제한되었다.
그래서 비비교 정렬은 데이터 자체에 의존하는 정렬 방식이기 때문에 연산 횟수를 정확하게 측정할 수 없다. 따라서 하한 자체가 의미없다.

<br/>

## 2. 몸풀기 문제
### [문제 50] 계수 정렬 구현하기
- 권장 시간 복잡도 : O(N)

> 인자로 받은 문자열 s를 계수 정렬로 정렬하여 반환하는 solution() 함수를 구현하세요.

#### [제약 조건]
- strings의 길이는 1 이상 10,000 이하이다.
- s는 알파벳 소문자로 이루어져 있다.

#### [입출력의 예]
|s|return|
|:---:|:---:|
|"hello"|"ehllo"|
|"algorithm"|"aghilmort"|

#### [문제 분석하고 풀기]
문자열 "hello"를 계수 정렬을 사용하여 정렬하려면 알파벳 소문자 개수 26만큼 빈도수 배열을 생성해야 한다. 그런 다음 문자열 "hello"의 각 문자의 빈도수를 저장하면 된다.
문자열의 각 문자를 아스키코다값으로 매핑하면 쉽게 할 수 있다. 이처럼 계수 정렬은 문자를 정렬할 때 매우 효율적인 알고리즘이다.
앞으로 문자 관련 정렬이 필요한 경우 계수 정렬을 활용해보기 바란다. 이제 코드를 작성해보자.

```java
class Solution {
  private static String solution(String s) {
    int[] counts = new int[26];  // (1) 알파벳 개수(26개)만큼 빈도수 배열 생성

    // (2) 문자열의 각 문자에 대한 빈도수를 count 배열에 저장
    for (char c : s.toCharArray()) {
      counts[c - 'a']++;
    }

    // (3) 빈도수 배열을 순회하면서 정렬된 문자열을 생성
    StringBuilder sortedStr = new StringBuilder();
    for (int i = 0; i < 26; i++) {
      for (int j = 0; j < counts[i]; j++) {
        sortedStr.append((char)(i + 'a'));
      }
    }

    return sortedStr.toString();
  }
}
```
- (1) 알파벳은 총 26글자이므로 빈도수를 측정하기 위해 크기가 26인 배열을 만든다.
- (2) 문자열을 순회하면서 각 문자에 대한 빈도수를 계산하여 빈도수 배열에 저장한다.
  각 문자는 아스키코드값으로 변환되는데, 이 아스키코드값에서 'a'의 아스키코드값을 빼면 배열의 0번째부터 문자의 빈도수를 저장할 수 있다. 문자열의 각 문자를 순회하면서 해당 문자를 센다.
- (3) 빈도수 계산이 끝나면 빈도수 배열을 순회하며 sortedStr에 정렬된 문자순으로 문자들을 추가한다. 반복문을 보면 인덱스가 0부터 25까지 수행되고 있다.
  문자열을 추가할 때는 0 ~ 25의 숫자가 아닌 'a' ~ 'z'가 추가되어야 하므로 인덱스에 'a'의 아스키코드값을 더해 sortedStr에 추가한다.
  여기서 StringBuilder 객체를 생성해서 append() 메서드로 문자열을 만들고 있음에 주목하자.
  자바에서 String 객체는 불변 객체이므로 + 연산으로 문자열을 만들면 시간 복잡도가 O(N^2)이 되어 성능이 좋지 않다. StringBuilder를 사용하면 O(N)의 시간 복잡도로 결과 문자열을 만들 수 있다.

  <img src="https://github.com/user-attachments/assets/a6091e80-ef7d-4f1b-9bc4-468b442642ba" width="350"/><br/>
  - 'a'의 아스키코드값은 97이므로 그대로 빈도수 배열에 저장하려면 97번째부터 빈도수를 저장해야 한다. 하지만 'a'를 일괄로 빼면 인덱스 0부터 빈도수를 저장할 수 있다.

#### [시간 복잡도 분석하기]
N은 S의 길이이다. count 배열을 초기화할 때의 시간 복잡도는 O(26)이고, 이후 문자열을 순회하면서 빈도수 배열을 만드는 시간 복잡도는 O(N)이다.
빈도수 배열을 순회하면서 정렬하기 위한 시간 복잡도는 O(26 + N)이다. 따라서 최종 시간 복잡도는 O(N)이다.

### [문제 51] 정렬이 완료된 두 배열 합치기
- 권장 시간 복잡도 : O(N+M)

> 이미 정렬이 완료되어 있는 두 배열 arr1, arr2를 받아 병합 정렬하는 solution() 함수를 구현하세요.

#### [제약 조건]
- arr1과 arr2는 각각 길이가 1 이상 100,000 이하이다.
- arr1과 arr2는 각각 오름차순으로 정렬되어 있다.

#### [입출력의 예]
|arr1|arr2|return|
|:---:|:---:|:---:|
|[1, 3, 5]|[2, 4, 6]|[1, 2, 3, 4, 5, 6]|
|[1, 2, 3]|[4, 5, 6]|[1, 2, 3, 4, 5, 6]|

#### [문제 분석하고 풀기]
두 배열이 이미 정렬되어 있으므로 정렬 순서를 지키며 합치기만 하면 된다. 병합 정렬은 앞서 자세히 설명했으므로 바로 코드를 작성해보자.
```java
class Solution {
  private static int[] solution(int[[] arr1, int[] arr2) {
    // 정렬된 배열을 저장할 배열 생성
    int[] merged = new int[arr1.length + arr2.length];
    int k = 0, i = 0, j = 0; // 3개 배열의 인덱스 초기화

    // 두 배열을 순회하면서 정렬된 배열을 생성
    while (i < arr1.length && j < arr2.length) {
      merged[k++] = arr1[i] <= arr2[j] ? arr1[i++] : arr2[j++];
    }

    // arr1이나 arr2 중 남아 있는 원소들을 정렬된 배열 뒤에 추가
    while (i < arr1.length) {
      merged[k++] = arr1[i++];
    }

    while (j < arr2.length) {
      merged[k++] = arr2[j++];
    }

    return merged;
  }
}
```
빈 배열 merged를 생성ㅇ한 다음 각각의 인덱스를 0으로 초기화한다. 두 배열을 순회하면서 정렬된 배열을 생성한다. 두 배열의 원소를 하나씩 비교하여 작은 값을 merged에 추가한다.
이때 작은 값이 추가된 배열의 인덱스를 1 증가시킨다. 이 과정을 두 배열 중 하나의 인덱스가 끝에 도달할 때까지 반복한다. arr1이나 arr2 중 아직 정렬이 끝나지 않은 원소는 merged 배열 뒤에 추가한다.

#### [시간 복잡도 분석하기]
N은 arr1의 길이, M은 arr2의 길이이다. 이 배열들을 합치면서 모든 원소를 한 번씩 순회하므로 최종 시간 복잡도는 O(N + M)이다.