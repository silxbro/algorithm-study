# 08. 해시

<br/>

---

## 1. 해시의 개념
어떤 데이터를 찾는다고 했을 때 쉽게 떠올려볼 수 있는 방법은 처음부터 끝까지 순차 탐색하는 방법이다. 이 방법을 사용하면 가장 확실하게 원하는 데이터를 찾을 수 있다.
하지만 최악의 경우 탐색을 할 때마다 모든 데이터를 살펴봐야 할 수 있으므로 효율적이지 않다. 이 방법을 개선하려면 찾아야 할 값이 어디에 있는지 알아낼 방법이 필요하다.
즉, 어떠한 값이 저장되는 위치를 어떤 규칙으로 정할 수 있다면 굳이 탐색을 할 필요 없이 바로 데이터를 찾아낼 수 있을 것이다. 이런 생각을 바탕으로 만든 자료구조가 해시(hash)이다.
**해시는 해시 함수를 사용해서 변환한 값을 인덱스로 삼아 키와 값을 저장해서 빠른 데이터 탐색을 제공하는 자료구조이다. 어떻게 탐색을 빠르게 만들까?
보통은 인덱스를 활용해서 탐색을 빠르게 만들지만 해시는 키(key)를 활용해 데이터 탐색을 빠르게 한다.**
- 해시는 키와 데이터를 일대일 대응하여 저장하므로 키를 통해 데이터에 바로 접근할 수 있다. 사람에게는 숫자(인덱스)로 데이터를 관리하는 배열보다 조금 더 접근성이 좋은 자료구조라 할 수 있다.

### 🥎 해시 자세히 알아보기
사실 우리 생활에도 해시를 많이 활용한다. 가장 쉽게 볼 수 있는 해시의 예는 연락처이다. 연락처는 다음과 같은 그림으로 그려볼 수 있다.

<img src="https://github.com/user-attachments/assets/a3cd999e-601f-4ef6-94f6-b67e02638b3d" width="400"><br/>

그림을 보면 내가 최종으로 얻고자 하는 정보, 즉, 전화번호는 값(value)이고, 값을 검색하기 위해 활용하는 정보는 키(key)이다. 그리고 그 사이에 키를 이용해 해시값 또는 인덱스로 변환하는 해시 함수가 있다.
해시 함수는 이렇게 키를 일정한 해시값으로 변환시켜 값을 찾을 수 있게 해준다. 해시 함수는 설명할 내용이 많으므로 우선 해시가 이런 식으로 동작한다는 컨셉만 머리속에 넣어두고 큰 범위에서 동작만 살펴보자.

#### [해시의 특징]
첫 번째, 해시는 단방향으로 동작한다. 즉, 키를 통해 값을 찾을 수 있지만 값을 통해 키를 찾을 수는 없다. 두 번째, 찾고자 하는 값을 O(1)에서 바로 찾을 수 있다.
**키 자체가 해시 함수에 의해 값이 있는 인덱스가 되므로 값을 찾기 위한 탐색 과정이 필요 없다.** 세 번째, 값을 인덱스로 활용하려면 적절한 변환 과정을 거쳐야 한다.
- 단방향으로만 동작하는 해시의 특성은 외부에 정보를 안전하게 제공한다는 특정이 있어 네트워크 보안에서 많이 활용된다.

#### [해시를 사용하지 않는다면 어떻게 될까?]
만약 해시를 사용하지 않는다면 우리는 값의 위치에 대한 어떤 정보도 알 수 없을 것이다. 그래서 어떤 데이터를 찾으려면 전체 데이터를 확인해보는 방법밖에는 없을 것이다.
예를 들면 다음과 같이 전체 전화번호를 순차 탐색해 이름에 맞는 전화번호를 찾아야 한다. 그림으로만 봐도 탐색 효율이 떨어진다.

<img src="https://github.com/user-attachments/assets/ca14d5f3-f6c8-4c6b-a08e-0325eb8d4e64" width="370"><br/>

<img src="https://github.com/user-attachments/assets/53ce7ba9-7ef8-4513-ab7f-8075fe271cb7" width="450"><br/>

반면 해시를 사용하면, 순차 탐색할 필요 없이 해시 함수를 활용해서 특정 값이 있는 위치를 바로 찾을 수 있어 탐색 효율이 좋다.
그림에서 **해시 테이블**(hash table)은 키와 대응한 값이 저장되어 있는 공간이고, 해시 테이블의 각 데이터를 **버킷**(bucket)이라고 부른다.

<img src="https://github.com/user-attachments/assets/73816141-8ef0-4f08-b960-0826868e6360" width="500"><br/>

### 🥎 해시의 특성을 활용하는 분야
해시는 단방향으로만 검색할 수 있는 대신 빠르게 원하는 값을 검색할 수 있다. 이런 해시의 특성은 데이터를 저장하고 검색하거나, 보안이 필요한 때에 활용된다.
코딩테스트에서는 특정 데이터를 탐색하는 횟수가 많을 경우 해시를 고려하면 좋다. 다음은 해시가 활용되는 실제 사례이다.
- **비밀번호 관리** : 사용자의 비밀번호를 그대로 노출해 저장하는 것은 위험하므로 해시 함수를 활용해 해싱한 비밀번호를 저장한다. 비밀번호가 맞는지 확인할 때도 마찬가지이다.
  사용자가 입력한 비밀번호를 해싱해 확인한다.
- **데이터베이스 인덱싱** : 데이터베이스에 저장된 데이터를 효율적으로 검색할 때 해시를 활용한다.
- **블록체인** : 블록체인에서 해시 함수는 핵심 역할을 한다. 각 블록은 이전 블록의 해시값을 포함하고 있으며, 이를 통해 데이터 무결성을 확인할 수 있다.

<br/>

## 2. 해시 함수
앞서 언급했던 해시 함수는 어떻게 구현할까? 이것을 알기 위해서는 해시 함수를 구현할 때 고려할 것들을 알아야 한다. 사실 코딩테스트에서 해시 함수를 직접 구현하라는 문제가 나오는 경우는 거의 없다.
**그리고 자바에서는 해시셋 혹은 해시맵이라는 표준 API를 제공하는데 이 클래스는 해시와 거의 동일하게 동작하므로 해시를 쉽게 사용할 수 있다.**
하지만 해시의 원리를 이해하고 해시맵을 사용하면 좀 더 효율적으로 해시맵을 사용할 수 있으므로 한 번쯤 해시 개념을 공부하기를 추천한다.

### 🥎 해시 함수를 구현할 때 고려할 내용
첫 번째, 해시 함수가 변환한 값은 인덱스로 활용해야 하므로 해시 테이블의 크기를 넘으면 안 된다. 다음 그림으로 예를 들어보자.
현재 해시 함수의 결과는 해시 테이블의 크기가 N이므로 인덱스 0 ~ N-1 사이의 값을 내야 한다.

<img src="https://github.com/user-attachments/assets/d4d0a704-049b-43a9-8a2e-3279d292131a" width="430"><br/>

두 번째, 해시 함수가 변환한 값의 충돌은 최대한 적게 발생해야 한다. **충돌의 의미는 서로 다른 두 키에 대해 해싱 함수를 적용한 결과가 동일한 것을 의미한다.**
다음과 같이 홍길동과 홍길서를 해시 함수에 넣었을 때 둘 다 결괏값이 1이면 저장 위치가 같다. 즉, 충돌이 발생한다.
- 충돌이 최대한 적어야 한다라고 이야기한 이유는 충돌이 아예 발생하지 않는 해시 함수는 거의 없기 때문이다.

<img src="https://github.com/user-attachments/assets/0eba2994-8d2f-4733-8f69-dcb268146861" width="400"><br/>

### 🥎 자주 사용하는 해시 함수 알아보기
실제로 자주 사용하는 해시 함수를 알아보자.

#### 1. 나눗셈법
나눗셈법은 가장 떠올리기 쉬운 단순한 해시 함수이다. 나눗셈법(division method)은 키를 소수로 나눈 나머지를 활용한다.
이처럼 나머지를 취하는 연산을 모듈러 연산이라고 하며 연산자는 %로 표시한다. 예를 들어 7 % 2 = 1이다. 나눗셈법을 수식으로 작성하면 다음과 같다.

<img src="https://github.com/user-attachments/assets/54dc7a47-a5c9-4214-8ed2-c706c5d18db4" width="130"><br/>

x는 키, k는 소수이다. 아주 간단하다. 키를 소수로 나눈 나머지를 인덱스로 사용하는 것이다. 나눗셈법을 그림으로 나타내면 다음과 같다.

<img src="https://github.com/user-attachments/assets/d3375429-2da5-4cfa-b226-3ff49cc977a6" width="500"><br/>

#### [나눗셈법에 소수가 아닌 15를 사용하면 어떨까?]
그런데 왜 소수로 나눌까? 소수를 사용하는 이유는 다른 수를 사용할 때보다 충돌이 적기 때문이다. 예를 들어 소수가 아닌 15를 나눗셈법에 적용했다고 해보자.
나눗셈법에 적용했다는 의미는 위 식에서 k에 15를 적용했다는 의미이다. 이때 x가 3의 배수인 경우를 한번 보겠다. 다음 그림을 보면 규칙적으로 계속 같은 해시값이 반복되는 것을 알 수 있다.

<img src="https://github.com/user-attachments/assets/5f8ac86b-c93e-4b60-b07a-2d38e56f6c71" width="600"><br/>

나눗셈법을 적용한 위 그림을 보면 x는 3의 배수, k는 15를 적용하면 수식은 h(x) = x mod 15(단, x는 3의 배수)가 된다. 이 식을 활용하면 해시값은 3, 6, 9, 12, 0이 반복된다.
해시값을 보면 동일한 값들이 계속 반복되며, 이를 해시값이 충돌되었다고 표현한다. 왜 그럴까? x가 k의 약수 중 하나인 3의 배수이기 때문이다. x를 5의 배수로 생각해도 충돌이 많이 발생한다.

#### [왜 충돌이 많이 발생할까?]
이유는 생각보다 간단하다. N의 약수 중 하나를 M이라고 한다면 임의의 수 K에 대해 M * K = N이 되는 수가 반드시 있다. 위 그림에서는 N이 15이고, M이 3인 경우이다.
3 * 5 = 15이므로 K = 5가 된다. 그리고 그림은 K를 주기로 같은 해시값이 반복됨을 알 수 있다. 따라서 K는 1과 자신 빼고는 약수가 없는 수, 즉, 소수를 사용하는 것이 좋다.

#### [나눗셈법의 해시 테이블 크기는 K]
그리고 나눗셈법은 해시 테이블의 크기가 자연스럽게 K가 된다. 왜냐하면 K에 대해 모듈러 연산을 했을 때 나올 수 있는 값은 0 ~ (K-1)이기 때문이다.
즉, 상황에 따라 아주 많은 데이터를 저장해야 한다면 굉장히 큰 소수가 필요할 수도 있다. 아쉽게도 매우 큰 소수를 구하는 효율적인 방법은 아직은 없으며 필요한 경우 기계적인 방법으로 구해야 한다.
나눗셈법의 단점 중 하나이다.

#### 2. 곱셈법
이번에는 곱셈법(multiplication method)을 알아보자. 나눗셈법은 때에 따라 큰 소수를 사용해야 하는데 큰 소수를 구하기가 쉽지 않다는 단점이 있다.
곱셈법은 나눗셈법과 비슷하게 모듈러 연산을 활용하지만 소수는 활용하지 않는다. 곱셈법의 공식은 다음과 같다.

<img src="https://github.com/user-attachments/assets/4e30ae45-1471-4593-9f3b-ceec98158a89" width="220"><br/>

m은 최대 버킷의 개수, A는 **황금비**(golden ratio number)이다. 황금비는 무한소수로 대략 1.6180339887...이며 여기서의 계산에는 황금비의 소수부의 일부인 0.61803만 사용했다.
- 황금비는 수학적으로 임의의 길이를 두 부분으로 나누었을 때, 전체와 긴 부분의 비율이 긴 부분과 짧은 부분의 비율과 같은 비율을 뜻한다.

**[1단계]** 키에 황금비를 곱한다.

<img src="https://github.com/user-attachments/assets/33565b30-768e-45d0-ab17-91da20a4dcad" width="330"><br/>

**[2단계]** [1단계]에서 구한 값의 모듈러 1을 취한다. 쉽게 말해 정수 부분을 버리고 소수 부분만 취한다. 예를 들어 모듈러 1의 결과가 3.1523이면 0.1523만 취한다.
소수 부분만 취하기 때문에 0.xxx 형태의 값이 나오게 된다.

<img src="https://github.com/user-attachments/assets/cbb87307-ad4b-4dd9-b6f4-7c8d6f986bf3" width="350"><br/>

**[3단계]** [2단계]에서 구한 값을 가지고 실제 해시 테이블에 매핑한다. 테이블의 크기가 m이면 [2단계]에서 구한 수에 m을 곱한 후 정수 부분을 취하는 연산을 통해 해시 테이블에 매핑할 수 있다.
[2단계]에서 구했던 값은 0.xxx의 값이므로 매핑할 테이블의 크기인 m을 곱하면 테이블의 인덱스인 0 ~ (m - 1)에 매치할 수 있다.

<img src="https://github.com/user-attachments/assets/ab773ea6-9d18-4579-8da9-86cf4c286fcb" width="650"><br/>

이처럼 곱셈법은 황금비를 사용하므로 나눗셈법처럼 소수가 필요 없다는 장점이 있다. 따라서 해시 테이블의 크기가 커져도 추가 작업이 필요 없다.

#### 3. 문자열 해싱
지금까지 알아본 해시 함수는 키의 자료형이 숫자였다. 이번에는 키의 자료형이 문자열일 때도 사용할 수 있는 해시 함수인 문자열 해싱을 알아보자.
문자열 해싱은 문자열의 문자를 숫자로 변환하고 이 숫자들을 다항식의 값으로 변환해서 해싱한다. 공식은 다음과 같다.
- 다음 함수는 문자열 해싱을 하기 위해 사용하는 polynomial rolling method이다.

<img src="https://github.com/user-attachments/assets/88130063-ffb2-4afe-9870-5e3f7633749c" width="450"><br/>

p는 31이고, m은 해시 테이블 최대 크기이다. 이 수식이 실제 적용되는 과정을 그림과 함께 알아보자.
- p를 31로 정한 이유는 홀수이면서 메르센 소수이기 때문이다.
- 메르센 소수는 일반적으로 2^N - 1 형식으로 표시할 수 있는 숫자 중 소수인 수를 말한다. 메르센 소수는 해시에서 충돌을 줄이는 데 효과적이라는 연구 결과가 있다.

**[1단계]** 다음 그림은 알파벳 a부터 z까지 숫자와 매치한 표와 키이다.

<img src="https://github.com/user-attachments/assets/cad1343e-a88d-43b7-84ec-3fadb855b304" width="600"><br/>

**[2단계]** "a"는 매치 표를 보면 1이다. 따라서 "apple"의 "a"는 1이다. 그러므로 수식의 s[0] * p^0는 1 * 1이므로(31의 0승은 1이다) 1이다.

<img src="https://github.com/user-attachments/assets/cd91afe9-7e73-4abc-8bff-83c043d664ad" width="200"><br/>

**[3단계]** 두 번째 문자열 "p"에 대해 연산을 진행한다. "p"는 16이다. 여기에 p^1을 곱하면 496이다.

<img src="https://github.com/user-attachments/assets/be2d70bf-3ed6-4b00-9197-61b449d889c6" width="200"><br/>

**[4단계]** 이렇게 곱한 값들을 더하면 최종값은 4,990,970이다. 이를 해시 테이블의 크기 m으로 모듈러 연산해 활용하면 된다.

<img src="https://github.com/user-attachments/assets/f6af2bce-085e-4227-949b-91a93b2ab6cb" width="380"><br/>

기존에는 키 자체가 숫자였으므로 바로 해시 함수를 적용했지만 키가 문자열이면 각 문자열의 문자들을 적절한 숫자로 변경한 다음 해시 함수를 적용해야 한다.
이런 변환 과정을 통해 문자열이 키인 데이터에도 해시를 사용할 수 있다. 하지만 해시 함수를 적용할 때 중요한 점이 있다. 해시 함수를 적용한 값이 해시 테이블 크기에 비해 너무 클 수 있다는 것이다.
그래서 해시 함수가 내는 결과의 크기를 해시 테이블 크기에 맞도록 하는 작업이 필요하다. 그림을 보면 "apple"이라는 간단한 문자열을 해싱했는데도 결괏값은 4,990,970으로 굉장히 크다.
오버플로가 발생될 여지가 있으므로 다음 연산 법칙을 활용해 문자열 해시 함수를 수정할 수 있다.

#### [문자열 해시 함수 수정하기]
덧셈을 전부 더한 다음 모듈러 연산을 하는 왼쪽 수식 대신, 오른쪽 수식처럼 중간 중간 모듈러 연산을 해 더한 값을 모듈러 연산하면 오버플로를 최대한 방지할 수 있다.
- 두 수식의 실제 결과는 같다.

<img src="https://github.com/user-attachments/assets/edd6c7a5-dfda-4c08-ba32-4b603fcf8737" width="220"><br/>

이를 활용해서 앞서 본 문자열 해싱 공식을 수정하면 다음과 같다.

<img src="https://github.com/user-attachments/assets/676fa567-a429-44fe-bc7e-a2191e892275" width="550"><br/>

해시 함수뿐 아니라 보통 수식에 모듈러 연산이 있는 문제 중 큰 수를 다루는 문제는 이런 오버플로 함정이 있는 경우가 많다. 난이도가 높은 문제는 대부분 이런 함정을 포함하고 있으니 이번 기회에 제대로 기억해두기 바란다.

<br/>

## 3. 충돌 처리
앞서 자주 언급했던 것처럼 서로 다른 키에 대해서 해시 함수의 결괏값이 같으면 **충돌**(collision)이라고 한다. 하나의 버킷에 2개의 값을 넣을 수는 없으므로 해시 테이블을 관리할 때는 반드시 충돌 처리를 해야 한다.

### 🥎 체이닝으로 처리하기
체이닝은 해시 테이블에 데이터를 저장할 때 해싱한 값이 같은 경우 충돌을 해결하는 간단한 방법이다. 체이닝은 충돌이 발생하면 해당 버킷에 링크드리스트로 같은 해시값을 가지는 데이터를 연결한다.
- 링크드리스트(linked list)는 데이터 요소들을 연결하여 구성된 선형 데이터 구조이다.

<img src="https://github.com/user-attachments/assets/e68a25e8-f6aa-4604-bd98-c14c685f7bcf" width="550"><br/>

그림을 보면 키 B와 C를 해싱했을 때 3이다. 즉, 해시 테이블의 같은 위치를 가리키므로 데이터를 저장할 때 충돌이 발생한다. 이때 체이닝은 링크드리스트로 충돌한 데이터를 연결하는 방식으로 충돌을 해결한다.
이후 어떤 데이터가 해시 테이블 상 같은 위치에 저장되어야 하면 이런 방식으로 데이터를 저장한다. 이처럼 체이닝은 충돌을 링크드리스트로 간단히 해결한다는 장점이 있지만 2가지 단점이 있다.

#### [해시 테이블 공간 활용성이 떨어짐]
충돌이 많아지면 그만큼 링크드리스트의 길이가 길어지고, 다른 해시 테이블의 공간은 덜 사용하므로 공간 활용성이 떨어진다.

#### [검색 성능이 떨어짐]
충돌이 많으면 링크드리스트 자체의 한계 때문에 검색 성능이 떨어진다. 링크드리스트로 연결한 값을 찾으려면 링크드리스트의 맨 앞 데이터부터 검색해야 하기 때문이다.
다음 그림을 보면 맨 뒤의 키 K에 해당하는 값을 검색하려면 B, C, K를 거쳐 확인해야 한다. 만약 N개의 키가 있고 모든 키가 충돌하여 체이닝되었다면 마지막 버킷을 검색하는 경우 시간 복잡도는 O(N)이다.

<img src="https://github.com/user-attachments/assets/9008000c-b6fd-44d9-817c-5eb8bb3c8cfb" width="650"><br/>

참고로 자바에서 HashMap 클래스는 체이닝을 사용하여 해시 충돌을 처리한다.
다만 충돌 발생 시 데이터 접근 시간 복잡도가 O(N)으로 늘어나는 문제가 있으므로 링크드리스트로 연결하는 데이터가 일정 개수가 넘어가면 자동으로 해당 링크드리스트를 이전 탐색 트리(binary search tree)로
변환하여 데이터 접근에 O(logN)의 성능이 나오도록 개선한다.

### 🥎 개방 주소법으로 처리하기
개방 주소법(open addressing)은 체이닝에서 링크드리스트로 충돌값을 연결한 것과 다르게 빈 버킷을 찾아 충돌값을 삽입한다. 이 방법은 해시 테이블을 최대한 활용하므로 체이닝보다 메모리를 더 효율적으로 사용한다.

#### [선형 탐사 방식]
선형 탐사(linear probing) 방식은 충돌이 발생하면 다른 빈 버킷을 찾을 때까지 일정한 간격으로 이동한다. 수식은 다음과 같다.
- 보통 간격은 1로 하는 것이 일반적이다.

<img src="https://github.com/user-attachments/assets/11eaaa51-da04-4d92-9946-349505cdf29e" width="200"><br/>

m은 수용할 수 있는 최대 버킷이다. 선형 탐사 시 테이블의 범위를 넘으면 안 되므로 모듈러 연산을 적용한 것이다. 수식을 그림으로 표현하면 다음과 같다.

<img src="https://github.com/user-attachments/assets/dc6e7ff4-7c58-4770-93e8-3bd5601f942b" width="170"><br/>

키5에 해시 함수를 적용하면 값2가 있는 위치 정보를 참조하므로 충돌이지만 선형 탐사 방법으로 1칸씩 아래로 내려간다. 값3, 값4를 지나 그다음 위치에 값5를 넣는다. 하지만 이 방법도 단점이 있다.
충돌 발생 시 1칸씩 이동하며 해시 테이블 빈 곳에 값을 넣으면 해시 충돌이 발생한 값끼리 모이는 영역이 생긴다. 이를 클러스터(cluster)를 형성한다고 하는데, 이런 군집이 생기면 해시값은 겹칠 확률이 더 올라간다.
- 그래서 이를 방지하기 위해 제곱수만큼 이동하며 탐사하는 방법도 있다.

#### [이중 해싱 방식]
이중 해싱 방식은 말 그대로 해시 함수를 2개 사용한다. 때에 따라 해시 함수를 N개로 늘리기도 한다.
두 번째 해시 함수의 역할은 첫 번째 해시 함수로 충돌이 발생하면 해당 위치를 기준으로 어떻게 위치를 정할지 결정하는 역할을 한다. 예를 들어 보자. h1이 1차 해시 함수, h2가 2차 해시 함수이다.

<img src="https://github.com/user-attachments/assets/5a8927e6-2923-4fdb-b0c5-9cb30ec87071" width="280"><br/>

수식을 보면 선형 탐사와 비슷하게 더하는 방식으로 데이터의 위치를 정하지만 클러스터를 줄이기 위해 m을 제곱수로 하거나 소수로 한다.
이는 주어지는 키마다 점프하는 위치를 해시 함수로 다르게 해서 클러스터 형성을 최대한 피하기 위함이다.

지금까지 해시에 대해 알아봤다. 솔직히 말하자면 해시 함수 자체를 구현하라는 문제는 나오지 않을 가능성이 높다. 그렇다고 지금까지 공부한 개념이 중요하지 않은 건 아니다.
해시는 IT 기업에 입사하려면 당연히 알고 있어야 할 기본 지식이므로 이참에 한번 정리하기 바란다. 면접에서 해시 관련 질문이 나와도 이 정도 수준으로 공부하면 충분히 대답할 수 있을 것이다.
**실제 코딩 테스트 문제에서 해시 문제의 핵심은 키와 값을 매핑하는 과정이다.**
특정 값이나 정보를 기준으로 빈번한 검색을 해야 하거나 특정 정보와 매핑하는 값의 관계를 확인해야 하는 작업이 문제에 있으면 해시를 고려해야 한다.

### 🥎 해시맵
해시맵을 위한 HashTable 클래스와 HashMap 클래스가 있다. 두 클래스는 유사하지만 HashTable 클래스는 자바의 초기 버전과 호환성을 위해 남겨두었을 뿐 최근에는 잘 사용되지 않는다.
따라서 여기서는 해시맵을 사용한다.

#### [해시맵의 ADT]
해시맵의 동작 방식은 앞서 설명한 해시 테이블과 동일하기 때문에 여기서는 해시맵의 ADT만 표를 통해서 간단하게 설명한다.

|구분|정의|설명|
|:---:|:---|:---|
|연산|ValueType put(keyType Key, ValueType value)|해시맵에 데이터를 저장한다.<br/>첫 번째 매개변수는 해당 데이터의 key값, 두 번째 매개변수는<br/>해당 key에 해당하는 value값이다. 반환하는 값은 해시맵 내에<br/>동일한 key에 해당하는 값이 있었다면 그 key에 대한 value값을 반환한다.|
|연산|ValueType get(KeyType key)|key값에 대한 value값을 반환한다.|
|연산|valueType remove(KeyType key)|해시맵에서 key에 해당하는 데이터를 삭제한다.|
|연산|boolean containsKey(KeyType key)|해시맵 안에 해당 key가 있다면 true, 없다면 false를 반환한다.|
|연산|void clear()|해시맵 안의 모든 데이터를 삭제한다.|
|상태|int isEmpty()|해시맵 안에 데이터가 없다면 true, 있다면 false를 반환한다.|
|상태|int size()|해시맵 안에 있는 데이터의 개수를 반환한다.|

### 🥎 HashMap 클래스 사용하기
다음 코드를 보면서 HashMap 클래스의 사용 방법을 알아보자.
```java
// HashMap<KeyType, ValueType>이다.
HashMap<String, Integer> hashMap = new HashMap<>();

// hashMap에 데이터 추가
hashMap.put("ABC", 10);
hashMap.put("BBB", 20);
hashMap.put("AAA", 30);
hashMap.put("ABC", 15);

System.out.println(hashMap.isEmpty());  // false
        System.out.println(hashMap.get("ABC");  // 15
System.out.println(hashMap.containsKey("ABC"));  // true

        hashMap.remove("ABC");  // hashMap에서 키가 "ABC"인 데이터 제거
System.out.println(hashMap.size());  // 2

        hashMap.clear();  // 해시맵의 모든 데이터 삭제
System.out.println(hashMap.isEmpty());  // true
```
해시맵을 선언할 때는 HashMap<KeyType, ValueType>과 같이 선언한다. 코드에서는 키로 String을, 값으로 Integer를 저장하는 해시맵을 생성했다.
만약 키로 Integer를, 값으로 String을 저장하려면 HashMap<Integer, String>과 같이 선언하면 된다.

그리고 동일한 "ABC"라는 키에 대해 10이라는 값을 먼저 넣고 이후에 15라는 값을 넣었을 때 기존 10은 삭제되고 15로 대체되므로 이후 get("ABC")을 실행하면 15를 반환한다.
해시맵은 코딩테스트에서 상당히 많이 사용한다. 뿐만 아니라 실무에서도 많이 사용하므로 해시맵의 사용방법과 개념을 꼭 숙지하기 바란다.

<br/>

## 4. 몸풀기 문제

### [문제 18] 두 개의 수로 특정값 만들기
- 권장 시간 복잡도 : O(N+K)

> n개의 양의 정수로 이루어진 배열 arr와 정수 target이 주어졌을 때 이 중에서 합이 target인 두 수가 arr에 있는지 찾고, 있으면 true, 없으면 false를 반환하는 solution() 함수를 작성하세요.

#### [제약 조건]
- n은 2 이상 10,000 이하의 자연수이다.
- arr의 각 원소는 1 이상 10,000 이하의 자연수이다.
- arr의 원소 중 중복되는 원소는 없다.
- target은 1 이상 20,000 이하의 자연수이다.

#### [입출력의 예]
|arr|target|return|
|:---:|:---:|:---:|
|[1, 2, 3, 4, 8]|6|true|
|[2, 3, 5, 9]|10|false|

#### [문제 분석하고 풀기]
arr에서 특정 원소 두 개를 뽑아 두 수의 합이 target과 같을 수 있는지 확인하는 문제이다. 첫 번째 입출력을 보자. arr이 [1, 2, 3, 4, 8]이고 target이 6이다.
여기서는 두 가지 방법을 알아볼 것이다. 첫 번째 방법은 무작정 가능한 모든 경우의 합을 확인하고, 두 수의 합이 되는지 확인하는 방법이다. 두 번째 방법은 해시를 활용하는 방법이다.

#### (1) 무작정 더하며 찾기
가장 간단한 방법은 각 원소에 대해 자신을 제외한 나머지 원소를 전부 더하면서 두 수의 합이 6인 경우를 찾는 것이다.
이렇게 하면 정답은 당연히 나오겠지만 시간 복잡도는 O(N^2)이므로 데이터가 최대 10,000개까지 들어오는 것을 가정하면 대략 1억 번의 연산이 수행될 수 있으므로 효율이 떨어진다. 뭔가 개선이 필요하다.

#### (2) 해시를 활용해 찾기
어떻게 개선할 수 있을까? 코드를 구현하기 전에 별 아이디어가 떠오르지 않다면 직접 이 문제를 풀어보는 것도 방법이다.
만약 여러분이 이 문제를 직접 푼다면 하나의 숫자를 고른 다음 그 숫자를 더했을 때 target이 되는 수가 arr에 있는지 확인해볼 것이다. 그러니 다음과 같은 관점으로 문제에 접근할 수도 있다.

- "arr에서 임의의 원소 x에 대해 x + k = target이 되는 원소 k가 arr에 있는지 확인하기"

**여기서 핵심은 k를 확인하는 동작의 효율이다.** 문제에서는 x, k는 모두 arr의 원소라고 했으므로 원소의 유무를 표시할 수 있는 해시셋을 마련해 활용하면 O(1) 안에 찾을 수 있다.
그림으로 표현하면 다음과 같다.

<img src="https://github.com/user-attachments/assets/fcc2469a-927e-4d0a-a0df-5ded693d1297" width="400"><br/>

왼쪽이 arr, 오른쪽이 arr을 보고 각 원소의 유무를 표현한 해시셋이다. 해시셋의 크기는 arr의 원소의 수인 5와 같다.
이렇게 해시셋을 준비하고 각 원소에 대해 HashSet(target - 원소)가 해시셋 안에 있다면 target을 만들 수 있는 두 수가 arr에 있다고 봐도 된다.

```java
import java.util.HashSet;

class Solution {
  private static boolean solution(int[] arr, int target) {
    HashSet<Integer> hashSet = new HashSet<>();

    for (int i : arr) {

      // (1) target에서 현재 원소를 뺀 값이 해시셋 있는지 확인
      if (hashSet.contains(target - i)) {
        return true;
      }
      // (2) 해시셋 현재 값 저장
      hashSet.add(i);
    }

    return false;
  }
}
```
우선 arr 배열값을 저장할 해시셋을 하나 만든다. 해시맵은 키-값 쌍으로 데이터를 저장하는 반면, 해시셋은 키만 저장한다는 점에 차이가 있고 다른 것은 해시맵과 동일하다.
이 문제에서는 키값만 필요하기 때문에 해시셋을 사용했다.

- (1) 배열을 순회하면서 현재 원소 i에 대해서 target - i값이 해시셋에 있는지 확인한다. 만약에 있다면 합이 target인 두 수가 있는 것이므로 true를 반환한다.
- (2) 현재 원소를 해시셋에 저장한다. arr 배열의 모든 값에 대해서 확인을 했음에도 더해서 target이 되는 두 원소를 찾지 못했다면 false를 반환한다.

#### [시간 복잡도 분석하기]
N은 arr의 길이이고, K는 target의 길이이다. 해시셋의 contains() 메서드와 add() 메서드의 시간 복잡도는 O(1)이므로 최종 시간 복잡도는 O(N)이 된다.