# 12. 백트래킹

<br/>

---

## 1. 백트래킹과 백트래킹 알고리즘 개념
깊이 우선 탐색, 너비 우선 탐색 방법은 데이터를 전부 확인하는 방법이었다. 이를 완전 탐색이라고 하는데, 완전 탐색은 모든 경우의 수를 탐색하는 방법이므로 대부분의 경우 비효율적이다.

### 🥎 백트래킹이란?
예를 들어 출근하기 위해 아파트를 나섰는데 지하철 개찰구에 도착해서야 지갑을 두고 나온 사실을 알았다고 해보자.그러면 우선은 아파트로 돌아갈 것이다.
집으로 돌아가서 방을 하나씩 보면서 물건을 찾기 시작할 것이다. 혹시라도 옆 집의 문 앞에 선 경우라도 금방 '아 옆 집이구나'하는 생각에 뒤로 돌아 우리 집으로 향할 것이다.
이렇게 어떤 가능성이 없는 곳을 알아보고 되돌아가는 것을 백트래킹(backtracking)이라 한다.

### 🥎 백트래킹 알고리즘이란?
이렇게 가능성이 없는 곳에서는 되돌아가고, 가능성이 있는 곳을 탐색하는 알고리즘을 백트래킹 알고리즘이라고 한다. 그림을 보자.

<img src="https://github.com/user-attachments/assets/7c5f6f3b-bf16-435c-a07f-94584926a9b7" width="400"><br/>

그림을 보면 답을 찾는 과정에서 가능성이 없는 곳에서는 백트래킹한다. 백트래킹 알고리즘은 문제마다 효율이 달라지므로 시간 복잡도를 특정하여 정의하기 어렵다.
하지만 확실한 것은 백트래킹을 통해 해가 될 가능성이 없는 탐색 대상을 배제할 수 있으므로 탐색 효율이 단순히 완전 탐색하는 방법보다 백트래킹이 효율적이다.
그럼 구체적인 예와 함께 백트래킹 알고리즘을 알아보자.

- 깊이 우선 탐색에서 끝까지 갔을 때 돌아가는 것도 백트래킹이라고 말해도 되는 걸까?
  - 깊이 우선 탐색도 백트래킹을 활용한다. 깊이 우선 탐색은 더 이상 탐색할 경로가 없을 때 백트래킹을 활용했다. 백트래킹 알고리즘에서는 해가 있을 가능성이 없을 경우 백트래킹을 활용한다.

### 🥎 유망 함수란?
백트래킹 알고리즘의 핵심은 '해가 될 가능성을 판단하는 것'이다. 그리고 그 가능성은 유망 함수라는 것을 정의하여 판단한다. 실제로 백트래킹 알고리즘은 다음과 같은 과정으로 진행한다.
- (1) 유효한 해의 집합을 정의한다.
- (2) 위 단계에서 정의한 집합을 그래프로 표현한다.
- (3) 유망 함수를 정의한다.
- (4) 백트래킹 알고리즘을 활용해서 해를 찾는다.

그렇다면 유망 함수가 백트래킹 알고리즘에서 어떻게 동작하는지 아주 간단한 문제를 풀어보며 알아보자.

#### [합이 6을 넘는 경우 알아보기]
{1, 2, 3, 4} 중 2개의 숫자를 뽑아서 합이 6을 초과하는 경우를 알아내는 백트래킹 알고리즘을 알아보자. 뽑는 순서가 다르면 다른 경우의 수로 간주한다.
예를 들어 {1, 3}과 {3, 1}의 합은 각각 4로 같지만 서로 다른 경우의 수이다.

**[1단계]** 유효한 해의 집합을 정의한다. 서로 다른 두 수를 뽑는 경우의 수는 다음과 같다.

<img src="https://github.com/user-attachments/assets/8dbf39ee-759e-4000-b49a-1696ca999ec5" width="450"><br/>

**[2단계]** 정의한 해의 집합을 그래프로 표현한다.

<img src="https://github.com/user-attachments/assets/67bb62e3-6a46-4e1a-9518-0f004b37b926" width="550"><br/>

**[3단계]** 그래프에서 백트래킹을 수행한다. **여기서는 '처음에 뽑은 숫자가 3 미만이면 백트래킹한다'라는 전략을 사용한다.**
다시 말해 1과 2를 처음에 뽑으면 이후에 어떤 경로로 가도 원하는 답이 나올 수 없으므로 1, 2는 아예 탐색을 시도하지도 않는다.
이렇게 특정 조건을 정의하는 것을 유망 함수(promising function)를 정의한다고 한다. 예를 들어 위 그림에서 1과 2는 유망 함수를 통과하지 못하여 백트래킹한다.

<img src="https://github.com/user-attachments/assets/e8f7a37c-b30c-4a93-b912-491c02d721b2" width="550"><br/>

**[4단계]** 3은 유망 함수를 통과한다. 참고로 1, 2는 유망 함수와는 상관없이 깊이 우선 탐색 알고리즘에 의해 방문하지만 답이 아니므로 백트래킹하는 것이다.
그 이후 3 → 4로 가서야 답을 찾는다.

<img src="https://github.com/user-attachments/assets/18f28ddf-159b-4420-b95e-70e5d5c5e7c3" width="550"><br/>

**[5단계]** 이와 같은 방식으로 나머지도 탐색을 진행하면 된다.

<img src="https://github.com/user-attachments/assets/1f32f5a8-8984-44e8-8dad-50ee5a2919c5" width="550"><br/>

### 🥎 백트래킹 알고리즘 문제에 적용해보기
백트래킹 알고리즘은 아주 간단해서 더 설명할 내용은 없다. 이제 백트래킹 알고리즘으로 해결할 수 있는 대표적인 문제인 부분 집합 합 문제와 N-여왕 문제를 살펴보자.
많은 사람은 백트래킹 알고리즘을 그냥 '백트래킹으로 문제를 푼다'라고 말하기도 한다. 여기서도 '백트래킹으로 문제를 푼다'라고 하고 엄밀하게 두 용어를 구분하여 말하지 않겠다.

#### [부분 집합 합]
부분 집합 합(sum of subset)은 1부터 N까지 숫자를 조합했을 때 합이 K가 되는 조합을 찾는 문제이다.
이 문제를 전체 탐색과 백트래킹으로 각각 한 번씩 풀면서 두 알고리즘의 차이와 백트래킹의 장점을 알아보겠다.

#### (1) 완전 탐색으로 풀기
각 숫자는 뽑는 상태와 뽑지 않는 상태가 있으며, 각 숫자를 선택하는 과정은 다른 숫자에 대한 선택에 영향을 미치지 않는다.
이 규칙을 적용하면 N개의 숫자를 뽑는 조합은 2^N개가 있으므로, 시간 복잡도는 O(2^N)이라고 할 수 있다. 실제로 어떻게 완전 탐색을 할지도 살펴보자.
N = 4이고 K = 5일 때 완전 탐색을 한다면 이렇게 할 것이다.

<img src="https://github.com/user-attachments/assets/a1d03a48-6249-438b-99d3-1e07c599cad2" width="600"><br/>

원 안의 숫자는 현재까지 뽑은 숫자들의 합을 의미한다. 동그라미(○)는 '그 수를 뽑는다', 엑스(✕)는 '그 수를 뽑지 않는다'이다. 말 그대로 완전히 모든 경우의 수를 탐색하여 총 16번의 탐색을 진행한다.

#### (2) 백트래킹으로 풀기
완전 탐색을 보면 알겠지만 답이 될 가능성이 없는 조합에 대해서도 탐색을 진행한다. 유망 함수를 활용해서 답이 될 가능성이 없는 경우 최대한 탐색이 되지 않도록 해보자.
이 문제에서 유망 함수는 다음과 같이 설계하면 된다.
- 조건 1 : 현재 조합으로 합이 K가 되면 더 탐색하지 않기
- 조건 2 : 해당 숫자를 조합하여 합이 K 이상이 되면 더 탐색하지 않기

**[1단계]** 본격적으로 문제를 풀기 전에 실제로 어떤 상황에서 유망 함수가 백트래킹시키는지도 생각해보자. (1) 우선은 2, 3을 뽑으면 이미 합이 5이므로 수를 더 뽑지 않아도 된다.
조건 1에 맞으니 백트래킹한다. (2) 다른 경우도 생각해보자. 1, 2를 뽑은 상태에서 3을 뽑는다면 6이므로 5보다 크니 3 이후는 뽑지 않아도 되므로 백트래킹한다.

<img src="https://github.com/user-attachments/assets/ab3cc980-db7e-4ca7-9ff8-e2b57a093d3c" width="600"><br/>

**[2단계]** 결국 백트래킹을 통해 탐색을 배제한 노드들이 많아졌다. 완전 탐색을 했다면 배제한 노드도 탐색해야 했을 것이다. 이런 식으로 백트래킹은 탐색의 효율을 크게 높여준다.

<img src="https://github.com/user-attachments/assets/1efe9c83-4462-4a12-a816-5666e8fff28e" width="600"><br/>

#### [유망 함수는 같은 문제에서도 다양하게 정의할 수 있다]
앞의 설명에서는 설명의 편의를 위해 유망 함수를 단순하게 정의하였다. 사실 앞의 설명에서 예로 든 유망 함수는 그렇게 효율적이지 않았다.
유망 함수는 문제를 푸는 사람에 따라 다르게 만들 수 있고, 실제로 이 문제도 다른 유망 함수를 사용하면 더 개선할 수 있다.
이 문제는 숫자를 1부터 체크하고 있으며 마지막 숫자를 알고 있다. 예를 들어 3을 탐색한 이후에는 나머지 숫자가 4라는 것을 알고 있다.
이를 활용하면 마지막 4를 선택할지 판단하는 시점에 현재까지 뽑은 숫자의 합이 1 이상이어야 5가 될 가능성이 있다는 것을 알 수 있다.
**숫자 1에서 3까지 조합에서 합이 0이었다면 4를 볼 필요도 없다는 것을 추가로 알게 되는 것이다.** 이 사실을 유망 함수에 적용하면 훨씬 효율적으로 백트래킹을 할 수 있을 것이다.

<img src="https://github.com/user-attachments/assets/3e0af39d-16a9-43a1-85c1-304f8307a635" width="550"><br/>

### 🥎 N-퀸 문제
N-퀸 문제는 체스의 퀸을 N ✕ N 체스판에 N개 배치했을 때 서로를 공격할 수 없는 위치에 놓을 수 있는 방법이 있는지 찾는 문제이다.
체스를 모르는 독자를 위해 퀸을 설명하자면 퀸은 다음과 같이 이동할 수 있는 말이다.

<img src="https://github.com/user-attachments/assets/7f7c674d-749d-45fe-907b-1c35581e4352" width="430"><br/>

퀸의 이동 경로에 다른 퀸이 있다면 공격하여 제거할 수 있다. 그렇게 되지 않도록 퀸을 배치할 수 있는지를 알아보는 문제이다. 다음과 같은 경우 퀸은 서로를 공격할 수 없다.

<img src="https://github.com/user-attachments/assets/2fdd38eb-eb99-43b0-a65a-39a03f7da6c7" width="480"><br/>

문제를 파악했으니 이제 본격적으로 문제를 풀어보자. 여기서도 완전 탐색, 백트래킹 방식으로 모두 풀어보겠다.

#### (1) 완전 탐색으로 풀기
완전 탐색 방식은 퀸을 놓을 수 있는 경우의 수를 모두 탐색하는 방식이다. 각 줄에 여왕을 놓는 방법은 총 N개이므로 시간 복잡도는 O(N^N)이 된다.
예를 들어 체스판의 크기가 4 ✕ 4라면 다음 그림을 생각해볼 수 있다. 지면상 한계로 일부 그래프를 생략하였다.

<img src="https://github.com/user-attachments/assets/cbeda055-f1c3-4e63-9c34-cc7ed6bf7791" width="500"><br/>

그림은 퀸을 (1, 1), (2, 3), (3, 2), (4, 1)에 놓은 것과 대응하는 그래프의 탐색 경로를 표시한 것이다.
완전 탐색은 그래프상의 모든 경우의 수를 다 탐색하며 조건에 맞는지 검사한다. 이렇게 하면 답을 찾을 수는 있지만 매우 비효율적인 방법이라는 건 이제는 금방 알 수 있을 것이다.
이를테면 (3, 2)에 놓은 퀸은 (2, 3)과 대각선 상에 놓이므로 애초에 그 이후는 탐색할 필요도 없다.

#### (2) 백트래킹으로 풀기
유망 함수를 추가해서 탐색 대상을 줄이고 시간 복잡도를 감소시켜 보자. 여기서 정의할 유망 함수는 다음과 같다.
- 여왕이 추가될 때마다 행이나, 대각선 방향에 겹치는 여왕이 있으면 더 탐색하지 않기

유망 함수를 정의하면 이런 식으로 백트래킹을 한다. (1, 1), (2, 3) 이후 (3, 2)를 만나면 대각선상의 (2, 3)과 겹치므로 유망 함수에서 걸러진다.
즉, 그 이후는 더 탐색하지 않고 백트래킹한다.

<img src="https://github.com/user-attachments/assets/7a5a2271-914e-4915-a6df-d03e3601dfa9" width="500"><br/>

구체적으로 백트래킹을 통해 문제를 푸는 과정은 다음과 같다.

**[1단계]** 유효한 해의 집합을 정의한다. 4행 4열의 칸이 있고 여기에 퀸을 놓을 수 있으므로 해의 집합은 다음과 같이 표시할 수 있다.

<img src="https://github.com/user-attachments/assets/4a2fda00-9cee-4cde-88bd-f27a70acdff1" width="450"><br/>

표시 방법이 헷갈릴 수 있으므로 그림으로도 확인한다. 예를 들어 2, 1, 1, 3은 다음과 같은 말의 상태를 의미한다.

<img src="https://github.com/user-attachments/assets/951adc24-5107-4bfc-bdad-5dd309d7c0f9" width="200"><br/>

**[2단계]** 앞서 본 것처럼 해의 집합을 그래프로 표현한다.

<img src="https://github.com/user-attachments/assets/49ae24e3-d117-4e2a-9346-282264c62f27" width="370"><br/>

**[3단계]** 백트래킹은 방금 본 것과 같다. 다른 예로도 설명해보겠다. 1 → 1로 이동하면 유망 함수에 의해 백트래킹한다.

<img src="https://github.com/user-attachments/assets/e033a8df-377a-4154-90ce-db931de7278d" width="400"><br/>

**[4단계]** 유망 함수를 통과하여 탐색하는 경우는 다음과 같다. 2, 4, 1, 3의 경우 유망 함수를 통과하는 조건이다.
X로 표시한 것들은 2, 4, 1, 3이 N퀸 조건에 맞는지 확인하는 과정에서 유망 함수에 의해 백트래킹된 것이다.

<img src="https://github.com/user-attachments/assets/7eab1cea-9bde-4ea9-ad14-763616c26079" width="480"><br/>

완전한 풀이는 이쯤에서 생략하고 여기서는 백트래킹 방식으로 푼다는 의미와 유망 함수의 역할이 무엇인지에 대한 감만 잡고 넘어가도록 한다.
본격적인 코드를 통한 풀이는 이후 문제를 통해 더 단단하게 만들어보자.

<br/>

## 2. 몸풀기 문제
### [문제 43] 1부터 N까지 숫자 중 합이 10이 되는 조합 구하기
- 권장 시간 복잡도 : O(N!)

> 정수 N을 입력받아 1부터 N까지의 숫자 중에서 합이 10이 되는 조합을 리스트로 반환하는 solutino() 함수를 작성하세요.

#### [제약 조건]
- 백트래킹을 활용해야 한다.
- 숫자 조합은 오름차수능로 정렬되어야 한다.
- 같은 숫자는 한 번만 선택할 수 있다.
- N은 1 이상 10 이하인 정수이다.

#### [입출력의 예]
|N|result|
|:---:|:---|
|5|[[1, 2, 3, 4], [1, 4, 5], [2, 3, 5]]|
|2|[]|
|7|[[1, 2, 3, 4], [1, 2, 7], [1, 3, 6], [1, 4, 5], [2, 3, 5], [3, 7], [4, 6]]|

#### [문제 분석하고 풀기]
앞서 살펴본 문제를 코드로 풀 때가 된 것 같다. 자세한 설명은 이미 했으므로 문제에 접근하는 방법만 이야기하겠다.
- 조합한 숫자의 합이 10이 되면 해당 조합을 결과 리스트에 추가하기
- 조합한 숫자의 합이 10보다 크면 백트래킹(유망 함수 조건)

유망 함수 조건만 잘 파악했다면 쉽게 구현할 수 있는 문제이다. 코드로 구현해보자.

```java
import java.util.ArrayList;

class Solution {
  // (1) 조합 결과를 담을 리스트
  private static ArrayList<ArrayList<Integer>> result;
  private static int n;


  private static void backtrack(int sum, ArrayList<Integer> selectedNums, int start) {
    // (2) 합이 10이 되면 결과 리스트에 추가
    if (sum == 10) {
      result.add(selectedNums);
      return;
    }

    // (3) 다음에 선택할 수 있는 숫자들을 하나씩 선택하면서
    for (int i = start; i <= n; i++) {
      // (4) 선택한 숫자의 합이 10보다 작거나 같으면
      if (sum + i <= 10) {
        ArrayList<Integer> list = new ArrayList<>(selectedNums);
        list.add(i);
        // (5) 백트래킹 메서드를 재귀적으로 호출한다.
        backtrack(sum + i, list, i + 1);
      }
    }
  }

  private static ArrayList<ArrayList<Integer>> solution(int N) {
    result = new ArrayList<>();
    n = N;

    // (6) 백트래킹 메서드 호출
    backtrack(0, new ArrayList<>(), 1);
    return result;  // (7)
  }
}
```
solution() 메서드는 정수 N을 인수로 받는다. 이 N은 1부터 N까지의 숫자 중에서 합이 10이 되는 조합을 구하는 데 사용한다.

- (1) 메서드 내부에서는 1부터 N까지의 숫자 중 합이 10이 되는 모든 조합을 담을 빈 리스트 result를 초기화한다. result는 최종 반환값이다.
- (2) 백트래킹 메서드 backtrack()가 있다.
  3개의 인자 sum, selectNums, start를 하나씩 설명하면, sum은 현재까지 선택한 숫자들의 합, selectedNums는 현재까지 선택된 숫자들을 담고 있는 리스트, start는 조합에 포함 여부를 확인할 숫자이다.
- (3) 현재까지의 숫자 조합으로 합이 10이 되면 results에 현재 숫자들의 조합이 있는 리스트 selectedNums를 추가한다. 이렇게 한 다음에는 더 숫자를 추가할 필요가 없으므로 백트래킹한다.
- (4) 현재 숫자 start부터 N까지 범위에 대해 반복문을 수행한다.
  backtrack() 메서드는 1부터 N까지 차례대로 조합을 하면서 특정값 K가 되는 부분합을 찾고 있으므로 현재 숫자 이전의 숫자는 체크할 필요가 없다.
- (5) 유망한 경우에만 backtrack() 메서드를 호출하여 숫자 조합을 계속 확인한다. 여기까지 backtrack() 메서드에 대한 설명이다.

이제 solution() 메서드의 나머지 부분을 설명한다.
- (6) 현재까지 구한 부분합 sum은 0, 해당 합의 조합인 selectedNums는 빈 리스트로, start는 1로 하여 backtrack() 메서드를 호출한다.
- (7) 모든 부분합의 조합인 result를 반환한다.

#### [시간 복잡도 분석하기]
N은 선택할 수 있는 숫자의 최대 개수이다. 비복원 방식으로 숫자의 조합을 구하고 있으므로 처음 선택지는 N개 그다음 선택지는 (N - 1), ... 이런 식으로 1씩 줄어든다.
이를 곱하면 최종 시간 복잡도는 O(N!)이다. 다만 실제 연산은 유망 함수에 의해 훨씬 적다.

## [문제 44 스도쿠 퍼즐]
- 권장 시간 복잡도 : O(9^N)

> 9 ✕ 9 스도쿠 보드를 다 채워 완성된 스도쿠 보드를 반환하는 solution() 함수를 작성하세요. 해는 유일하지 않을 수 있습니다.
> 스도쿠의 조건에 맞다면 맞는 해라고 생각하시면 됩니다. 스도쿠의 규칙은 아래와 같습니다.
>   1. 가로줄, 세로줄에는 1부터 9까지의 숫자가 한 번씩 나타나야 합니다.
>   2. 9 ✕ 9 보드를 채울 9개의 작은 박스(3 ✕ 3 크기)에도 1부터 9까지의 숫자가 한 번씩 나타나야 합니다.

#### [제약 조건]
- 문제에 주어지는 board 중 스도쿠를 완성하지 못하는 board는 없다고 가정한다. 예를 들어 특정 행이나 열에 같은 숫자가 있는 경우는 없다.

#### [입출력의 예]
|board|result|
|:---|:---|
|<img src="https://github.com/user-attachments/assets/9f9b82cf-3a94-4358-b574-4e4154be8bd8" width="200"><br/>|<img src="https://github.com/user-attachments/assets/f8270d65-90f4-42ae-8310-499aa8f2d787" width="200"><br/>|
|<img src="https://github.com/user-attachments/assets/4fe64abe-cf31-4a7a-9948-9e12870d7df3" width="200"><br/>|<img src="https://github.com/user-attachments/assets/19b84f0a-7611-4ef7-a189-f8483fc039df" width="200"><br/>|

#### [문제 분석하고 풀기]
스도쿠 보드의 빈칸에 적절한 숫자를 채우는 과정에 백트래킹을 사용해보자. num이라는 숫자를 특정 위치에 넣어도 되는지 여부는 아래와 같이 판단할 수 있다.
다음 조건에 해당된다면 백트래킹한다.
- 조건 1 : 해당 행에 넣으려는 숫자 num이 있는지 확인한다.
- 조건 2 : 해당 열에 넣으려는 숫자 num이 있는지 확인한다.
- 조건 3 : 해당 위치를 포함하는 3 ✕ 3 박스에 num이 있는지 확인한다.

```java
import java.util.Arrays;

class Solution {
  private static class Block {
    int i, j;
    public Block(int i, int j) {
      this.i = i;
      this.j = j;
    }
  }

  private static int[][] Board;

  private static boolean isValid(int num, int row, int col) {
    // (1) 현재 위치에 num이 들어갈 수 있는지 검사
      return !(inRow(num, row) || incol(num, col) || inBox(num, row, col));
  }

  private static boolean inRow(int num, int row) {
    // (2) 해당 행에 num이 있는지 확인
    return Arrays.stream(Board[row]).anyMatch(n -> n == num);
  }

  private static boolean inCol(int num, int col) {
    // (3) 해당 열에 num이 있는지 확인
    for (int i = 0; i < 9; i++) {
      if (Board[i][col] == num) {
        return true;
      }
    }
    return false;
  }

  private static boolean inBox(int num, int row, int col) {
    // (4) 현재 위치의 3 ✕ 3 박스에 num이 있는지 확인
    int boxRow = (row / 3) * 3;
    int boxCol = (col / 3) * 3;

    for (int i = boxRow; i < boxRow + 3; i++) {
      for (int j = boxCol; j < boxCol + 3; j++) {
        if (box[boxRow][boxCol] == num) {
          return true;
        }
      }
    }
    return false;
  }

  private static Block findEmptyPosition() {
    // (5) 스도쿠 보드에서 비어 있는 위치 반환
    for (int i = 0; i < 9; i++) {
      for (int j = 0; j < 9; j++) {
        if (Board[i][j] == 0) {
          return new Block(i, j);
        }
      }
    }
    return null;
  }

  private static boolean findSolution() {
    // (6) 비어 있는 위치에 가능한 숫자를 넣어가며 스도쿠 해결
    Block emptyPos = findEmptyPosition();
    // (7) 빈칸이 없으면 스도쿠가 해결된 것으로 간주
    if (emptyPos == null) {
      return true;
    }

    int row = emptyPos.i;
    int col = emptyPos.j;

    for (int num = 1; num <= 9; num++) {
      if (isValid(num, row, col)) {
        Board[row][col] = num;
        // (8) 다음 빈칸을 재귀 탐색
        if (findSolution()) {
          return true;
        }
        // (9) 가능한 숫자가 없으면 원래의 0으로 되돌림
        Board[row][col] = 0;
      }
    }
    return false;
  }

  private static int[][] solution(int[][] board) {
    Board = board;
    findSolution();
    return board;
  }
}
```

- (1) isValid() 메서드는 칸의 위치, 즉, 행과 열, 그리고 스도쿠 보드에 넣을 값을 매개변수로 받는다. 백트래킹의 유망 메서드가 이 메서드이다.
  해당 위치에 값을 넣을 수 있는지 inRow, inCol, inBox를 활용하여 확인한다.
- (2) inRow() 메서드는 넣을 수가 같은 행에 있는지 확인하고, (3) 마찬가지로 inCol() 메서드는 열을 확인한다.
- (4) 현재 위치를 포함한 3 ✕ 3 박스에 같은 숫자가 있는지 확인한다.
- (5) findEmptyPosition() 메서드는 현재 스도쿠 보드에 비어 있는 위치를 반환한다.
  스도쿠 보드를 순회하면서 값이 0인 칸이 있는지 확인하고, 값이 0인 칸이 있다면 해당 칸의 행, 열을 반환한다. 빈칸이 없으면 null을 반환한다.
- (6) findSolution()은 스도쿠를 푸는 메인 메서드이다. 스도쿠 보드에서 빈 위치를 확인하고 알맞은 숫자를 넣는다. 여기서 '알맞은'이란 isValid() 메서드가 true를 반환하는 경우이다.
- (7) 스도쿠 보드에 숫자가 전부 채워져 있다면 더 탐색을 진행하지 않는다. 백트래킹은 다음과 같이 진행한다.
- (8) ~ (9) row, col은 findEmptyPosition() 메서드를 통해 찾은 빈칸의 행과 열 값이다.
  - 해당 위치에 숫자를 1~9까지 하나씩 넣으며 isValid() 메서드로 체크한다.
    - 유망하다면 스도쿠 보드에 해당 값을 넣고 findSolution() 메서드를 호출하여 빈칸을 체크한다.
    - findSolution() 메서드가 true를 반환하면, 즉, 스도쿠 보드에 빈칸이 없다면 더 탐색하지 않는다. false를 반환하면 row, col에 num을 넣었을 때 해가 없는 경우이다.
      반복문을 다 돌았는데도 해를 찾지 못하면 false를 반환한다.

#### [시간 복잡도 분석하기]
N은 스도쿠에서 빈칸의 개수이다. 빈칸당 1~9의 수가 들어가므로 최종 시간 복잡도는 O(9^N)이다. 다만 실제 연산은 유망 함수에 의해 훨씬 적다.