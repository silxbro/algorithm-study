# 06. 스택
<br/>

---

## 1. 스택 개념
스택(stack) 어원은 '쌓는다'이다. 스택은 어원에서 짐작할 수 있듯이 먼저 입력한 데이터를 제일 나중에 꺼낼 수 있는 자료구조이다. 스택은 우리 주변에서도 쉽게 찾아볼 수 있다.
티슈를 생각해보자. 티슈를 만들 때는 먼저 넣은 티슈가 가장 아래에 위치한다. 그래서 티슈를 사용할 때는 가장 위에 있는 티슈부터 사용할 수 있다.
**이렇게 먼저 들어간 것이 마지막에 나오는 규칙을 선입후출 또는 FILO(First In Last Out)라고 한다. 이때 스택에 삽입하는 연산을 푸시(push), 꺼내는 연산을 팝(pop)이라고 한다.**

### 🥎 스택의 동작 원리 이해하기
다음 그림을 통해 스택에서 원소가 이동하는 과정을 이해해보자.

#### [01단계] 초기에는 빈 스택이 있습니다.
<img src="https://github.com/user-attachments/assets/3205c033-5c0b-4f2c-8c46-c4b00578130d" width="100">

#### [02단계] 여기에 데이터 '1'을 푸시해봅시다. 그럼 다음과 같을 겁니다.
<img src="https://github.com/user-attachments/assets/ead5d0ad-b71f-40c6-bc60-03caec69bd45" width="200">

#### [03단계] 그럼 여기에 데이터 '2'를 푸시하면 어떻게 될까요? '1' 위로 '2'가 올라갑니다.
<img src="https://github.com/user-attachments/assets/b12b5412-9285-4cb2-b109-9ae44b578aeb" width="200">

#### [04단계] 그럼 팝을 하면 어떻게 될까요? 가장 위에 있는 데이터인 '2'가 빠져나옵니다.
<img src="https://github.com/user-attachments/assets/adececb5-a632-44a7-880c-27ba173a890a" width="180">

#### [05단계] 그리고 다시 데이터 '3'을 푸시를 하면? 다시 '1' 위에 '3'이 위치하게 되었습니다.
<img src="https://github.com/user-attachments/assets/b95bf9eb-5b0b-431f-947f-ea3c6acb6b51" width="200">

#### [06단계] 팝을 2번 연속으로 하면 '3', '1' 순서로 데이터가 빠져나올 겁니다.
<img src="https://github.com/user-attachments/assets/b61bd939-11ac-45ff-aa9a-7e6ef5c9b365" width="500">

<br/>

## 2. 스택의 정의
스택이 어떤 방식으로 동작하는지는 이해했을 것이다. 이제 스택의 ADT라는 것을 정의해보고 실제 스택이 동작하는 원리를 설명하도록 한다.
ADT는 우리말로 추상 자료형(abstract data type)인데, 추상 자료형이란 인터페이스만 있고 실제로 구현은 되지 않은 자료형이다. 일종의 자료형의 설계도라고 생각하면 된다.
그렇다면 스택은 어떤 정의가 필요한 자료구조일까?
- 언어에 따라 표준 라이브러리에서 스택 제공 여부는 다르다. 자바는 컬렉션 프레임워크에서 Stack 클래스를 제공하기 때문에 Stack 클래스의 객체를 생성해서 사용하면 된다.
- 덱(deque)은 한쪽으로만 데이터 삽입, 삭제할 수 있는 스택과 다르게 양쪽에서 데이터를 삽입하거나 삭제할 수 있는 자료구조이다.
  이런 덱의 특징을 조금만 응용하면 스택처럼 사용할 수 있다.

### 🥎 스택의 ADT
우선 스택에는 (1) 푸시(push), (2) 팝(pop), (3) 가득 찼는지 확인(isFull), (4) 비었는지 확인(isEmpty)과 같은 연산을 정의해야 한다.
그리고 스택은 최근에 삽입한 데이터의 위치를 저장할 변수인 (5) 톱(top)도 있어야 한다. 표와 그림으로 정리하면 다음과 같다.
- 여기서는 스택의 내부 데이터를 배열로 관리하는 모습을 예로 들었다. 하지만 스택의 원소는 배열이 아니라 다른 자료구조로 관리할 수도 있다.

|구분|정의|설명|
|:---:|:---|:---|
|연산|boolean isFull()|스택에 들어 있는 데이터 개수가 maxsize인지 확인해 boolean값을 반환한다.<br/>가득 차 있다면 true, 아니면 false이다.|
|연산|boolean isEmpty()|스택에 들어 있는 데이터가 하나도 없는지 확인해 boolean값을 반환한다.<br/>데이터가 하나라도 있으면 false, 아니면 true이다.|
|연산|void push(ItemType item)|스택에 데이터를 푸시한다.|
|연산|ItemType pop()|스택에서 최근에 푸시한 데이터를 팝하고, 그 데이터를 반환한다.|
|상태|Int top|스택에서 최근에 푸시한 데이터의 위치를 기록한다.|
|상태|ItemType data[maxsize]|스택의 데이터를 관리하는 배열이다. 최대 maxsize개의 데이터를 관리한다.|

<img src="https://github.com/user-attachments/assets/0190cfeb-8dd3-4dd9-9a9b-853bad5c44ae" width="350">

그림은 스택의 ADT를 나타낸 것이다. 스택 외부와 내부에 네모 모양으로 표현한 연산과 상태가 보인다.
그림에서는 연산 시 해야 할 동작과 상태가 가지고 있어야 할 값을 정의하고 있기는 하지만 세부 구현 내용, 즉 **프로그래밍 언어는 무엇을 사용해야 하고 데이터는 이렇게 저장해야 한다는 등의 내용은 없다.**
data 배열을 보면 최대 크기는 maxsize이므로 인덱스의 범위는 0부터 maxsize - 1이다. top은 가장 최근에 추가한 데이터의 위치를 참조한다.
지금 그림에서는 아무 데이터도 없으므로 top에 -1이 들어 있다. 만약 top이 0이면 데이터가 1개 있는 것이므로 초깃값을 0이 아니라 -1로 했음에 주목하자.

그렇다면 스택을 공부할 때 ADT만 알면 되고 세부 구현은 몰라도 될까? 사실은 세부 구현을 알아두면 도움이 된다. 왜냐하면 어떤 문제도 '스택으로 푸세요'라고 대놓고 알려주지는 않기 때문이다.
만약 어떤 문제를 보고 '스택으로 푸는 게 좋겠다'라는 생각이 떠오르려면 스택의 세부 동작을 충분히 아는 것이 좋다.

#### [자료구조의 세부 동작을 공부하면 큰 도움이 됩니다]
자룍구조의 세부 동작을 이해하면 코딩 테스트뿐 아니라 면접에도 큰 도움이 된다.
왜냐하면 자료구조의 세부 동작을 공부하면 그 자료구조의 성능 및 특성을 이해하는 것이고, 이는 효율적인 알고리즘을 떠올릴 수 있게 해주기 때문이다.
실제로 자료구조의 이해도를 요구하는 문제가 출제되기도 한다. 꼭 한 번은 자료구조의 세부 동작을 공부하기 바란다.

#### [스택 세부 동작에 대해 조금 더 자세히 알아보기]
스택에 데이터를 추가하는 경우를 생각해보자. 이번에 설명할 내용은 이 푸시 연산을 수행할 때 스택 내부에서 일어나는 과정이다. 그림은 push(3) 연산을 수행하며 데이터 3이 추가되는 모습을 보여준다.

<img src="https://github.com/user-attachments/assets/50161cca-a4da-43c5-8c20-8cac8d1062d8" width="500">

연산 과정은 push(3)을 호출하면 내부적으로 (1)isFull()을 수행해 우선 data 배열에 데이터가 가득 찼는지 확인하고,
(2)그렇지 않다면 top을 1만큼 증가시킨 후 top이 가리키는 위치 (3)data[0]에 3을 추가한다.

반대로 pop() 연산을 수행한다면 어떻게 될까?

<img src="https://github.com/user-attachments/assets/78ab6d02-6047-444e-9e8e-663fa122687c" width="500">

그림에서 보듯 pop() 함수를 수행하면 내부적으로 (1)isEmpty() 함수를 우선 수행해 data 배열에 데이터가 없는 건 아닌지 확인하고,
데이터가 있다면 (2)top을 1만큼 감소시키고 (3)데이터 '3'을 반환한다. 여기서 '3이 남아 있는데?'라고 생각할 수도 있다. 앞서 정의한 스택의 ADT에서 top은 최근에 삽입한 데이터의 위치라고 하였다.
즉, top이 가리키는 위치는 -1이므로 실제 data 배열에 데이터가 남아 있더라도 스택은 비어 있다고 봐도 된다.

### 🥎 Stack 클래스 사용하기
코딩 테스트에서는 문제에 적용할 자료구조 혹은 알고리즘을 파악하는 능력이 중요하다. 문제에서 의도한 데이터 흐름이 스택에 딱 맞는지 알아차리는 것이 중요하다.
예를 들어 데이터를 그냥 저장하고 순서와 상관 없이 임의 접근하기만 해도 되면 배열을 사용하면 되지만 최근에 삽입한 데이터를 대상으로 뭔가 연산해야 한다면 스택을 떠올리는 것이 좋다.
본격적인 문제를 풀기 전에 앞서 자바에서 Stack을 사용하는 방법에 대해 코드로 알아보자.
```java
Stack<Integer> stack = new Stack<>();  // 스택 객체 생성
// 스택에 데이터 푸시
stack.push(1);
stack.push(3);
// 스택이 비어 있는지 확인
System.out.println(stack.isEmpty());  // false
// 스택에서 팝
        System.out.println(stack.pop());  // 3
        System.out.println(stack.pop());  // 1
        System.out.println(stack.isEmpty());  // true
```
그러나 자바의 Stack 클래스는 크기를 동적으로 관리하므로 max_size나 isFull() 메서드는 없다. 다만 size() 메서드를 제공하여, 스택에 들어 있는 데이터의 수를 알 수 있다.
또한 추가적으로 스택에서 가장 최근에 push한 데이터를 꺼내지 않으면서 반환만 하는 peek() 메서드를 제공한다.
```java
Stack<Integer> stack = new Stack<>();
stack.push(6);
stack.push(5);
// 스택에 가장 최근에 푸시한 값(peek)
System.out.println(stack.peek());  // 5
        System.out.println(stack.pop());  // 5
// 스택에 들어 있는 데이터의 개수(size)
        System.out.println(stack.size());  // 1
        stack.push(7);
stack.push(4);
System.out.println(stack.pop());  // 4
        System.out.println(stack.pop());  // 7
        System.out.println(stack.pop());  // 6
        System.out.println(stack.size());  // 0
```
스택의 개념 자체는 크게 어렵지 않으므로 비교적 쉽게 이해할 수 있다.
하지만 실전에 들어가 문제를 풀다 보면 스택을 몰라서 풀지 못하는 것이 아니라 '이 문제는 스택을 활용해야 풀 수 있다'라는 생각 자체를 못해서 풀지 못하는 경우가 대부분이다.
**따라서 스택 관련 문제를 많이 풀어보며 '이 문제는 스택을 사용하는 게 좋겠다'라는 감을 익히기를 권한다.**

<br/>

## 3. 몸풀기 문제
지금까지 배운 내용을 활용해서 문제 2개를 풀어보자. 여기서는 왜 스택을 사용하는지, 스택을 어떤 식으로 활용하는지에 집중하며 학습하기 바란다.

### [문제 08] 올바른 괄호
- 권장 시간 복잡도 : O(N)
> 괄호가 바르게 짝지어졌다는 것은 '(' 문자로 열렸으면 반드시 짝지어서 ')' 문자로 닫혀야 한다는 뜻이다. 예를 들어
> - "()()" 또는 "(())()"는 올바른 괄호이다.
> - ")()(" 또는 "(()("는 올바르지 않은 괄호이다.
>
> '(' 또는 ')'로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 반환하고 올바르지 않은 괄호이면 false를 반환하는 solution() 함수를 완성해주세요.

#### [제약 조건]
- 문자열 s의 길이 : 100,000 이하의 자연수
- 문자열 s는 '(' 또는 ')'로만 이루어져 있다.

#### [입출력의 예]
|s|answer|
|:---:|:---:|
|"()()"|true|
|"(())()"|true|
|")()("|false|
|"(()("|false|

#### [문제 분석하고 풀기]
이런 괄호 짝 맞추기를 해결하려면 어떻게 해야 할까? 바로 스택을 사용하면 된다. 스택을 어떻게 적용할 수 있는지 알아보자.
문제 조건에서 주목해야 할 내용은 **닫힌 괄호가 임의 위치의 열린 괄호와 상쇄되는 것이 아니라 닫힌 괄호가 나오기 바로 전의, 즉 가장 가까운(최근) 열린 괄호와 상쇄된다는 것이다.**
가장 가까운(최근)이라는 키워드를 보고 **스택**을 떠올리는 감각이 있어야 한다. 스택과 함께 이 문제를 풀려면 다음과 같은 과정으로 괄호를 상쇄하면 된다.

1. 문자열을 앞에서 하나씩 보며 열린 괄호가 나오면 푸시
2. 닫힌 괄호가 나오면 팝 연산을 통해 문자열에서 열린 괄호, 닫힌 괄호 한 쌍을 상쇄
3. 1~2를 마지막 문자열까지 반복해 스택에 열린 괄호가 남아 있다면 짝이 맞지 않은 것(false)이고, 괄호가 남아 있지 않다면 짝이 맞은 것(true)으로 판단

실제 데이터와 함께 위 과정을 연습해보자.

#### (1) 괄호의 짝이 맞는 경우
**[1단계]** 우선은 짝이 맞는 경우를 살펴보자. (1) 크기가 6인 배열에 괄호를 배치하고 스택을 준비하자. (2) 그런 다음 인덱스 0은 열린 괄호이므로 스택에 푸시하고 다음을 본다.
(3) 다음의 값은 닫힌 괄호이므로 스택에서 팝하고 다음을 본다. 이 단계를 마치면 스택에는 아무것도 없으므로 지금까지 본 인덱스 0~1에 한해서는 괄호를 상쇄했다고 보아도 된다.

<img src="https://github.com/user-attachments/assets/9000fc6d-52ea-4d08-97cf-9de340125a91" width="700">

**[2단계]** (1) 인덱스 2는 열린 괄호이므로 푸시하고 다음을 본다. (2) 인덱스 3은 열린 괄호이므로 다시 푸시하고 다음을 본다. (3) 이번엔 닫힌 괄호이므로 스택에서 팝하고 다음을 본다.
(4) 인덱스 5는 닫힌 괄호이므로 팝하고 연산을 마친다. 모든 탐색을 끝냈을 때 스택이 비어 있으므로 배열의 괄호는 모두 짝이 맞다.

<img src="https://github.com/user-attachments/assets/208a828e-e595-40fc-9ab0-5494a8cb184a" width="700">

#### (2) 괄호의 짝이 맞지 않는 경우
**[1단계]** 이번에는 짝이 맞지 않은 경우를 살펴보자. (1) (, ), ( 순서로 괄호가 배치되어 잉ㅆ다. (2) 처음은 열린 괄호이므로 푸시하고 그 다음을 본다.

<img src="https://github.com/user-attachments/assets/609e3156-13df-40d4-9406-5c0d64a1fd8e" width="400">

**[2단계]** (3) 인덱스 1은 닫힌 괄호이므로 팝하고 다음을 본다. (4) 인덱스 2는 열린 괄호이므로 푸시한다. 이렇게 하고 보면 모든 데이터를 탐색했으므로 스택에는 열린 괄호가 남아 있다.
즉, 짝이 맞지 않다.

<img src="https://github.com/user-attachments/assets/9c135a8e-3c6a-4e8f-899b-7cf41e100cb2" width="500">

이제 코드로 문제를 풀어보자. 코드는 아주 간단하다
```java
import java.util.ArrayDeque;

class Solution {
  private boolean solution(String s) {
    ArrayDeque<Character> stack = new ArrayList<>();

    char[] a = s.toCharArray();
    for (char c : a) {
      if (c == '(') {
        stack.push(char);
      }
      else {  // (1)
        if (stack.isEmpty() || stack.pop() == c) {
          return false;
        }
      }
    }

    return stack.isEmpty();
  }
}
```
(1) stack.isEmpty()로 스택이 비어있는지 먼저 체크한 후 pop()하고 있는 것을 주목하자. 스택이 비어있을 때 pop() 메서드를 호출하면 EmptyStackException 예외가 발생한다.

#### [시간 복잡도 분석하기]
N은 s의 길이이다. s를 순회하며 괄호의 쌍을 확인하므로 시간 복잡도는 O(N)이다. 참고로 괄호 쌍을 확인할 때 push() 메서드와 pop() 메서드의 시간 복잡도는 O(1)이다.

### [문제 09] 10진수를 2진수로 변환하기
- 권장 시간 복잡도 : O(logN)

> 10진수를 입력받아 2진수로 변환해 반환하는 solution() 함수를 구현하세요.

#### [제약 조건]
- decimal은 1 이상 10억 미만의 자연수

#### [입출력의 예]
|decimal|반환값|
|:---:|:---:|
|10|1010|
|27|11011|
|12345|110000000111001|

#### [문제 분석하고 풀기]
우선 10진수를 2진수로 표현하는 과정을 보자. 10진수를 2진수로 표현하는 과정은 다음과 같으며, 이 과정은 이미 수학적으로 증명된 것이므로 별도로 설명하지 않는다.

1. 10진수 N을 2로 나눈 나머지, 즉, %2 연산을 한 값을 저장하고, N은 2로 나눔
2. 몫이 0이 아니라면 나머지를 버리고 다시 1을 수행
3. 모든 과정이 끝나고 1에서 저장한 수를 뒤부터 순서대로 가져와 붙이기

#### [십진수를 2진수로 변환하는 과정]
십진수 13을 위 과정대로 변경하는 모습은 다음과 같다. 13을 2로 나누면서 나눈 나머지를 순서대로 저장한다. 이 과정을 0이 될 때까지 반복한다.
몫이 0이 되면 저장한 값을 뒤부터 순서대로 읽으면 1101으로 이진수 변환이 완료된다.

이 문제도 스택으로 쉽게 풀 수 있다. 스택에 저장할 데이터가 무엇인지 정의하면 된다. 그림의 왼쪽을 보면 10진수 N을 2로 나누며 나머지를 표시했는제 이 나머지를 거꾸로 읽으면 우리가 원하는 이진수가 된다.
즉, 나머지를 스택에 쌓고, 하나씩 꺼내면 답이 나온다.

**[1단계]** 다음 그림을 보며 이해해보자. 초기에는 13으로 시작한다. 이것을 2로 나누고 나머지를 스택에 푸시한다. 13을 2로 나눈 나머지가 1이므로 1을 푸시했다.

<img src="https://github.com/user-attachments/assets/ab22eb53-5555-4fe5-a244-b3989ba250bb" width="200">

**[2단계]** 그다음도 같은 작업을 계속한다. 6을 2로 나눈 나머지는 0이므로 0을 푸시하고, 3을 2로 나눈 나머지는 1이므로 1을 푸시한다.

<img src="https://github.com/user-attachments/assets/58f6afa1-99c6-48b3-8957-b35765374a23" width="550">

**[3단계]** 십진수 13을 몫이 0이 될 때까지 나눈 결과로 스택에는 1, 0, 1, 1이 쌓였다.

<img src="https://github.com/user-attachments/assets/c7c29256-d661-4e7f-95e3-ddaf47a1b9d0" width="210">

**[4단계]** 연산이 끝난 후 스택에서 팝한 값을 나열하면 13을 이진수로 변환한 1101이 된다.

<img src="https://github.com/user-attachments/assets/590d554c-4a54-4957-a483-d22c0b0c4e81" width="210">

지금까지 설명한 내용을 바탕으로 코드를 작성하면 다음과 같다.
```java
import java.util.Stack;

class Solution {
  public static String solution(int decimal) {
    Stack<Integer> stack = new Stack<>();

    while (decimal > 0) {
      int remainder = decimal % 2;
      stack.push(remainder);
      decimal /= 2;
    }

    // String의 + 연산은 시간 복잡도 측면에서 성능이 좋지 않음
    // 따라서 StringBuilder를 사용했음
    StringBuilder sb = new StringBuilder();
    while (!stack.isEmpty()) {
      sb.append(stack.pop());
    }

    return sb.toString();
  }
}
```

#### [시간 복잡도 분석하기]
N은 이진수로 변환할 숫자이다. N을 이진수로 변환하는 과정은 N이 1이 될 때까지 2로 계속 나누므로 연산 횟수는 O(logN)이다. String의 + 연산자는 수행할 때마다 객체를 새로 생성한다.
따라서 문자열의 길이가 계속 길어지는 반복문 내에서는 가급적 String의 + 연산보다는 StringBuilder를 사용하는 것이 바람직하다. StringBuilder를 사용한 코드의 시간 복잡도는 O(logN)이다.
만약 String + 연산을 사용한다면 O((logN)^2)이 된다.
- 이 문제는 다양한 풀이 방법이 있다. 자바의 toBinaryString() API를 사용할 수도 있고, 스택을 사용하지 않고도 풀 수 있다. 책에서 소개한 방법 외의 다른 풀이로도 풀어보자.