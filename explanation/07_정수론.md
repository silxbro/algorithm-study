# 정수론
<br/>

# 목차
1. [소수 구하기](#1-소수-구하기)
2. [오일러 피](#2-오일러-피)
3. [유클리드 호제법](#3-유클리드-호제법)
4. [확장된 유클리드 호제법](#4-확장된-유클리드-호제법)
<br/>

# 1. 소수 구하기
- **`소수(prime number)`** 는 **자신보다 작은 2개의 자연수를 곱해 만들 수 없는 1보다 큰 자연수**를 말한다. 이와 같은 의미로 **1과 자기 자신 외에 약수가 존재하지 않는
  수**를 말한다.<br/>
  코딩 테스트에서는 이러한 소수를 판별하는 방식을 묻는 소수 구하기 문제가 종종 출제된다.
## (1) 소수 구하기의 핵심 이론
### 대표적인 판별법 : 에라토스테네스의 체 원리
  1. 구하고자 하는 소수의 범위만큼 1차원 배열을 생성한다.
  2. 2부터 시작하고 현재 숫자가 지워지지 않을 때는 현재 선택된 숫자의 배수에 해당하는 수를 배열에서 끝까지 탐색하면서 지운다. 이때 처음으로 선택된 숫자는 지우지 않는다.
  3. 배열의 끝까지 ⅱ를 반복한 후 배열에서 남아 있는 모든 수를 출력한다.
  - #### 에라토스테네스의 체를 사용할 때 시간 복잡도는?
    - 일반적으로 에라토스테네스의 체를 구현하려면 이중 for문을 이용하므로 시간 복잡도가 O(N^2) 정도라고 판단할 수 있다. 하지만 실제 시간 복잡도는 최적화의 정도에 따라
      다르겠지만, 일반적으로 **`O(Nlog(logN))`** 이다. 그 이유는 **배수를 삭제하는 연산**으로 실제 구현에서 **바깥쪽 for문을 생략**하는 경우가 빈번하게 발생하기 때문이다.<br/>
      이러한 이유 때문에 에라토스테네스의 체 기법은 현재에도 코딩 테스트에서 소수를 구하는 일반적인 방법으로 통용되고 있다.
### [문제 037] : 소수 구하기 (2s)
  ### 문제
  - M 이상 N 이하의 소수를 모두 출력하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 자연수 M과 N이 빈칸을 사이에 두고 주어진다(1≤M≤N≤1,000,000). M 이상 N 이하의 소수가 1개 이상 있는 입력만 주어진다.
  ### 출력
  - 1줄에 1개씩 증가하는 순서대로 소수를 출력한다.
  ### 예제 입력1
  ```java
  3 16
  ```
  ### 예제 출력1
  ```java
  3
  5
  7
  11
  13
  ```
  ### [1단계] 문제 분석하기
  - 숫자 사이에 소수를 출력하는 문제이다. N의 최대 범위가 1,000,000이므로 일반적인 소수 구하기 방식으로 문제를 풀면 시간 초과가 발생한다. 따라서 앞에서 배운
    에라토스테네스 방법으로 문제를 풀어야 한다.
    - 일반적으로 소수를 찾을 때는 2 이상부터 자기 자신보다 작은 수로 나눴을 때 나머지가 0이 아닌 수를 찾는다.
  ### [2단계] 손으로 풀어보기
  1. 크기가 N+1인 배열을 선언한 후 값은 각각의 인덱스값으로 채운다.
  2. 1은 소수가 아니므로 삭제한다.
  3. 2부터 N의 제곱근까지 값을 탐색한다. 값이 인덱스값이면 그대로 두고, 그 값의 배수를 탐색해 0으로 변경한다.
  4. 배열에 남아 있는 수 중 M 이상 N 이하의 수를 모두 출력한다.
  - #### N의 제곱근까지만 탐색하는 이유
    - N이 a*b라고 가정했을 때, a와 b 모두 N의 제곱근보다 클 수 없다. 따라서 N의 제곱근까지만 확인해도 전체 범위의 소수를 판별할 수 있다.
  ### [3단계] 슈도코드 작성하기
  ```java
  M(시작 수) N(종료 수)
  A(소수 배열)
  for (N만큼 반복하기) {
    A 배열 초기화하기   // 각각의 인덱스값으로 초기화하기
  }
  for (N의 제곱근까지 반복하기) {
    소수가 아니면 넘어감
    for (소수의 배수 값을 N까지 반복하기) {
      이 수가 소수가 아니라는 것을 표시하기
    }
  }
  for (M ~ N까지 반복하기) {
    A 배열에서 소수인 값 출력하기
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam037_소수구하기](src/book/ch07/exam037_소수구하기.java)
### [문제 038] : 거의 소수 구하기 (2s)
  ### 문제
  - 어떤 수가 소수의 N 제곱(N≥2)일 때 이 수를 '거의 소수'라고 한다. A와 B가 주어질 때 A보다 크거나 같고, B보다 작거나 같은 거의 소수가 몇 개인지 출력하는 프로그램을
    작성하시오.
  ### 입력
  - 1번째 줄에 왼쪽 범위 A와 오른쪽 범위 B가 공백 한 칸을 사이에 두고 주어진다. A의 범위는 10^14보다 작거나 같은 자연수, B는 A보다 크거나 같고 10^14보다 작거나 같은 자연수다.
  ### 출력
  - 1번째 줄에 거의 소수가 총 몇 개 있는지 출력한다.
  ### 예제 입력1
  ```java
  1 1000   // A, B
  ```
  ### 예제 출력1
  ```java
  25
  ```
  ### [1단계] 문제 분석하기
  - 최대 범위에 해당하는 모든 소수를 구해 놓고, 이 소수들이 입력된 A와 B 사이에 존재하는지 판단해 문제를 해결할 수 있다. 입력에서 주어진 범위의 최댓값 10^14의 제곱근인
    10^7까지 소수를 탐색해야 한다. 에라토스테네스의 체를 이용해 빠르게 소수를 먼저 구한다. 그 이후에는 주어진 소수들이 A~B 범위 안에 존재하는지 판별해 유효한 소수의 개수를
    세면 이 문제를 해결할 수 있다.
  ### [2단계] 손으로 풀어보기
  1. 2 ~ 10,000,000 사이에 존재하는 모든 소수를 구한다.
  2. 각각의 소수에 관해 소수를 N제곱한 값이 B보다 커질 때까지 반복문을 실행한다. 이때 소수를 N제곱한 값이 A보다 크거나 같으면 거의 소수로 판단해 카운트한다.
     모든 소수에 관해서는 반복문을 실행한 후 카운트한 값을 출력한다.
     - N제곱한 값이 long 변수의 범위를 넘을 수 있어 **이항 정리**로 해결한다. <br/>
       이 부분을 실제 구현하면 N제곱한 값을 구하는 도중 값의 범위가 long형을 초과하는 경우가 발생한다. 따라서 계산 오류를 방지하려면 N^k과 B 값이 아니라 N과 B/N^(k-1)을
       비교하는 형식으로 식을 적절하게 정리해야 한다.   
  ### [3단계] 슈도코드 작성하기
  ```java
  Min(시작 수) Max(종료 수)
  A(소수 배열)
  for(2~10000000) {       // 10^14의 제곱근인 10^7까지 반복하기
    A 배열 초기화하기     // 각각의 인덱스값으로 초기화하기
  }
  for (10000000의 제곱근까지 반복하기) {
    소수가 아니면 넘어감
    for(소수의 배숫값을 10000000까지 반복하기) {
      이 수가 소수가 아니라는 것을 표시하기
    }
  }
  for (2~10000000) {
    A 배열에서 소수인 값일 때
    temp = 현재 소수
    // 현재 소수의 제곱근이 Max보다 작을 때를 기준으로 하지만
    // 곱셈이 long의 범위를 넘어갈 수 있어 이항 정리로 처리하기
    while (현재 소수 <= Max/temp) {
      if (현재 소수 >= Min/temp) 정답값 증가
      temp = temp * 현재 소수
    }
  }
  정답 출력하기
  ```
  ### [4단계] 코드 구현하기
  - [exam038_거의소수](src/book/ch07/exam038_거의소수.java)
### [문제 039] : 소수 & 팰린드롬 수 중에서 최솟값 찾기 (2s)
  ### 문제
  - 어떤 수와 그 수의 숫자 순서를 뒤집은 수가 일치하는 수를 '팰린드롬'이라 부른다. 예를 들어 79197과 324423 등이 팰린드롬 수다. 어떤 수 N(1≤N≤1,000,000)이 주어졌을 때
    N보다 크거나 같고 소수이면서 팰린드롬인 수 중 가장 작은 수를 구하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 N이 주어진다.
  ### 출력
  - 1번째 줄에 조건을 만족하는 수를 출력한다.
  ### 예제 입력1
  ```java
  31   // N
  ```
  ### 예제 출력1
  ```java
  101
  ```
  ### [1단계] 문제 분석하기
  - 에라토스테네스의 체를 이용해 최대 범위에 해당하는 모든 소수를 구해 놓은 후 이 소수들의 집합에서 N보다 크거나 같으면서 팰린드롬 수인 것을 찾아내면 되는 문제이다.
    앞에서 배웠던 두 문제와 매우 비슷하므로 답을 쉽게 구할 수 있다. 단, 팰린드롬 수를 판별할 때 Integer값의 적절한 형 변환을 이용해 좀 더 쉽게 구할 수 있는 로직이
    문제를 해결하는 데 도움이 된다.
  ### [2단계] 손으로 풀어보기
  1. 2~1,000,000 사이에 존재하는 모든 소수를 구한다. 그중 N보다 크거나 같은 소수에서 팰린드롬 수인지를 판별한다.
  2. 소수의 값을 char 배열 형태로 변환한 후 양끝의 투 포인터를 비교하면 쉽게 팰린드롬 수인지 판별할 수 있다. 배열의 처음과 끝을 가리키는 포인터(S,E)를 부여해 두 값을
     비교한다. 두 값이 같으면 S++, E-- 연산으로 두 포인터를 이동한다. S<E를 만족할 때까지 반복해 모든 값이 같으면 팰린드롬 수로 판별한다.
  3. 오름차순으로 과정 2를 실행하다가 최초로 팰린드롬 수가 나오면 프로그램을 종료한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(어떤 수)
  A(소수 배열)
  for (2 ~ 10000001) {
    A 배열 초기화    // 인덱스를 자기 값으로 초기화하기
  }
  for (A 배열 길이의 제곱근까지 반복하기) {
    소수가 아니면 넘어감
    for (소수의 배수 값을 10000001까지 반복하기) {
      이 수가 소수가 아니라는 것을 표시하기
    }
  }
  while (true) {
    N부터 값을 1씩 증가시키면서 해당 값이 소수이면서 팰린드롬 수인지 판별하기
    맞으면 반복문 종료하기
  }
  // 팰린드롬 판별 함수 구현하기
  Integer값을 char 배열로 변환하기
  s(시작 인덱스), e(종료 인덱스)
  while (s<e) {
    만약 시작과 끝 인덱스에 해당하는 값이 다르면 return false;
    s++; e--;
    반복문을 다 돌았으면 return true;
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam039_소수팰린드롬](src/book/ch07/exam039_소수팰린드롬.java)
### [문제 040] : 제곱이 아닌 수 찾기 (2s)
  ### 문제
  - 어떤 수 X가 1보다 큰 제곱수로 나누어떨어지지 않을 때 이 수를 '제곱이 아닌 수'라고 가정해 보자. 여기서 제곱수는 정수의 제곱이다. min과 max의 값이 주어질 때
    min보다 크고, max보다 작은 값 중 '제곱이 아닌 수'가 몇 개 있는지 출력하시오.
  ### 입력
  - 1번째 줄에 두 정수 min과 max가 주어진다.
  ### 출력
  - 1번째 줄에 [min, max] 구간에 제곱이 아닌 수가 몇 개인지 출력한다.
    (1≤min≤1,000,000,000,000, min≤max≤min+1,000,000)
  ### 예제 입력1
  ```java
  1 10     // min max
  ```
  ### 예제 출력1
  ```java
  7
  ```
  ### [1단계] 문제 분석하기
  - 언뜻 보면 min의 최댓값이 1,000,000,000,000으로 매우 큰 것 같지만 실제로는 min과 max 사이의 수들 안에서 구하는 것이므로 1,000,000의 데이터만 확인하면 된다.
    제곱수 판별을 일반적인 반복문으로 구하면 시간 초과가 발생하므로 에라토스테네스의 체 알고리즘 방식을 제곱수 판별 로직에 적용해 문제를 해결해보자.
  ### [2단계] 손으로 풀어보기
  1. 2의 제곱수인 4부터 max값까지 제곱수를 찾는다.
  2. 탐색한 배열에서 제곱수로 확인되지 않은 수의 개수를 센 후 출력한다.
  - 데이터를 순차적으로 탐색하는 것이 아니라 에라토스테네스의 체 방식으로 제곱수의 배수 형태로 탐색해 시간 복잡도를 최소화하는 것이 이 문제 풀이의 핵심이다.
  ### [3단계] 슈도코드 작성하기
  ```java
  Min(최솟값) Max(최댓값)
  Check(Min~Max 사이에 제곱수 판별 배열)
  for (i = 2 ~ Max 사이 반복, i*i 증가) {        // 단순 탐색이 아닌 제곱수 형태로 증가
    pow (제곱수)
    start_index (최솟값/제곱수)
    for (j = start_index ~ Max 사이 반복하기) {  // 제곱수의 배수 형태로 탐색하기
      j*pow가 Max보다 작을 때 최솟값, 최댓값 사이의 제곱수이므로
      Check 배열에 저장하기
    }
  }
  count(제곱이 아닌 수 카운트)
  for (0 ~ Max-Min) {
    Check 배열에서 제곱이 아닌 수라면 count 증가
  }
  count 출력하기
  ```
  ### [4단계] 코드 구현하기
  - [exam040_제곱이아닌수](src/book/ch07/exam040_제곱이아닌수.java)

# 2. 오일러 피
- 오일러 피 함수 P[N]의 정의는 **1부터 N까지 범위에서 N과 서로소인 자연수의 개수**를 뜻한다. 오일러 피 함수는 증명 과정을 공부해야 완벽하게 알 수 있지만 실제
  코딩 테스트에 사용하기 위한 구현 부분만 알아본다.
## (1) 오일러 피의 핵심 이론
오일러 피 함수의 원리는 에라토스테네스의 체와 비슷하다.
### [오일러 피 함수의 원리]
1. 구하고자 하는 오일러 피의 범위만큼 배열을 초기화한다.
2. 2부터 시작해 현재 배열의 값과 인덱스가 같으면(=소수일 때) 현재 선택된 숫자(K)의 배수에 해당하는 수를 배열에 끝까지 탐색하며 **`P[i] = P[i] - P[i]/K`** 연산을
   수행한다.(i는 K의 배수)
3. 배열의 끝까지 2를 반복하여 오일러 피 함수를 완성한다.
### [수학적으로 오일러 피 함수 이해하기]
    * 초기 상태 : ∮(6) = 6 → 서로소가 될 수 있는 후보의 개수로 초기화 (1,2,3,4,5,6)
    * 2의 배수로 인한 후보 탈락 : ∮(6) = 6 - 6 / 2 = 3 (1,3,5)
    * 3의 배수로 인한 후보 탈락 : ∮(6) = 3 - 3 / 3 = 2 (1,5)
- 이때 후보에서 삭제하는 기준을 6이 아닌 업데이트된 3으로 진행하는 이유는 3의 배수 중 2의 배수인 수들은, 즉 3과 2의 공배수는 2의 배수에서 이미 삭제됐기 때문에
  중복 삭제를 막기 위함이다. 이 예시의 경우 6(3과 2의 공배수)을 중복 삭제하지 않기 위함이다.<br/>
  최종적으로 ∮(6) = 2가 된다. 이때 2의 의미는 6이 6 이하의 숫자들 중 서로소가 되는 개수가 2개(1,5)라는 뜻이 된다.
### [문제 041] : 오일러 피 함수 구현하기 (1s)
  ### 문제
  - 자연수 n이 주어졌을 때 GCD(n,k) = 1(1≤k≤n)을 만족하는 자연수의 개수를 구하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 자연수 n(1≤n≤10^12)이 주어진다.
  ### 출력
  - GCD(n,k) = 1(1≤k≤n)을 만족하는 자연수의 개수를 출력한다.
  ### 예제 입력1
  ```java
  1    // n
  ```
  ### 예제 출력1
  ```java
  1
  ```
  ### 예제 입력2
  ```java
  5
  ```
  ### 예제 출력2
  ```java
  4
  ```
  ### 예제 입력3
  ```java
  10
  ```
  ### 예제 출력3
  ```java
  4
  ```
  ### 예제 입력4
  ```java
  45
  ```
  ### 예제 출력4
  ```java
  24
  ```
  ### 예제 입력5
  ```java
  99
  ```
  ### 예제 출력5
  ```java
  60
  ```
  ### [1단계] 문제 분석하기
  - 문제에서 요구하는 GCD(n,k)=1을 만족하는 자연수의 개수가 바로 오일러 피 함수의 정의이다. 즉, 오일러 피 함수를 잘 구현할 수 있는지 묻는 문제이다.
  ### [2단계] 손으로 풀어보기
  1. 서로소의 개수를 표현하는 변수 result와 현재 소인수 구성을 표시하는 변수 n을 선언한다. 예제 입력 1의 경우 변수 초기화는 n=45, result=45로 초기화한다.
  2. 오일러 피 핵심 이론 부분을 참고해 2~N의 제곱근까지 탐색하면서 소인수일 때 result = result - (result/소인수) 연산으로 result값을 업데이트한다.
     이때 n에서 이 소인수는 나누기 연산으로 삭제한다.
     ```
       * P(현재 수) 2 ⇒ n(45) % P(2) != 0 ⇒ 소인수가 아님
       * P(현재 수) 3 ⇒ n(45) % P(3) == 0 ⇒ 소인수이므로 값 업데이트
         ⇒ result = 45 - 45/3 = 30
         ⇒ n = 3^3 * 5 ⇒ 5로 업데이트
       * P(현재 수) = 4 ⇒ 현재 n(5)의 제곱근보다 4가 크므로 반복문 종료
     ```
  4. 반복문 종료 후 현재 n이 1보다 크면 n이 마지막 소인수라는 뜻이다. result = result - (result/n) 연산으로 result 값을 마지막으로 업데이트한 후 출력한다.
     ```
       ∴ result(30) = 30 - 30/5 = 24
     ```
  ### [3단계] 슈도코드 작성하기
  ```java
  n(소인수 표현) result(결괏값)
  for (2 ~ n의 제곱근) {
    if (현재 값이 소인수라면) {
      결괏값 = 결괏값 - 결괏값 / 현재값
      n에서 현재 소인수 내역을 제거하기
    }
  }
  if (n > 1) {    // n이 마지막 소인수일 때 ---> ** 이해가 어려운 부분
    결괏값 = 결괏값 - 결괏값 / n
  }
  결괏값 출력하기
  ```
  ### [4단계] 코드 구현하기
  - [exam041_GCDNK1](src/book/ch07/exam041_GCDNK1.java)

# 3. 유클리드 호제법
- **`유클리드 호제법(euclidean-algorithm)`** 은 **두 수의 최대 공약수**를 구하는 알고리즘이다. 일반적으로 최대 공약수를 구하는 방법은 소인수분해를 이용한 공통된
  소수들의 곱으로 표현할 수 있지만 유클리드 호제법은 좀 더 간단한 방법을 제시한다.
## (1) 유클리드 호제법의 핵심 이론
- 유클리드 호제법을 수행하려면 먼저 MOD 연산을 이해하고 있어야 한다. MOD 연산이 최대 공약수를 구하는 데 사용하는 핵심 연산이기 때문이다.
  
  |연산|기능|예제|
  |:---|:---|:---|
  |MOD|두 값을 나눈 나머지를 구하는 연산|10 MOD 4 = 2  // 10 % 4 = 2|

  MOD 연산을 이해하면 다음과 같은 3단계로 유클리드 호제법을 구현할 수 있다.
  ### [MOD 연산으로 구현하는 유클리드 호제법]
  1. 큰 수를 작은 수로 나누는 MOD 연산을 수행한다.
  2. 앞 단계에서의 작은 수와 MOD 연산 결괏값(나머지)으로 MOD 연산을 수행한다.
  3. 나머지가 0이 되는 순간의 작은 수를 최대 공약수로 선택한다.
### [문제 042] : 최소 공배수 구하기 (1s)
  ### 문제
  - 자연수 A와 B가 있을 때 A의 배수이면서 B의 배수인 자연수를 A와 B의 공배수라고 한다. 이런 공배수 중 가장 작은 수를 최소 공배수라고 한다. 예를 들어 6과 15의 공배수는
    30,60,90이 있으며, 최소 공배수는 30이다. 두 자연수 A와 B가 주어졌을 때 A와 B의 최소 공배수를 구하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 테스트 케이스의 개수 T(1≤T≤1,000), 2번째 줄부터 T개의 줄에 걸쳐 A와 B가 주어진다.(1≤A,B≤45,000)
  ### 출력
  - 1번째 줄부터 T개의 줄에 A와 B의 최소 공배수를 입력받은 순서대로 1줄에 1개씩 출력한다.
  ### 예제 입력1
  ```java
  3    // 테스트 케이스 개수
  1 45000   // A,B
  6 10
  13 17
  ```
  ### 예제 출력1
  ```java
  45000
  30
  221
  ```
  ### [1단계] 문제 분석하기
  - 최소 공배수는 A와 B가 주어졌을 때 **`A * B / 최대 공약수`** 를 계산해 구할 수 있다. 결국 이 문제는 유클리드 호제법을 이용해 최대 공약수를 구한 후 두 수의 곱에서
    최대 공약수를 나눠 주는 것으로 해결할 수 있다.
  ### [2단계] 손으로 풀어보기
  1. 유클리드 호제법을 이용해 A,B의 최대 공약수를 구한다.
  2. 두 수의 곱을 최대 공약수로 나눈 값을 정답으로 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  t(테스트 케이스)
  for (t만큼 반복하기) {
    a(1번째 수) b(2번째 수)
    결괏값 = a * b / gcd(a,b)
    결괏값 출력하기
  }
  // 최대 공약수 gcd() 함수 구현하기
  if (b가 0이면) a가 최대 공약수
  else gcd(작은 수, 큰 수 % 작은 수)    // 재귀 함수 형태로 구현하기
  ```
  ### [4단계] 코드 구현하기
  - [exam042_최소공배수](src/book/ch07/exam042_최소공배수.java)
### [문제 043] : 최대 공약수 구하기 (2s)
  ### 문제
  - 모든 자리가 1로만 이뤄진 두 자연수 A와 B가 주어져 있다. 이때 A와 B의 최대 공약수를 구하는 프로그램을 작성하시오. 예를 들어 A가 111이고, B가 1111일 때 A와 B의
    최대 공약수는 1이다. A가 111이고, B가 111111일 경우에는 최대 공약수가 111이다.
  ### 입력
  - 1번째 줄에 두 자연수 A와 B를 이루는 1의 개수가 주어진다. 입력되는 수는 263보다 작은 자연수다.
  ### 출력
  - 1번째 줄에 A와 B의 최대 공약수를 출력한다. 정답은 1,000만 자리를 넘지 않는다.
  ### 예제 입력1
  ```java
  3 4    // A와 B의 길이
  ```
  ### 예제 출력1
  ```java
  1
  ```
  ### 예제 입력2
  ```java
  3 6
  ```
  ### 예제 출력2
  ```java
  111
  ```
  ### 예제 입력3
  ```java
  500000000000000000
  500000000000000002
  ```
  ### 예제 출력3
  ```java
  11
  ```
  ### [1단계] 문제 분석하기
  - 예제 입력 3과 같이 입력값이 크면 단순한 방법으로 최소 공배수를 찾을 수 없다. 하지만 주어진 예제를 바탕으로 다음 규칙을 찾을 수 있다.
    ##### [예제의 규칙]
    - 수의 길이를 나타내는 두 수의 최대 공약수는 A와 B의 최대 공약수의 길이를 나타낸다.
  ### [2단계] 손으로 풀어보기
  1. 유클리드 호제법을 이용해 주어진 A,B의 최대 공약수를 구한다.
  2. 공약수의 길이만큼 1을 반복해 출력한다. 일반적인 출력을 수행하면 시간 초과가 발생할 수 있으므로 BufferedWriter를 사용한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  a(1번째 수)
  b(2번째 수)
  결괏값 = gcd(a,b)
  결괏값만큼 1을 반복해 출력하기  // 출력 횟수가 많기 때문에 BufferedWriter 사용
  // 최대 공약수 gcd() 함수 구현하기
  if (b가 0이면) a가 최대 공약수
  else {
    // 재귀 함수 형태로 구현하기
    gcd(작은 수, 큰 수 % 작은 수)
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam043_최대공약수](src/book/ch07/exam043_최대공약수.java)
### [문제 044] : 칵테일 만들기 (2s)
  ### 문제
  - august14는 세상에서 가장 맛있는 칵테일이다. 이 칵테일을 만드는 정확한 방법은 아직 세상에 공개되지 않았지만, 들어가는 재료 N개는 공개돼 있다. 경근이는 인터넷 검색으로
    재료 쌍 N-1개의 비율을 알아냈고, 이 비율을 이용하면 칵테일에 들어가는 전체 재료의 비율을 알아낼 수 있다. 총 재료 쌍 N-1개의 비율이 입력으로 주어질 때 다음 조건을
    만족하는 칵테일을 만드는 데 필요한 각 재료의 양을 구하는 프로그램을 작성하시오.
    - 필요한 재료의 질량을 모두 더한 값이 최소가 되어야 한다.
    - 칵테일을 만드는 재료의 양은 정수이고, 총 질량은 0보다 커야 한다.
    - 비율은 'a b p q'와 같은 형식으로 주어지는데, a번 재료의 질량을 b번 재료의 질량으로 나눈 값이 p/q라는 뜻이다.
  ### 입력
  - 1번째 줄에 august14를 만드는 데 필요한 재료의 개수 N이 주어지고, N은 10보다 작거나 같은 자연수다.<br/> 2번째 줄부터 N-1개의 줄에는 재료 쌍의 비율이 1줄에 1개씩 주어지는데,
    문제 설명에 나온 형식인 'a b p q'로 주어진다. 재료는 0번부터 N-1까지이고, a와 b는 모두 N-1보다 작거나 같은 자연수 또는 0이다. p와 q는 9보다 작거나 같은 자연수다.
  ### 출력
  - 1번째 줄에 칵테일을 만드는 데 필요한 각 재료의 질량을 0번 재료부터 순서대로 공백으로 구분해 출력한다.
  ### 예제 입력1
  ```java
  5   // 재료 개수
  4 0 1 1
  4 1 3 1
  4 2 5 1
  4 3 7 1
  ```
  ### 예제 출력1
  ```java
  105 35 21 15 105
  ```
  ### [1단계] 문제 분석하기
  - 문제에서는 N-1개의 비율로 N개의 재료와 관련된 전체 비율을 알아낼 수 있다고 했다. 이것을 그래프 관점으로 생각하면 **사이클이 없는 트리 구조**로 이해할 수 있다.
    이 내용을 바탕으로 임의의 노드에서 **DFS**를 진행하면서 정답을 찾으면 된다. DFS 과정에서 유클리드 호제법을 사용해 비율들의 최소 공배수와 최대 공약수를 구하고,
    재료의 최소 질량을 구하는 데 사용해 문제를 해결해보자.
  ### [2단계] 손으로 풀어보기
  1. 인접 리스트를 이용해 각 재료의 비율 자료를 그래프로 구현한다.
  2. 데이터를 저장할 때마다 비율과 관련된 수들의 최소 공배수를 업데이트한다.
  3. 임의의 시작점에 최대 공배수 값을 저장한다.
  4. 임의의 시작점에서 DFS로 탐색을 수행하면서 각 노드의 값을 이전 노드의 값과의 비율 계산을 통해 계산하고 저장한다.
  5. 각 노드의 값을 모든 노드의 최대 공약수로 나눈 뒤 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  A(인접 리스트) lcm(최소 공배수)
  D(각 노드값 저장 배열) visited(DFS를 탐색할 때 탐색 여부 저장 배열)
  변수 초기화 수행하기
  for (에지 개수) {
    인접 리스트 배열에 이 에지 정보를 저장하기
    최소 공배수 업데이트하기
  }
  0번 노드에 최소 공배수 저장하기
  0번에서 DFS 탐색 수행하기
  DFS를 이용해 업데이트된 D 배열의 값들의 최대 공약수 계산하기
  D 배열의 각 값들을 최대 공약수로 나눠 정답 출력하기
  // 최대 공약수 gcd 함수 구현하기
  if (b가 0이면) a가 최대 공약수
  else {
    // 재귀 함수 형태로 구현하기
    gcd(작은 수, 큰 수 % 작은 수)
  }
  // 탐색 함수 구현하기
  DFS {
    visited 배열에 현재 노드 방문 기록하기
    현재 노드의 연결 노드 중 방문하지 않은 노드로
    다음 노드의 값 = 현재 노드의 값 * 비율 로 저장하기
    DFS 실행하기 (재귀 형태)
  }
  // 노드 클래스 선언하기
  c 노드 {
    다음 노드, 비율1, 비율2
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam044_칵테일](src/book/ch07/exam044_칵테일.java)

# 4. 확장된 유클리드 호제법
- 유클리드 호제법의 목적이 두 수의 최대 공약수를 구하는 것이라면 확장 유클리드 호제법의 목적은 **방정식의 해를 구하는 것**이다.<br/>
  확장 유클리드 호제법을 제대로 이해하려면 수학 증명 과정까지 공부해야 하지만 여기서는 확장 유클리드 호제법 관련 문제를 풀기 위한 알고리즘만 설명한다.
## (1) 확장 유클리드 호제법의 핵심 이론
- 확장 유클리드 호제법에서 해를 구하고자 하는 방정식은 다음과 같다.
  ### [해를 구하고자 하는 방정식]
  ```
  ax + by = c (a,b,c,x,y는 정수)
  ```
  이때 위 방정식은 **`c % gcd(a,b) = 0`**인 경우에만 정수해를 가진다. 다시 말해 **c가 a와 b의 최대 공약수의 배수인 경우**에만 정수해를 가진다.<br/>
  이는 ax + by = c가 정수해를 갖게 하는 c의 최솟값이 gcd(a,b)라는 것을 의미한다. 이 내용을 숙지한 후 **재귀 함수**를 사용하여 확장 유클리드 호제법을 구현하도록 한다.
  ### [확장 유클리드 호제법의 원리 이해하기]
    #### 5x + 9y = 2일 때 이 식을 만족하는 정수 x,y를 구해보자.
  1. 우선 5x + 9y가 정수해를 갖게 하는 c의 최솟값이 gcd(5,9)라는 것을 적용하여 식을 다시 놓는다. gcd(5,9) = 1이므로 5x + 9y = 1로 식을 다시 놓고 다음 단계를 진행한다.
  2. a,b로 유클리드 호제법을 반복 실행하여 몫, 나머지를 저장한다. 반복은 나머지가 0이 되면 중단한다.
   
     |유클리드 호제법 실행|나머지|몫|
     |:---|:---:|:---:|
     |5 % 9 = 5|5|&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;|
     |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9 % 5 = 4|4|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
     |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5 % 4 = 1|1|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
     |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 % 1 = 0|0|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
  3. 반복적으로 구한 나머지와 몫을 이용하여 거꾸로 올라가며 **`x = y', y = x' - y' * q`** 를 계산한다. x'는 이전 x, y'는 이전 y를 의미하고, q는 현재 보고 있는 몫을
     의미한다. 이때 처음 시작하는 x,y는 이전 x와 이전 y가 없으므로 각각 1,0으로 지정하여 역계산을 진행한다.

     |나머지|몫|`x=y', y=x'-y'*q` 역순 계산|계산 방향|
     |:---:|:---:|:---|:---:|
     |5|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|X = 2, Y = -1 - (2*0) = -1||
     |4|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|X = -1, Y = 1 - (-1*1) = 2|↑|
     |1|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|X = 1, Y = 0 - 1*1 = -1|↑|
     |0|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|X = 0, Y = 1 - 0*4 = 1|↑|
  4. 이렇게 재귀 방식으로 알아낸 최종 x,y는 ax + by = gcd(a,b)를 만족한다. 그리고 c / gcd(a,b) = K를 가정하면 최초 방정식의 해는 Kx, Ky로 간단히 구할 수 있다.<br/>
     과정 ⅲ에서 찾은 x는 2, y는 -1이므로 2/1 = 2이며, 2*2, 2*(-1)에 의해 최초 방정식의 해는 4, -2가 된다.

  - #### 오른쪽 변의 값이 gcd(a,b)의 배수가 아니라면?
    위 예제에서 만약 오른쪽 변의 값이 gcd(A,B)의 배수의 형태가 아니라면 어떻게 X,Y의 값을 도출할 수 있을까? 결론적으로 이 경우를 만족하는 X,Y 값은 **정수 범위에서
    존재하지 않는다.**<br/>
    따라서 확장 유클리드 호제법을 구현할 때 먼저 오른쪽 변의 값이 gcd(A,B)의 배수라는 조건을 만족하는지 먼저 판단해야 한다. 만약 조건에 만족하지 않는다면 이후 프로그램을
    수행하지 않고 불가능을 표현하는 값을 출력하면 된다.<br/>
    또한 이미 눈치챘겠지만, 유클리드 호제법의 구조 자체가 특정한 값을 업데이트시키면서 같은 로직을 반복적으로 수행하므로 **`재귀 함수`** 의 형태로 구현한다.
### [문제 045] : Ax + By = C (1s)
  ### 문제
  - A,B,C가 주어졌을 때 Ax + By = C를 만족하면서 다음 조건을 만족하는 (x,y) 쌍을 찾으시오.
    - x,y는 정수
    - 1,000,000,000 ≤ x,y ≤ 1,000,000,000
  ### 입력
  - 1번째 줄에 정수 A,B,C가 주어진다.
  ### 출력
  - Ax + By = C를 만족하는 x,y를 공백으로 구분해 출력한다. 문제의 조건을 만족하는 (x,y)가 존재하지 않을 때는 -1을 출력한다.
  ### 예제 입력1
  ```java
  1 2 3  // A B C
  ```
  ### 예제 출력1
  ```java
  3 0
  ```
  ### 예제 입력2
  ```java
  3 4 5
  ```
  ### 예제 출력2
  ```java
  -5 5
  ```
  ### 예제 입력3
  ```java
  6 8 3
  ```
  ### 예제 출력3
  ```java
  -1
  ```
  ### [1단계] 문제 분석하기
  - 앞에서 배운 '확장 유클리드 호제법'을 그대로 구현하면 되는 문제이다.
  ### [2단계] 손으로 풀어보기
  1. C의 값이 A와 B의 최대 공약수의 배수 형태인지 확인한다. 최대 공약수의 배수 형태라면 C의 값을 최대 공약수로 변경한다. <br/>
     최대 공약수의 배수 형태가 아니라면 -1을 출력한 후 프로그램을 종료한다.
  2. A와 B에 관해 나머지가 0이 나올 때까지 유클리드 호제법을 수행한다.
  3. 나머지가 0이 나오면 x = 1, y = 0으로 설정한 후 과정 2에서 구한 몫들을 식(x=y', y=x'-y'*몫)에 대입하면서 역순으로 계산한다.
  4. 최종으로 계산된 x,y 값에 C를 x와 y의 최대 공약수로 나눈 값을 각각 곱해 방정식의 해를 구한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  a(1번째 수) b(2번째 수) c(3번째 수)
  최대 공약수 = gcd(a,b)
  if (c가 최대 공약수의 배수가 아니면) -1 출력하기
  else {
    나머지(b)가 0이 될 때까지 재귀 함수를 호출하는 유클리드 호제법 함수 호출하기
    결괏값에 c/최대 공약수의 값을 곱한 후 해당 값을 출력하기
  }
  // 유클리드 호제법 함수 구현하기
  Execute(a,b) {
    if (b == 0) 재귀 함수를 중단하고 return
    Execute(b, a % b)   // 호제법 함수 호출하기(재귀 함수 형태)
    x = y', y = x' - y'*몫을 계산하는 역산 로직 구현하기
    // 재귀에서 빠져나오는 영역에서 실행하면 자연스럽게 역순이 됨
  }
  // 최대 공약수 gcd 함수 구현하기
  if (b가 0이면) a가 최대 공약수
  else {
    // 재귀 함수 형태로 구현하기
    gcd(작은 수, 큰 수 % 작은 수)
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam045_AxByC](src/book/ch07/exam045_AxByC.java)
