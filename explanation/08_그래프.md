# 그래프
<br/>

# 목차
1. [그래프의 표현](#1-그래프의-표현)
2. [유니온 파인드](#2-유니온-파인드)
3. [위상 정렬](#3-위상-정렬)
4. [다익스트라](#4-다익스트라)
5. [벨만-포드](#5-벨만-포드)
6. [플로이드-워셜](#6-플로이드-워셜)
7. [최소 신장 트리](#7-최소-신장-트리)
<br/>

# 1. 그래프의 표현
## (1) 에지 리스트
- **`에지 리스트(edge list)`** 는 에지를 중심으로 그래프를 표현한다.<br/> 에지 리스트는 배열에 **출발 노드, 도착 노드**를 저장하여 에지를 표현한다.
  또는 **출발 노드, 도착 노드, 가중치**를 저장하여 **가중치**가 있는 에지를 표현한다.
  #### [에지 리스트로 가중치 없는 그래프 표현하기]
  - 가중치가 없는 그래프는 출발 노드와 도착 노드만 표현하므로 배열의 행은 **2개**면 충분하다. 노드는 여러 자료형을 사용할 수 있다. 또한, 방향이 있는 그래프는 순서에 맞게
    노드를 배열에 저장하는 방식으로 표현한다. 그리고 노드를 배열에 저장하여 에지를 표현하므로 에지 리스트라 한다.
  #### [에지 리스트로 가중치 있는 그래프 표현하기]
  - 가중치가 있는 그래프는 행을 3개로 늘려 3번째 행에 가중치를 저장한다.
  
- 에지 리스트는 구현하기 쉽다. 하지만 **특정 노드와 관련되어 있는 에지를 탐색하기는 쉽지 않다.**
  - 벨만 포드나 크루스칼(MST) 알고리즘에 사용하며, 노드 중심 알고리즘에서는 잘 사용하지 않는다.
 
## (2) 인접 행렬
- **`인접 행렬(adjacency matrix)`** 은 2차원 배열을 자료구조로 이용하여 그래프를 표현한다. 인접 행렬은 에지 리스트와 다르게 **노드 중심으로 그래프를 표현**한다.
  #### [인접 행렬로 가중치 없는 그래프 표현하기]
  - a에서 b를 향하는 에지를 인접 행렬은 a행 b열에 **1을 저장**하는 방식으로 표현한다. 1을 저장하는 이유는 **가중치가 없기 때문**이다.
    a에서 b로 향하는 에지가 있다는 표시를 노드 중심으로 한다고 볼 수 있다.
  #### [인접 행렬로 가중치 있는 그래프 표현하기]
  - a에서 b를 향하는 에지의 가중치를 a행 b열에 기록한다.
    
- 인접 행렬을 이용한 그래프 구현은 쉽다. 두 노드를 연결하는 에지의 여부와 가중치값은 배열에 직접 접근하면 바로 확인할 수 있는 것도 장점이다.<br/>
  하지만 노드와 관련되어 있는 에지를 탐색하려면 N번 접근해야 하므로 **노드 개수에 비해 에지가 적을 때는 공간 효율성이 떨어진다.** 또한 노드 개수가 많은 경우 아예
  2차원 배열 선언 자체를 할 수 없는 결함도 있다.<br/>
  따라서 인접 행렬은 **노드 개수**에 따라 사용 여부를 적절하게 판단하는 능력도 필요하다. 예를 들어 노드가 3만 개가 넘으면 `자바 힙 스페이스(java heap space) 에러` 가 발생한다.

## (3) 인접 리스트
- **`인접 리스트(adjacency list)`** 는 **ArrayList**로 그래프를 표현한다. 노드 개수만큼 ArrayList를 선언하며, 자료형은 경우에 맞게 사용한다.
  #### [인접 리스트로 가중치 없는 그래프 표현하기]
  - 인접 리스트에는 N번 노드와 연결되어 있는 노드를 배열의 위치 N에 연결된 노드 개수만큼 배열을 연결하는 방식으로 표현한다.
  #### [인접 리스트로 가중치 있는 그래프 표현하기]
  - 가중치가 있는 경우 자료형을 **`클래스`** 로 사용한다.<br/>
    * ex: (도착 노드, 가중치)를 갖는 Node 클래스를 선언하여 ArrayList에 사용
- 인접 리스트를 이용한 그래프 구현은 그래프를 구현하는 다른 방법에 비해 복잡한 편이다.<br/>
  하지만 노드와 연결되어 있는 **에지를 탐색하는 시간이 매우 뛰어나며**, 노드 개수가 커도 **공간 효율이 좋아** 메모리 초과 에러도 발생하지 않는다.
  이러한 이유로 실제 코딩 테스트에서는 인접 리스트를 이용한 그래프 구현을 선호한다.


### [문제 046] : 특정 거리의 도시 찾기 (2s)
  ### 문제
  - 1번부터 N번까지의 도시와 M개의 단방향 도로가 존재하고, 모든 도로의 거리는 1인 도시가 있다. 도시 X로부터 출발해 도달할 수 있는 모든 도시 중 최단 거리가 정확히 K인
    모든 도시들의 번호를 출력하시오.(출발 도시 X에서 출발 도시 X로 가는 최단 거리는 항상 0이다)
  ### 입력
  - 1번째 줄에 도시의 개수(N), 도로의 개수(M), 거리 정보(K), 출발 도시의 번호(X)가 입력된다(2≤N≤300,000, 1≤M≤1,000,000, 1≤K≤300,000, 1≤X≤N). 이후 M개의 줄에 걸쳐
    2개의 자연수 A,B가 공백으로 구분돼 주어진다. A번 도시에서 B번 도시로 이동하는 단방향 도로가 존재한다는 뜻이다(1≤A,B≤N). 단 A와 B는 같을 수 없다.
  ### 출력
  - X로부터 출발해 도달 가능한 도시 중 최단 거리가 K인 모든 도시의 번호를 1줄에 1개씩 오름차순으로 출력한다. 해당하는 도시가 1개도 존재하지 않으면 -1을 출력한다.
  ### 예제 입력1
  ```java
  4 4 2 1   // 도시 개수, 도로 개수, 거리 정보, 출발 도시 번호
  1 2
  1 3
  2 3
  2 4
  ```
  ### 예제 출력1
  ```java
  4
  ```
  ### 예제 입력2
  ```java
  4 3 2 1
  1 2
  1 3
  1 4
  ```
  ### 예제 출력2
  ```java
  -1
  ```
  ### [1단계] 문제 분석하기
  - 모든 도로의 거리가 1이므로 가중치가 없는 인접 리스트로 이 그래프를 표현할 수 있다. 도시의 개수가 300,000, 도로의 최대 크기가 1,000,000이므로 BFS 탐색을 수행하면
    이 문제를 시간 복잡도 안에서 해결할 수 있다.
  ### [2단계] 손으로 풀어보기
  1. 인접 리스트로 도시와 도로 데이터의 그래프를 구현한다.
  2. BFS 탐색 알고리즘으로 탐색을 수행하면서 각 도시로 가는 최단 거릿값을 방문 배열에 저장한다.
     최초 방문 도시이 경우, 이동하지 않았으므로 방문 배열에 0을 저장한다. 이후 방문하는 도시는 이전 도시의 방문 배열값 + 1을 방문 배열에 저장하는 방식으로 이동 거리를
     저장한다.
  3. 탐색 종료 후 방문 배열에 값이 K와 같은 도시의 번호를 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(노드 개수) M(에지 개수) K(목표 거리) X(출발 도시)
  answer(정답 리스트)
  A(그래프 데이터 저장 인접 리스트) visited(방문 거리 저장 배열)
  for (N의 개수만큼 반복하기) {
    A 인접 리스트의 각 ArrayList 초기화하기
  }
  for (M의 개수만큼 반복하기) {
    A 인접 리스트에 그래프 데이터 저장하기
  }
  visited 배열 초기화하기
  BFS(X) 실행하기
  for (N의 개수만큼 반복하기) {
    방문 거리가 K인 노드의 숫자를 정답 배열에 더하기
  }
  정답 배열 오름차순 정렬해 출력하기
  BFS {   // BFS 구현하기
    큐 자료구조에 출발 노드 더하기(add 연산)
    visited 배열에 현재 노드 방문 기록하기
    while (큐가 빌 때까지) {
      큐에서 노드 데이터를 가져오기(poll 연산)
      가져온 노드 출력하기
      현재 노드의 연결 노드 중 방문하지 않은 노드로
      큐에 데이터 삽입(add 연산)하고 visited 배열에 방문 거리 기록하기 (이전 노드의 방문 노드 거리 + 1)
    }
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam046_특정거리도시찾기](src/book/ch08/exam046_특정거리도시찾기.java)
### [문제 047] : 효율적으로 해킹하기 (5s)
  ### 문제
  - 해커 김지민은 잘 알려진 어느 회사를 해킹하려고 한다. 이 회사에는 신뢰하는 관계와 신뢰하지 않는 관계로 이루어진 N개의 컴퓨터가 있다. A가 B를 신뢰할 경우 B를 해킹하면
    A도 해킹할 수 있다. 이 회사의 컴퓨터의 신뢰하는 관계가 주어질 때 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 출력하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 N과 M이 들어온다. N은 10,000보다 작거나 같은 자연수, M은 100,000보다 작거나 같은 자연수다.
    2번째 줄부터 M개의 줄에 신뢰하는 관계가 'A B'와 같은 형식으로 들어오며, 'A가 B를 신뢰한다'를 의미한다. 컴퓨터는 1번부터 N번까지 번호가 1개씩 매겨져 있다.
  ### 출력
  - 1번째 줄에 김지민이 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 오름차순 출력한다.
  ### 예제 입력1
  ```java
  5 4   // 컴퓨터 개수(노드), 신뢰 관계 개수(에지)
  3 1
  3 2
  4 3
  5 3
  ```
  ### 예제 출력1
  ```java
  1 2
  ```
  ### [1단계] 문제 분석하기
  - N과 M의 크기가 작은 편이므로 시간 복잡도와 관련된 제약은 크지 않은 편이다. 이 문제에서 잘 확인해야 할 부분은 신뢰 관계가 A,B라고 했을 때, A가 B를 신뢰한다는 것이다.
    또한 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터는 신뢰를 가장 많이 받는 컴퓨터이다. 그래프의 노드와 에지를 기준으로 이해하면 A라는 노드에서 탐색 알고리즘으로 방문하는
    노드가 B,C라고 하면 B,C는 A에게 신뢰받는 노드가 된다. 이 부분을 고려해 문제에 접근한다.
  ### [2단계] 손으로 풀어보기
  1. 인접 리스트로 컴퓨터와 신뢰 관계 데이터의 그래프를 표현한다.
  2. 모든 노드로 각각 BFS 탐색 알고리즘을 적용해 탐색을 수행한다. 탐색을 수행하면서 탐색되는 노드들의 신뢰도를 증가시켜 준다.
  3. 탐색 종료 후 신뢰도 배열을 탐색해 신뢰도의 최댓값을 Max값으로 지정하고, 신뢰도 배열을 다시 탐색하면서 Max값을 지니고 있는 노드를 오름차순 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(노드 개수) M(에지 개수)
  A(그래프 데이터 저장 인접 리스트) visited(방문 체크 배열) faithCount(신뢰도 저장 배열)
  for (N의 개수만큼 반복하기) {
    A 인접 리스트의 각 ArrayList 초기화하기
  }
  for (M의 개수만큼 반복하기) {
    A 인접 리스트에 그래프 데이터 저장하기
  }
  for (N의 개수만큼 반복하기) {
    visited 배열 초기화하기
    BFS 실행하기
  }
  for (N의 개수만큼 반복하기) {
    faithCount 배열에서 가장 큰 수 찾기 -> maxVal
  }
  for (N의 개수만큼 반복하기) {
    faithCount 배열에서 maxVal와 같은 값을 가진 index를 정답으로 출력하기
  }
  // BFS 구현하기
  BFS {
    큐 자료구조에 출발 노드 더하기(add 연산)
    visited 배열에 현재 노드 방문 기록하기
    while (큐가 빌 때까지) {
      큐에서 노드 데이터를 가져오기(poll 연산)
      현재 노드의 연결 노드 중 방문하지 않은 노드로
      큐에 데이터 삽입(add 연산)하고 visited 배열에 방문 기록하기
      신규 노드 인덱스의 정답 배열 값을 증가시키기 // **핵심 로직
    }
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam047_효율적인해킹](src/book/ch08/exam047_효율적인해킹.java)
### [문제 048] : 이분 그래프 판별하기 (2s)
  ### 문제
  - 각 집합에 속한 노드끼리 서로 인접하지 않는 두 집합으로 그래프의 노드를 나눌 수 있을 때 이 그래프를 '이분 그래프(bipartite graph)'라고 한다. 그래프가 입력으로
    주어졌을 때 이 그래프가 이분 그래프인지 여부를 판별하는 프로그램을 작성하시오.
  ### 입력
  - 입력은 여러 개의 사례로 구성돼 있는데, 1번째 줄에 테스트 케이스의 개수 K(2≤K≤5)가 주어진다. 각 사례의 1번째 줄에 그래프의 노드의 개수 V(1≤V≤20,000)와 에지의 개수
    E(1≤E≤200,000)가 빈칸을 사이에 두고 순서대로 주어진다. 각 노드에는 1부터 V까지 차례로 번호가 붙어 있다. 이어서 2번째 줄부터 E개의 줄에 걸쳐 에지와 관련된 정보가
    주어지는데, 각 줄에 인접한 두 노드의 번호가 공백 문자를 사이에 두고 주어진다.
  ### 출력
  - K개의 줄에 걸쳐 입력으로 주어진 그래프가 이분 그래프이면 YES, 아니면 NO를 순서대로 출력한다.
  ### 예제 입력1
  ```java
  2         // 테스트 케이스 개수
  3 2       // 노드 개수, 에지 개수
  1 3
  2 3
  4 4
  1 2
  2 3
  3 4
  4 2
  ```
  ### 예제 출력1
  ```java
  YES
  NO
  ```
  ### [1단계] 문제 분석하기
  - 노드의 집합을 2개로 나누는데, 인접한 노드끼리 같은 집합이 되지 않도록 적절하게 임의로 분할할 수 있다고 한다. 잘 생각해 보면 트리의 경우에는 항상 이분 그래프가
    된다는 것을 알 수 있다. 사이클이 발생하지 않으면 탐색을 하면서 다음 노드를 이번 노드와 다른 집합으로 지정하면 되기 때문이다. 단, 사이클이 발생했을 때는 이런
    이분 그래프가 불가능할 때가 있다. 바로 기존의 탐색 메커니즘에서 탐색한 노드에 다시 접근하게 됐을 때 현재 노드의 집합과 같으면 이분 그래프가 불가능하다는 것으로
    판별할 수 있다.
  ### [2단계] 손으로 풀어보기
  1. 입력된 그래프 데이터를 인접 리스트로 구현한다.
  2. 모든 노드로 각각 DFS 탐색 알고리즘을 적용해 탐색을 수행한다. DFS를 실행할 때 현재 노드에서 연결된 노드 중 이미 방문한 노드가 나와 같은 집합이면 이분 그래프가 아닌
     것으로 판별한다. 실행 결과가 이분 그래프가 아니면 이후 노드는 탐색하지 않는다.
     - 여기에서 모든 노드로 DFS를 실행하는 이유는 그래프의 모든 노드가 이어져 있지 않고, 여러 개의 부분 그래프로 이뤄진 케이스가 존재할 수 있기 때문이다.
  4. 이분 그래프 여부를 정답으로 출력한다.
  5. 사례의 개수만큼 과정 1~3을 반복한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  check(이분 그래프 체크 배열)
  A(그래프 데이터 저장 인접 리스트) visited(방문 기록 저장 배열)
  N(테스트 케이스)
  for (N의 개수만큼 반복하기) {
    V(노드 개수)
    E(에지 개수)
    for (V의 개수만큼 반복하기) {
      A 인접 리스트의 각 ArrayList 초기화하기
    }
    for (E의 개수만큼 반복하기) {
      A 인접 리스트에 그래프 데이터 저장하기
    }
    for (V의 개수만큼 반복하기) {
      각 노드에서 DFS 실행 -> 결과가 이분 그래프가 아니면 반복 종료
    }
    이분 그래프 여부를 정답으로 출력하기
  }
  DFS {      // DFS 구현하기
    visited 배열에 현재 노드 방문 기록하기
    if (현재 노드의 연결 노드 중 방문하지 않은 노드로) {
      현재 노드와 다른 집합으로 연결 노드 집합 저장하기
      DFS 실행하기(재귀 형태)
    }
    else {   // 이미 방문한 노드인데, 현재 나의 노드와 같은 집합이면
      이분 그래프가 아님
    }
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam048_이분그래프](src/book/ch08/exam048_이분그래프.java)
### [문제 049] : 물의 양 구하기 (1s)
  ### 문제
  - 각각 부피가 A,B,C(1≤A,B,C≤200) 리터인 3개의 물통이 있다. 처음에는 앞의 두 물통은 비어 있고, 3번째 물통은 가득(C리터) 차 있다. 이제 어떤 물통에 들어 있는 물을 다른
    물통으로 쏟아부을 수 있는데, 이때는 한 물통이 비거나, 다른 한 물통이 가득 찰 때까지 물을 부을 수 있다. 이 과정에서 손실되는 물은 없다고 가정한다. 이와 같은 과정을
    거치다 보면 3번째 물통(용량이 C인)에 담겨 있는 물의 양이 변할 수도 있다. 1번째 물통(용량이 A인)이 비어 있을 때 3번째 물통(용량이 C인)에 담겨 있을 수 있는 물의 양을
    모두 구하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 세 정수 A,B,C가 주어진다.
  ### 출력
  - 1번째 줄에 공백으로 구분해 답을 출력한다. 각 용량은 오름차순 정렬한다.
  ### 예제 입력1
  ```java
  8 9 10   // A B C
  ```
  ### 예제 출력1
  ```java
  1 2 8 9 10
  ```
  ### [1단계] 문제 분석하기
  - 지금까지 접해 봤던 그래프 데이터를 저장하고 저장한 자료구조를 이용하는 방식과 달리, 그래프 원리를 적용해 그래프를 역으로 그리는 방식으로 접근하는 문제이다. A,B,C의
    특정 무게 상태를 1개의 노드로 가정하고, 조건에 따라 이 상태에서 변경할 수 있는 이후 무게 상태가 에지로 이어진 인접한 노드라고 생각하고, 문제에 접근해보자.
  ### [2단계] 손으로 풀어보기
  1. 처음에 물통 A,B는 비어 있고, C는 꽉 차 있으므로 최초 출발 노드를 (0,0,3번째 물통의 용량)으로 초기화한다.
  2. BFS를 수행한다. 탐색 과정은 다음과 같다.
     1. 노드에서 갈 수 있는 6개의 경우 (A→B, A→C, B→A, B→C, C→A, C→B)에 관해 다음 노드로 정해 큐에 추가한다. A,B,C 무게가 동일한 노드에 방문한 이력이 있을 때는
        큐에 추가하지 않는다.
     2. 보내는 물통의 모든 용량을 받는 물통에 저장하고, 보내는 물통에는 0을 저장한다. 단, 받는 물통이 넘칠 때는 초과하는 값만큼 보내는 물통에 남긴다.
     3. 큐에 추가하는 시점에 1번째 물통(A)의 무게가 0일 때가 있으면 3번째 물통(C)의 값을 정답 배열에 추가한다.
  3. 정답 리스트를 오름차순 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  Sender, Receiver (6가지 경우를 탐색하기 위한 선언 배열)
  answer (정답 배열)
  now (A,B,C의 값을 저장하는 배열)
  now 배열 저장하기
  visited, answer 초기화 작업하기
  BFS 수행하기
  for (answer 배열 탐색하기) {
    answer 배열에서 값이 true인 index를 정답으로 출력하기
  }
  BFS {                 // BFS 구현하기
    큐 자료구조에 출발 노드 더하기 → A와 B가 0인 상태이므로 (0,0) 노드에서 시작하기
    visited 배열에 현재 노드 방문 기록하기
    answer 배열에 현재 C의 값 체크하기
    while (큐가 빌 때까지) {
      큐에서 노드 데이터를 가져오기(poll 연산)
      데이터를 이용해 A,B,C의 값 초기화하기
      for (6가지 케이스 반복하기) { // A→B, A→C, B→A, B→C, C→A, C→B
        받는 물통에 보내려는 물통의 값을 저장하기
        보내려는 물통 값을 0으로 업데이트하기
        if (받는 물통이 넘칠 때) {
          넘치는 만큼 보내는 물통에 다시 넣어 주고, 받는 물통은 이 물통의 최댓값으로 저장
        }
        현재 노드의 연결 노드 중 방문하지 않은 노드로
        큐에 데이터 삽입(add 연산)하고 visited 배열에 방문 기록하기,
        if (1번째 물통이 비어 있을 때) 3번째 물통의 물의 양을 answer 배열에 기록하기
      }
    }
  }
  // AB 클래스 선언 → A와 B의 값만 지니고 있으면 C는 유추할 수 있으므로 두 변수만 사용하기
  class AB {
    A,B 물통 무게를 변수로 가짐
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam049_물통](src/book/ch08/exam049_물통.java)

# 2. 유니온 파인드
- **`유니온 파인드(union-find)`** 는 일반적으로 여러 노드가 있을 때 특정 2개의 노드를 연결해 1개의 집합으로 묶는 **union 연산**과 두 노드가 같은 집합에 속해 있는지를
  확인하는 **find 연산**으로 구성되어 있는 알고리즘이다.
## (1) union, find 연산
- ### union 연산
  - 각 노드가 속한 집합을 1개로 합치는 연산이다. 노드 a,b가 a∈A, b∈B일 때 union(a,b)는 **`A∪B`** 를 말한다.
- ### find 연산
  - 특정 노드 a에 관해 a가 속한 **집합의 대표 노드를 반환**하는 연산이다. 노드 a가 a∈A일 때 find(a)는 A 집합의 대표 노드를 반환한다.
## (2) 유니온 파인드의 원리 이해하기
  1. 유니온 파인드를 표현하는 일반적인 방법은 1차원 배열을 이용하는 것이다. 처음에는 노드가 연결되어 있지 않으므로 각 노드가 대표 노드가 된다.
     각 노드가 모두 대표 노드이므로 배열은 자신의 인덱스값으로 초기화한다.
  2. 2개의 노드를 선택해 각각의 대표 노드를 찾아 연결하는 union 연산을 수행한다. <br/>
     - **(level1) 1,4 union && 5,6 union 연산**
       - 1은 대표 노드, 4는 자식 노드로 union 연산을 할 때 배열[4]의 대표 노드를 1로 설정한다. 그 결과 각각의 집합이었던 1,4는 하나로 합쳐진다.
       - 5는 대표 노드, 6은 자식 노드로 union 연산을 할 때 배열[6]의 대표 노드를 5로 설정한다. 그 결과 각각의 집합이었던 5,6은 하나로 합쳐진다.
     - **(case2) 4,6 union 연산**
       - 4,6은 모두 대표 노드가 아니므로 각 노드의 대표 노드를 찾아 올라간 다음 그 대표 노드를 연결한다.<br/>
         지금의 경우 4의 대표 노드 1에 6의 대표 노드 5를 연결한 것이므로 배열은 [1,2,3,1,1,5]가 된다. 배열 상태로 보면 그래프의 연결이 잘 안 보일 수도 있겠지만
         find 연산 설명을 보면 위 배열이 그래프 연결을 잘 나타내고 있다는 것을 쉽게 이해할 수 있다.
  3. find 연산은 자신이 속한 집합의 대표 노드를 찾는 연산이다. find 연산은 단순히 대표 노드를 찾는 역할만 하는 것이 아니라 **그래프를 정돈하고 시간 복잡도를 향상**시킨다.
     1. 대상 노드 배열에 index값과 value값이 동일한지 확인한다.
     2. 동일하지 않으면 value값이 가리키는 index 위치로 이동한다.
     3. 이동 위치의 index값과 value값이 같을 때까지 1~2를 반복한다. 반복이므로 이 부분은 **`재귀 함수`** 로 구현한다.
     4. 대표 노드에 도달하면 재귀 함수를 빠져나오면서 거치는 모든 노드값을 루트 노드값으로 변경한다.
     - find 연산은 잘 생각하면 시간 복잡도가 줄어드는 효과를 얻게 된다. 연산을 할 때 거치는 노드들이 대표 노드와 바로 연결되는 형태로 변경된다.
       이렇게 되면 **추후 노드와 관련된 find 연산 속도가 O(1)로 변경**된다. ⇒ **경로 압축의 효과**

### [문제 050] : 집합 표현하기 (2s)
  ### 문제
  - 초기에 {0}, {1}, {2}, ..., {n}이 각각 n+1개의 집합을 이루고 있다. 여기에 합집합 연산과 두 원소가 같은 집합에 포함돼 있는지를 확인하는 연산을 수행하려고 한다.
    집합을 표현하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 n(1≤n≤1,000,000), m(1≤m≤100,000)이 주어진다. m은 입력으로 주어지는 연산의 개수다. 다음 m개의 줄에는 각각의 연산이 주어진다.<br/>
    합집합은 0 a b의 형태로 입력이 주어진다. 이는 a가 포함돼 있는 집합과 b가 포함돼 있는 집합을 합친다는 의미다. 두 원소가 같은 집합에 포함돼 있는지를 확인하는 연산은
    1 a b의 형태로 입력이 주어진다. 이는 a와 b가 같은 집합에 포함돼 있는지를 확인하는 연산이다. a와 b는 n 이하의 자연수 또는 0이고, 같을 수도 있다.
  ### 출력
  - 1로 시작하는 입력에 1줄에 1개씩 YES 또는 NO로 결과를 출력한다.
  ### 예제 입력1
  ```java
  7 8    // 원소 개수, 질의 개수
  0 1 3
  1 1 7
  0 7 6
  1 7 1
  0 3 7
  0 4 2
  0 1 1
  1 1 1
  ```
  ### 예제 출력1
  ```java
  NO
  NO
  YES
  ```
  ### [1단계] 문제 분석하기
  - 최대 원소의 개수 1,000,000과 질의 개수 100,000이 큰 편이므로 경로 압축이 필요한 전형적인 유니온 파인드 문제이다.
  ### [2단계] 손으로 풀어보기
  1. 처음에는 노드가 연결돼 있지 않으므로 각 노드의 대표 노드는 자기 자신이다. 각 노드의 값을 자기 인덱스값으로 초기화한다.
  2. find 연산으로 특정 노드의 대표 노드를 찾고, union 연산으로 2개의 노드를 이용해 각 대표 노드를 찾아 연결한다. 그리고 질의한 값에 따라 결과를 반환한다.
  - #### 유니온 파인드에서 자주 실수하는 부분
    - find 연산을 수행할 때 재귀 함수에서 나오면서 탐색한 모든 노드의 대표 노드값을 이번 연산에서 발견한 대표 노드로 변경하는 부분
    - union 연산에서 선택된 노드끼리 연결하는 것이 아닌 선택된 노드의 대표 노드끼리 연결하는 부분
  ### [3단계] 슈도코드 작성하기
  ```java
  N(원소 개수) M(질의 개수)
  parent(대표 노드 저장 배열)
  for (N의 개수만큼 반복하기) {
    대표 노드를 자기 자신으로 초기화하기
  }
  for (M만큼 반복하기) {
    if (0이면) 집합 합치기 → union 연산
    else 같은 집합 원소인지 확인하고 결괏값 출력하기
  }
  // union 연산
  union(a,b) {
    a와 b의 대표 노드 찾기
    두 원소의 대표 노드끼리 연결하기
  }
  // find 연산
  find(a) {
    a가 대표 노드면 리턴
    아니면 a의 대표 노드값을 find(parent[a]) 값으로 저장 → 재귀 함수 형태
  }
  // checkSame → 두 원소가 같은 집합인지 확인
  checkSame(a,b) {
    a와 b의 대표 노드 찾기
    두 대표 노드가 같으면 true
    아니면 false return
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam050_집합표현하기]
### [문제 051] : 여행 계획 짜기 (2s)
  ### 문제
  - 동혁이는 친구들과 함께 여행을 가려고 한다. 한국에는 도시가 N개 있고 임의의 두 도시 사이에 길이 있을 수도, 없을 수도 있다. 동혁이는 여행 계획이 주어졌을 때
    이 계획대로 여행할 수 있는지를 알아보려 한다. 물론 중간에 다른 도시를 경유해 여행할 수도 있다.<br/>
    예를 들어 도시가 5개 있고, A-B, B-C, A-D, B-D, E-A의 길이 있고, 동혁이의 여행 계획이 E,C,B,C,D라면 E-A-B-C-B-C-B-D라는 여행 경로를 이용해 계획대로 여행할 수 있다. 도시의 개수와 도시 간의 연결 여부가 주어져 있고, 동혁이의
    여행 계획에 속한 도시들이 순서대로 주어졌을 때 계획대로 여행이 가능한지를 판별하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 도시의 수 N이 주어진다(N≤200). 2번째 줄에 여행 계획에 속하 도시들의 수 M이 주어진다(M≤1,000). 다음 N개의 줄에는 N개의 정수가 주어진다.<br/>
    i번째 줄의 j번째 수는 i번 도시와 j번 도시의 연결 정보를 의미한다. 1이면 연결된 것이고, 0이면 연결되지 않은 것이다. A와 B가 연결됐으면 B와 A도 연결돼 있다.<br/>
    마지막 줄에는 여행 계획이 주어진다. 도시의 번호는 1에서 N까지 차례대로 매겨져 있다.
  ### 출력
  - 1번째 줄에 가능하면 YES, 불가능하면 NO를 출력한다.
  ### 예제 입력1
  ```java
  3   // 도시 개수
  3   // 여행 경로 데이터
  0 1 0
  1 0 1
  0 1 0
  1 2 3
  ```
  ### 예제 출력1
  ```java
  YES
  ```
  ### [1단계] 문제 분석하기
  - 도시의 연결 유무를 유니온 파인드 연산을 이용해 해결할 수 있다는 아이디어를 떠올릴 수 있으면 쉽게 해결할 수 있는 문제이다. 일반적으로 유니온 파인드는 그래프 영역에서
    많이 활용되지만, 위 문제와 같이 단독으로도 활용할 수 있다는 점도 참고하자. 이 문제에서는 도시 간 연결 데이터를 **인접 행렬**의 형태로 주었기 때문에 인접 행렬을
    탐색하면서 연결될 때마다 union 연산을 수행하는 방식으로 문제에 접근하면 된다.
  ### [2단계] 손으로 풀어보기
  1. 도시와 여행 경로 데이터를 저장하고, 각 노드와 관련된 대표 노드 배열의 값을 초기화한다.
  2. 도시 연결 정보가 저장된 인접 행렬을 탐색하면서 도시가 연결돼 있을 때 union 연산을 수행한다. 이때 항상 큰 도시가 대표가 되도록 union 연산의 매개변수를 변경한다.
     → *** 큰 도시가 대표가 되도록 어떻게 구현할 것인가? 구현된 부분이 코드에 존재하지 않음
  3. 여행 경로에 포함된 도시의 대표 노드가 모두 같은지 확인한 후 결괏값을 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(도시의 수) M(여행 계획에 속한 도시의 수)
  dosi(도시 연결 데이터 배열) route(여행 계획 도시 저장 배열)
  for (N만큼 반복하기) {
    for (N만큼 반복하기) {
      dosi 데이터 저장하기
    }
  }
  for (M만큼 반복하기) {
    route 데이터 저장하기
  }
  for (i → N만큼 반복하기) {     // 인접 행렬 탐색하기
    for (j → N만큼 반복하기) {
      dosi[i][j] == 1이면, 즉 도시가 연결돼 있으면 union 연산하기
    }
  }
  for (M만큼 반복하기) {
    route에 포함되는 노드들의 대표 노드가 모두 동일한지 확인한 후 결괏값 출력하기
  }
  union(a,b) {                   // union 연산
    a와 b의 대표 노드 찾기
    두 원소의 대표 노드끼리 연결하기
  }
  find(a) {                      // find 연산
    a가 대표 노드면 리턴
    아니면 a의 대표 노드값을 find(parent[a]) 값으로 저장 → 재귀 함수 형태
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam051_여행계획짜기](src/book/ch08/exam051_여행계획짜기.java)
### [문제 052] : 거짓말쟁이가 되긴 싫어 (2s)
  ### 문제
  - 지민이는 파티에 갈 때마다 자기가 가장 좋아하는 이야기를 한다. 이야기는 과장할수록 더 재미있어지므로 되도록이면 과장해 이야기하려 한다. 문제는 몇몇 사람들이 그 이야기의
    진실을 안다는 것이다. 지민이는 이야기를 과장한 게 들켜서 거짓말쟁이가 되는 건 싫어한다. 그래서 이 사람들이 파티에 왔을 때는 진실을 이야기할 수밖에 없다.<br/>
    사람의 수 N이 주어지고, 이야기의 진실을 아는 사람이 주어진다. 그리고 각 파티에 오는 사람들의 번호가 주어진다. 지민이는 모든 파티에 참가해야 한다.
    이때 지민이가 거짓말쟁이로 알려지지 않으면서 과장된 이야기를 할 수 있는 파티 개수의 최댓값을 구하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 사람의 수 N과 파티의 수 M이 주어진다. 2번째 줄에 이야기의 진실을 아는 사람의 수와 번호가 주어진다. 진실을 아는 사람의 수가 먼저 주어지고, 그 개수만큼
    사람들의 번호가 주어진다. 사람들의 번호는 1부터 N까지의 수로 주어진다. 3번째 줄에서 M개의 줄에는 각 파티마다 오는 사람의 수와 번호가 같은 방식으로 주어진다.
    N, M은 50 이하의 자연수, 진실을 아는 사람의 수와 각 파티마다 오는 사람의 수는 모두 0 이상 50 이하의 정수다.
  ### 출력
  - 1번째 줄에 문제의 정답을 출력한다.
  ### 예제 입력1
  ```java
  4 3      // 사람 수, 파티 수
  0        // 진실을 아는 사람 정보
  2 1 2    // 파티 정보
  1 3
  3 2 3 4
  ```
  ### 예제 출력1
  ```java
  3
  ```
  ### 예제 입력2
  ```java
  4 1
  1 1
  4 1 2 3 4
  ```
  ### 예제 출력2
  ```java
  0
  ```
  ### 예제 입력3
  ```java
  4 1
  0
  4 1 2 3 4
  ```
  ### 예제 출력3
  ```java
  1
  ```
  ### 예제 입력4
  ```java
  4 5
  1 1
  1 1
  1 2
  1 3
  1 4
  2 4 1
  ```
  ### 예제 출력4
  ```java
  2
  ```
  ### 예제 입력5
  ```java
  10 9
  4 1 2 3 4
  2 1 5
  2 2 6
  1 7
  1 8
  2 7 8
  1 9
  1 10
  2 3 10
  1 4
  ```
  ### 예제 출력5
  ```java
  4
  ```
  ### 예제 입력6
  ```java
  8 5
  3 1 2 7
  2 3 4
  1 5
  2 5 6
  2 6 8
  1 8
  ```
  ### 예제 출력6
  ```java
  5
  ```
  ### [1단계] 문제 분석하기
  - 이 문제의 핵심은 파티에 참석한 사람들을 1개의 집합으로 생각하고, 각각의 파티마다 union 연산을 이용해 사람들을 연결하는 것이다. 이 작업을 하면 1개의 파티에 있는 모든
    사람들은 같은 대표 노드를 바라보게 된다. 이후 각 파티의 대표 노드와 진실을 알고 있는 사람들의 각 대표 노드가 동일한지 find 연산을 이용해 확인함으로써 과장된 이야기를
    할 수 있는지 판단할 수 있다.
  ### [2단계] 손으로 풀어보기
  1. 진실을 아는 사람 데이터, 파티 데이터, 유니온 파인드를 위한 대표 노드 자료구조를 초기화한다.
  2. union 연산을 수행해 각 파티에 참여한 사람들을 1개의 그룹으로 만든다.
  3. find 연산을 수행해 각 파티의 대표 노드와 진실을 아는 사람들이 같은 그룹에 있는지 확인한다. 파티 사람 노드는 모두 연결돼 있으므로 아무 사람이나 지정해 find 연산을
     수행하면 된다.
  4. 모든 파티에 관해 과정 3을 반복해 수행하고, 모든 파티의 대표 노드가 진실을 아는 사람들과 다른 그룹에 있다면 결괏값을 증가시킨다.
  5. 과장할 수 있는 파티의 개수를 결괏값으로 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(사람 수) M(파티 수)
  T(진실을 아는 사람 수) trueP(진실을 아는 사람 데이터) party(파티 데이터)
  parent(대표 노드 저장 배열)
  데이터를 입력받아 각자 자료구조에 저장하기
  for (N만큼 반복하기) {
    대표 노드를 자기 자신으로 초기화하기
  }
  for (i → M만큼 반복하기) {
    firstPeople(i번째 파티의 1번째 사람)
    for (j → i번째 파티의 사람 수만큼 반복하기) {
      union(firstPeole, j)   // 각 파티에 참여한 사람들을 1개의 그룹으로 만들기
    }
  }
  for (i → M만큼 반복하기) {
    firstPeople(i번째 파티의 사람)
    for (j → 진실을 아는 사람들의 수만큼 반복하기) {
      // 각 파티의 대표 노드와 진실을 아는 사람들의 대표 노드가 같다면 과장할 수 없음
      find(firstPeople), find(trueP[j]) 비교하기
    } 모두 다른 경우 결괏값 1 증가
  }
  결괏값 출력하기
  union(a,b) {     // union 연산
    a와 b의 대표 노드 찾기
    두 원소의 대표 노드끼리 연결하기
  }
  find(a) [        // find 연산
    a가 대표 노드면 리턴하기
    아니면 a의 대표 노드값을 find(parent[a]) 값으로 저장 → 재귀 함수 형태
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam052_거짓말](src/book/ch08/exam052_거짓말.java)

# 3. 위상 정렬
- **`위상 정렬(topology sort)`** 은 사이클이 없는 방향 그래프에서 노드 순서를 찾는 알고리즘이다.
  
  |기능|특징|시간 복잡도 (노드 수: V, 에지 수: E)|
  |:---|:---|:---|
  |노드 간의 순서를 결정|사이클이 없어야 함|O(V+E)|

  위상 정렬에서는 항상 유일한 값으로 정렬되지 않는다. 또한 사이클이 존재하면 노드 간의 순서를 명확하게 정의할 수 없으므로 위상 정렬을 적용할 수 없다.
  ## 위상 정렬의 원리 이해하기
  ### 1. 진입 차수(in-degree) 배열 업데이트
  - 진입 차수는 자기 자신을 가리키는 에지의 개수를 말한다.
  ### 2. 진입 차수가 0인 노드 선택 및 정렬 배열 저장
  ### 3. 선택 노드가 가리키는 노드들의 진입 차수를 1씩 차감
  #### ▶ `모든 노드가 정렬될 때까지 2,3번 반복`

### [문제 053] : 줄 세우기 (2s)
  ### 문제
  - N명의 학생들을 키 순서대로 줄을 세우려고 한다. 각 학생의 키를 직접 재서 정렬하면 간단하겠지만, 마땅한 방법이 없어 두 학생의 키를 비교하는 방법을 사용하기로 했다.
    그나마도 모든 학생을 비교해 본 것이 아니라 일부 학생들의 키만을 비교해 봤다. 일부 학생들의 키를 비교한 결과가 주어졌을 때 줄을 세우는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 N(1≤N≤32,000), M(1≤M≤100,000)이 주어진다. M은 키를 비교한 횟수다. 그다음 M개의 줄에는 키를 비교한 두 학생의 번호 A,B가 주어진다. 이는 학생 A가 학생 B의
    앞에 서야 한다는 의미다. 학생들의 번호는 1번부터 N번이다.
  ### 출력
  - 1번째 줄부터 앞에서부터 줄을 세운 결과를 출력한다. 답이 여러 가지일 경우에는 아무거나 출력한다.
  ### 예제 입력1
  ```java
  4 2   // 노드 개수, 에지 개수
  4 2
  3 1
  ```
  ### 예제 출력1
  ```java
  4 2 3 1
  ```
  ### 예제 입력2
  ```java
  3 2
  1 3
  2 3
  ```
  ### 예제 출력2
  ```java
  1 2 3
  ```
  ### [1단계] 문제 분석하기
  - 학생들을 노드로 생각하고, 키 순서 비교 데이터로 에지를 만든다고 생각했을 때 노드의 순서를 도출하는 가장 기본적인 문제이다. 특히 답이 여러 개일 때 아무것이나 출력해도
    된다는 전제는 위상 정렬의 결괏값이 항상 유일하지 않다는 알고리즘의 전제와 동일하다는 것을 알 수 있다.
  ### [2단계] 손으로 풀어보기
  1. 인접 리스트에 노드 데이터를 저장하고, 진입 차수 배열값을 업데이트한다.
  2. 다음 순서에 따라 위상 정렬을 수행한다.
     1. 진입 차수가 0인 노드를 큐에 저장한다.
     2. 큐에서 데이터를 poll해 해당 노드를 탐색 결과에 추가하고, 해당 노드가 가리키는 노드의 진입 차수를 1씩 감소한다.
     3. 감소했을 때 진입 차수가 0이 되는 노드를 큐에 offer한다.
     4. 큐가 빌 때까지 ⅰ~ⅲ을 반복한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(학생 수) M(비교 횟수) A(데이터 저장 인접 리스트)
  학생 수만큼 인접 리스트 초기화하기
  진입 차수 배열 초기화하기
  for (비교 횟수만큼 반복하기) {
    인접 리스트 데이터 저장하기
    진입 차수 배열 초기 데이터 저장하기
  }
  // 위상 정렬 수행하기
  큐 생성하기
  for (학생 수) {
    진입 차수 배열의 값이 0인 학생(노드)을 큐에 삽입하기
  }
  while (큐가 빌 때까지) {
    현재 노드 = 큐에서 데이터 poll
    현재 노드값 출력하기
    for (현재 노드에서 갈 수 있는 노드의 개수) {
      타깃 노드 진입 차수 배열--
      if (타깃 노드의 진입 차수가 0이면) {
        큐에 타깃 노드 추가하기
      }
    }
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam053_줄세우기](src/book/ch08/exam053_줄세우기.java)
### [문제 054] : 게임 개발하기 (2s)
  ### 문제
  - 숌 회사에서 이번에 새로운 전략 시뮬레이션 게임 세준크래프트를 개발하기로 했다. 핵심적인 부분은 개발이 끝난 상태고, 종족별 균형과 전체 게임 시간 등을 조절하는 부분만
    남아 있었다. 게임 플레이에 들어가는 시간은 상황에 따라 다를 수 있기 때문에 모든 건물을 짓는 데 걸리는 최소의 시간을 이용해 근사하기로 했다.<br/>
    물론, 어떤 건물을 짓기 위해서는 다른 건물을 먼저 지어야 할 수도 있으므로 문제가 단순하지는 않다. 예를 들면 스타크래프트에서 벙커를 짓기 위해서는 배럭을 먼저 지어야
    하므로 배럭을 먼저 지은 후 벙커를 지어야 한다. 여러 개의 건물을 동시에 지을 수 있다. 편의상 자원은 무한히 많고, 건물을 짓는 명령을 내리기까지는 시간이 걸리지 않는다고
    가정해 보자. N개의 건물을 지을 때 각 건물을 짓기 위해 필요한 최소 시간을 출력하시오.
  ### 입력
  - 1번째 줄에 건물의 종류 수 N(1≤N≤500), 그다음 N개의 줄에는 각 건물을 짓는 데 걸리는 시간과 그 건물을 짓기 위해 먼저 지어야 하는 건물들의 번호가 주어진다. 건물의 번호는
    1부터 N까지로 하고, 각 줄은 -1로 끝난다고 가정해 보자. 각 건물을 짓는 데 걸리는 시간은 100,000보다 작거나 같은 자연수다.
  ### 출력
  - N개의 각 건물이 완성되기까지 걸리는 최소 시간을 출력한다.
  ### 예제 입력1
  ```java
  5     // 건물 종류 수
  10 -1
  10 1 -1
  4 1 -1
  4 3 1 -1
  3 3 -1
  ```
  ### 예제 출력1
  ```java
  10
  20
  14
  18
  17
  ```
  ### [1단계] 문제 분석하기
  - 이 문제를 풀기 위해서는 어떤 건물을 짓기 위해 먼저 지어야 하는 건물이 있을 수 있다라는 문장에 주목해야 한다. 각 건물을 노드라고 생각하면 그래프 형태에서 노드 순서를
    정렬하는 알고리즘인 위상 정렬을 사용하는 문제라는 것을 눈치챌 수 있다. 건물의 수가 최대 500, 시간 복잡도가 2초이므로 시간 제한 부담은 거의 없다.
  ### [2단계] 손으로 풀어보기
  1. 입력 데이터를 바탕으로 필요한 자료구조를 초기화한다. 인접 리스트로 그래프를 표현할 때는 (건물 번호, 현재 건물을 짓는 데 걸리는 시간)를 Node로 선언하여 연결한다.
     진입 차수 배열은 [0,1,1,2,1], 정답 배열은 모두 0으로 초기화한다.
  2. 위상 정렬을 실행하면서 각 건물을 짓는 데 걸리는 최대 시간을 업데이트한다. 업데이트는 다음과 같은 방법으로 수행한다.
     - Math.max(현재 건물(노드)에 저장된 최대 시간, 이전 건물(노드)에 저장된 최대 시간 + 이전 건물(노드)의 생산 시간)
  3. 정답 배열에 자기 건물을 짓는 데 걸리는 시간을 더한 후 정답 배열을 차례대로 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(건물 종류 수), A(데이터 저장 인접 리스트)
  건물의 개수만큼 인접 리스트 초기화하기
  진입 차수 배열 초기화하기
  자기 자신을 짓는 데 걸리는 시간 저장 배열 초기화하기
  for (건물의 개수) {
    인접 리스트 데이터 저장하기
    진입 차수 배열 초기 데이터 저장하기
    자기 자신 배열 초기화하기
  }
  // 위상 정렬 수행하기
  큐 생성하기
  for (건물의 개수) {
    진입 차수 배열의 값이 0인 건물(노드)를 큐에 삽입하기
  }
  while (큐가 빌 때까지) {
    현재 노드 = 큐에서 데이터 poll
    for (현재 노드에서 갈 수 있는 노드의 개수) [
      타깃 노드 진입 차수 배열 --
      결과 노드 업데이트 = Math.max(현재 저장된 값, 현재 출발 노드 + 비용)
      if (타깃 노드의 진입 차수가 0이면) {
        큐에 타깃 노드 추가하기
      }
    }
  }
  위상 정렬 결과 출력하기
  ```
  ### [4단계] 코드 구현하기
  - [exam054_게임개발](src/book/ch08/exam054_게임개발.java)
### [문제 055] : 임계 경로 구하기 (2s)
  ### 문제
  - 월드 나라는 모든 도로가 일방통행이고, 사이클이 없다. 그런데 어떤 무수히 많은 사람이 월드 나라의 지도를 그리기 위해 어떤 시작 도시에서 도착 도시까지 출발해 갈 수 있는
    모든 경로를 탐색한다고 한다. 이 지도를 그리는 사람들은 사이가 너무 좋아서 지도를 그리는 일을 모두 마치고 도착 도시에서 만나기로 했다. 어떤 사람은 도착 시간에 만나기
    위해 1분도 쉬지 않고 달려야 한다. 이들의 출발 도시에서 출발한 후 도착 도시에서 만나기까지 걸리는 최소 시간과, 1분도 쉬지 않고 달려야 하는 사람들이 지나는 도로의 수를
    계산하는 프로그램을 작성하시오(출발 도시는 들어오는 도로가 0개, 도착 도시는 나가는 도로가 0개다).
  ### 입력
  - 1번째 줄에 도시의 개수 n(1≤n≤10,000), 2번째 줄에 도로의 개수 m(1≤m≤100,000)이 주어진다. 그리고 3번째 줄에서 m+2줄까지 다음과 같은 도로의 정보가 주어진다.<br/>
    처음에는 도로의 출발 도시의 번호가 주어지고, 그다음에는 도착 도시의 번호 그리고 마지막에는 이 도로를 지나는 데 걸리는 시간이 주어진다. 도로를 지나가는 시간은
    10,000보다 작거나 같은 자연수다.<br/> 그리고 m+3번째 줄에는 지도를 그리는 사람들이 출발하는 출발 도시와 도착 도시가 주어진다. 모든 도시는 출발 도시에서 도달할 수 있고,
    모든 도시에서 도착 도시에 도달할 수 있다.
  ### 출력
  - 1번째 줄에 이들이 만나는 시간, 2번째 줄에 1분도 쉬지 않고 달려야 하는 도로의 수가 몇 개인지 출력하라.
  ### 예제 입력1
  ```java
  7   // 도시 수
  9   // 도로 수
  1 2 4
  1 3 2
  1 4 3
  2 6 3
  2 7 5
  3 5 1
  4 6 4
  5 6 2
  6 7 5
  1 7  // 시작 도시, 도착 도시
  ```
  ### 예제 출력1
  ```java
  12
  5
  ```
  ### [1단계] 문제 분석하기
  - 출발 도시와 도착 도시가 주어지기 때문에 일반적인 위상 정렬이 아닌 시작점을 출발 도시로 지정하고 위상 정렬을 수행하면 출발 도시에서 도착 도시까지 거치는 모든 도시와
    관련된 임계 경로값을 구할 수 있다. 단, 이 문제의 핵심은 1분도 쉬지 않고 달려야 하는 도로의 수를 구하는 것인데, 이를 해결하려면 **에지 뒤집기**라는 아이디어가 필요하다.
    에지 뒤집기 아이디어는 그래프 문제에서 종종 나오는 개념이므로 이 문제를 이용해 학습해보자.
  ### [2단계] 손으로 풀어보기
  1. 인접 리스트에 노드 데이터를 저장하고, 진입 차수 배열 값을 업데이트한다. 이때 에지의 방향이 반대인 역방향 인접 리스트도 함께 생성하고 저장한다.
  2. 시작 도시에서 위상 정렬을 수행해 각 도시와 관련된 임계 경로를 저장한다.
  3. 도착 도시에서 역방향으로 위상 정렬을 수행한다. 이때 '이 도시의 임계 경로값 + 도로 시간(에지) == 이전 도시의 임계 경로값'일 경우에는 이 도로를 1분도 쉬지 않고
     달려야 하는 도로로 카운팅하고, 이 도시를 큐에 삽입하는 로직으로 구현해야 한다.
  4. 도착 도시의 임계 경로값과 1분도 쉬지 않고 달려야 하는 도로의 수를 출력한다.
     ### ** 노드를 큐에 삽입할 때 주의할 점
     - 1분도 쉬지 않고 달려야 하는 도로로 이어진 노드와 연결된 다른 도로만이 1분도 쉬지 않고 달려야 하는 도로의 후보가 될 수 있으므로 이 메커니즘을 바탕으로 노드를
       큐에 삽입해야 한다. 또한 중복으로 도로를 카운트하지 않기 위해 **이미 방문한 적이 있는 한 노드는 큐에 넣어 주지 않는다.**<br/>
       기존의 위상 정렬 방식을 완벽하게 이해하고, 요구사항에 따라 적절하게 로직을 수정할 수 있어야만 문제를 풀 수 있기 때문에 많이 고민해야 하는 문제이다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(도시 수) M(도로 수)
  A(도시 인접 리스트) reverseA(역방향 인접 리스트)
  도시 수만큼 인접 리스트 초기화하기
  진입 차수 배열 초기화하기
  for (도로 수만큼 반복하기) {
    인접 리스트 데이터 저장하기
    역방향 인접 리스트 데이터 저장하기
    진입 차수 배열 초기 데이터 저장하기
  }
  // 위상 정렬 수행하기
  큐 생성하기
  출발 도시를 큐에 삽입하기
  result(각 도시의 최대 걸리는 시간 저장 - 임계 경로값)
  while (큐가 빌 때까지) {
    현재 노드 = 큐에서 데이터 poll
    for (현재 노드에서 갈 수 있는 노드의 개수) {
      타깃 노드 진입 차수 배열 --
      result = Math.max(타깃 노드의 현재 경로값, 현재 노드의 경로값 + 도로 시간값)
      if (타깃 노드의 진입 차수가 0이면) 큐에 타깃 노드 추가하기
    }
  }
  // 위상 정렬 역방향 수행하기
  visited(각 도시의 방문 유무 저장하기)
  resultCount(1분도 쉬지 않고 달려야 하는 도로의 수)
  도착 도시를 큐에 삽입하기
  visited 배열에 도착 도시를 방문 도시로 표시하기
  while (큐가 빌 때까지) {
    현재 노드 = 큐에서 데이터 poll
    for (현재 노드에서 갈 수 있는 노드의 개수 → 역방향 인접 리스트 기준) {
      if (타깃 노드의 result값 + 도로를 지나는 데 걸리는 시간(에지) == 현재 노드의 result값) {
        1분도 쉬지 않고 달려야 하는 도로값 1 증가
        if (아직 방문하지 않은 도시이면) {
          visited 배열에 방문 도시 표시하기
          큐에 타깃 노드 추가하기
        }
      }
    }
  }
  만나는 시간(result[endDosi]) 출력
  1분도 쉬지 않고 달려야 하는 도로의 수(resultCount) 출력
  ```
  ### [4단계] 코드 구현하기
  - [exam055_임계경로](src/book/ch08/exam055_임계경로.java)

# 4. 다익스트라
- **`다익스트라(dijkstra)`** 알고리즘은 그래프에서 최단 거리를 구하는 알고리즘으로, 주요 특징은 다음과 같다.

  |기능|특징|시간 복잡도 (노드 수: V, 에지 수: E)|
  |:---|:---|:---|
  |출발 노드와 모든 노드 간의 **최단 거리** 탐색|에지는 모두 **양수**|O(ElogV)|

  **특정 노드에서 다른 노드들의 최단 거리**를 구하는 문제가 주어졌을 때 다익스트라 알고리즘을 사용하면 문제를 해결할 수 있다.
  ## 다익스트라 알고리즘의 핵심 이론
  ### 1. 인접 리스트로 그래프 구현하기
  - 다익스트라 알고리즘은 인접 행렬로 구현해도 좋지만 **시간 복잡도 측면, N의 크기가 클 것을 대비**해 인접 리스트를 선택하여 구현하는 것이 좋다.
    그래프의 연결을 표현하기 위해 인접 리스트에 연결한 배열의 자료형은 **(노드, 가중치)** 와 같은 클래스 형태로 선언하여 연결하는 경우가 많다.
  ### 2. 최단 거리 배열 초기화하기
  - 최단 거리 배열을 만들고, 출발 노드는 0, 이외의 노드는 **무한(∞)으로 초기화**한다. 이때 무한은 적당히 큰 값을 사용하면 된다.(표기: ∞)
    - ∞은 실제 구현 시 아주 큰 값, 예를 들어 99,999,999 정도로 정하면 된다.
  ### 3. 값이 가장 작은 노드 고르기
  - 최단 거리 배열에서 현재 값이 가장 작은 노드를 고른다. 맨 처음에는 값이 0인 출발 노드에서 시작하면 된다.
  ### 4. 최단 거리 배열 업데이트하기
  - 선택된 노드에 연결된 에지의 값을 바탕으로 다른 노드의 값을 업데이트한다. 1단계에서 저장해 놓은 연결 리스트를 이용해 현재 선택된 노드의 에지들을 탐색하고
    업데이트하면 된다. 연결 노드의 최단 거리는 다음과 같이 두 값 중 더 작은 값으로 업데이트한다.
    - **최단 거리 : Min(선택 노드의 최단 거리 배열 값 + 에지 가중치, 연결 노드의 최단 거리 배열 값)**
  ### 5. 과정 3~4를 반복해 최단 거리 배열 완성하기
  - 모든 노드가 처리될 때까지 과정 3~4를 반복한다. 과정 4에서 선택 노드가 될 때마다 다시 선택되지 않도록 **방문 배열**을 만들어 처리하고,
    **모든 노드가 선택될 때까지 반복**하면 최단 거리 배열이 완성된다.

### [문제 056] : 최단 경로 구하기 (1s)
  ### 문제
  - 에지의 가중치가 10 이하의 자연수인 방향 그래프가 있다. 이 그래프의 시작점에서 다른 모든 노드로의 최단 경로를 구하시오.
  ### 입력
  - 1번째 줄에 노드의 개수 V와 에지의 개수 E가 주어진다(1≤V≤20,000, 1≤E≤300,000). 모든 노드에는 1부터 V까지 번호가 매겨져 있다.
    2번째 줄에 출발 노드의 번호 K가 주어진다(1≤K≤V). 3번째 줄에서 E개의 줄에 걸쳐 각 에지의 정보(u,v,w)가 순서대로 주어진다. 이는 u에서 v로 가는 가중치 w인 에지가
    존재한다는 뜻으로, u와 v는 서로 다르다. 두 노드 사이에 에지가 2개 이상 존재할 수 있다는 것에 유의하자.
  ### 출력
  - 1번째 줄부터 V개의 줄에 걸쳐, i번째 줄에 i번 노드까지 최단 경로값을 출력한다. 시작점은 0, 경로가 없을 때는 INF를 출력한다.
  ### 예제 입력1
  ```java
  5 6  // 노드 개수, 에지 개수
  1    // 출발 노드
  5 1 1
  1 2 2
  1 3 3
  2 3 4
  2 4 5
  3 4 6
  ```
  ### 예제 출력1
  ```java
  0
  2
  3
  7
  INF
  ```
  ### [1단계] 문제 분석하기
  - 시작점과 다른 노드와 관련된 최단 거리를 구하는 문제로, 다익스트라 알고리즘의 가장 기본적인 형태를 구현할 수 있는지를 묻고 있다. 앞에서 배운 핵심 이론을 이용해
    다익스트라 알고리즘을 코드로 구현해보자.
  ### [2단계] 손으로 풀어보기
  1. 인접 리스트에 노드를 저장하고 거리 배열을 초기화한다. 거리 배열은 앞에서 설명했듯이 ∞으로 초기화한다.
  2. 최초 시작점을 큐에 삽입하고, 다음 과정에 따라 다익스트라 알고리즘을 수행한다.
     1. 거리 배열에서 **아직 방문하지 않은** 노드 중 **현재 값이 가장 작은** 노드를 선택한다.
     2. 해당 노드와 연결된 노드들의 최단 거릿값을 다음 공식을 이용해 업데이트한다.
        * **Min (선택 노드의 거리 배열의 값 + 에지의 가중치, 연결 노드의 거리 배열의 값)** <br/>
            **---> 업데이트된 경우 연결 노드를 큐에 삽입**
     3. 큐가 빌 때까지 ⅰ~ⅱ를 반복한다.
  3. 완성된 거리 배열의 값을 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  자료구조 선언하기 (그래프 정보 저장, 최단 거리 저장, 노드 사용 여부 저장)
  V(노드 개수)
  E(에지 개수)
  K(출발 노드)
  거리 배열은 충분히 큰 수로 초기화하기
  for (노드 개수) {
    그래프 정보를 저장하는 인접 리스트 초기화하기
  }
  for (에지 개수) {
    인접 리스트 배열에 이 에지 정보를 저장하기
  }
  다익스트라 알고리즘 수행하기
  출발 노드는 우선순위 큐에 넣고 시작하기  // 자동으로 거리가 최소인 노드를 선택하게 함
  while (큐가 빌 때까지) {
    현재 선택된 노드가 방문된 적이 있는지 확인하기
    현재 노드를 방문 노드로 업데이트하기
    for (현재 선택 노드의 에지 개수) {
      if (타깃 노드 방문 전 && 현재 선택 노드 최단 거리 + 비용 < 타깃 노드의 최단 거리) {
        타깃 노드 최단 거리 업데이트하기
        우선순위 큐에 타깃 노드 추가하기
      }
    }
  }
  완성된 거리 배열을 탐색해 출력하기
  // 가중치가 있는 그래프를 담기 위한 클래스 별도 구현하기
  Edge {
    vertex(가리키는 노드)
    value(에지의 가중치)
    우선순위 큐 정렬 기준을 위해 compareTo 함수 구현하기
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam056_최단경로](src/book/ch08/exam056_최단경로.java)
### [문제 057] : 최소 비용 구하기 (0.5s)
  ### 문제
  - N개의 도시가 있다. 그리고 한 도시에서 출발해 다른 도시에 도착하는 M개의 버스가 있다. A번째 도시에서 B번째 도시까지 가는 데 드는 버스 비용을 최소화하려고 한다.
    A번째 도시에서 B번째 도시까지 가는 데 드는 최소 비용을 출력하라. 도시 번호는 1부터 N까지다.
  ### 입력
  - 1번째 줄에 도시의 개수 N(1≤N≤1,000), 2번째 줄에 버스의 개수 M(1≤M≤100,000)이 주어진다. 그리고 3번째 줄에서 M+2줄까지 다음과 같은 버스의 정보가 주어진다.<br/>
    가장 처음에는 그 버스의 출발 도시의 번호가 주어진다. 그다음에는 도착지의 도시 번호가 주어지고, 그 버스 비용이 주어진다. 버스 비용은 0보다 크거나 같고, 100,000보다
    작은 정수다. 그리고 M+3째 줄에는 우리가 구하고자 하는 구간 출발점의 도시 번호와 도착점의 도시 번호가 주어진다. 출발점에서 도착점을 갈 수 있을 때만 입력으로 주어진다.
  ### 출력
  - 1번째 줄의 출발 도시에서 도착 도시까지 가는 데 드는 최소 비용을 출력한다.
  ### 예제 입력1
  ```java
  5   // 도시 개수
  8   // 버스 개수
  1 2 2
  1 3 3
  1 4 1
  1 5 10
  2 4 2
  3 4 1
  3 5 1
  4 5 3
  1 5
  ```
  ### 예제 출력1
  ```java
  4
  ```
  ### [1단계] 문제 분석하기
  - 시작점과 도착점이 주어지고, 이 목적지까지 가는 최소 비용(최단 거리)을 구하는 문제이다. 또한 버스 비용의 범위가 음수가 아니기 때문에 이 문제는 다익스트라 알고리즘을
    이용해 해결할 수 있다. 도시의 개수가 최대 1,000개이므로 인접 행렬 방식으로도 그래프를 표현할 수 있지만, 시간 복잡도나 공간 효율성 측면을 고려해 인접 리스트의
    자료구조를 선택했다.
  ### [2단계] 손으로 풀어보기
  1. 주어진 예제 데이터를 기반으로 그래프를 그린다. 도시는 노드로, 도시 간 버스 비용은 에지로 나타낸다.
  2. 첫째 숫자(도시 개수)의 크기만큼 인접 리스트 배열의 크기를 설정한다. 이때 버스의 비용(가중치)이 존재하므로 인접 리스트 배열의 자료형이 될 클래스를 선언한다.
     그리고 둘째 숫자(버스 개수)의 크기만큼 반복문을 돌면서 그래프를 리스트 배열에 저장한다.
  3. 다익스트라 알고리즘을 수행한다. 최단 거리 배열이 완성되면 정답을 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  필요한 자료구조 선언하기 (그래프 정보 저장, 최단 거리 저장, 노드 사용 여부 저장)
  N(노드 수) M(에지 수)
  선언한 변수들을 초기화하기
  거리 배열은 충분히 큰 수로 초기화하기
  for (노드 개수) {
    그래프 정보를 저장하는 인접 리스트 초기화하기
  }
  for (에지 개수) {
    인접 리스트 배열에 이 에지 접오를 저장하기
  }
  startIndex (시작점)
  endIndex (도착점)
  시작점을 기준으로 다익스트라 수행
  최단 거리 배열에서 목적지 길이를 찾아 출력하기
  // 다익스트라 함수 별도 구현
  다익스트라 (시작점, 도착점) {
    시작점을 오름차순 우선순위 큐에 넣고 시작
    // 자동으로 거리가 최소인 노드를 선택할 수 있도록 해 주는 자료구조
    while (큐가 빌 때까지) {
      현재 선택된 노드가 방문한 적이 있는지 확인
      현재 노드를 방문 노드로 업데이트
      for (현재 선택 노드의 에지 개수) {
        if (타깃 노드 방문 전 && 현재 선택 노드 최단 거리 + 비용 < 타깃 노드의 최단 거리) {
          타깃 노드 최단 거리 업데이트
          우선순위 큐에 타깃 노드 추가
        }
      }
    }
    // 가중치가 있는 그래프를 담기 위한 클래스 별도 구현하기
    Edge {
      vertex (가리키는 노드)
      value (에지의 가중치)
      우선순위 큐 정렬 기준을 위해 compareTo() 함수 구현하기
    }
  ```
  ### [4단계] 코드 구현하기
  - [exam057_최소비용구하기](src/book/ch08/exam057_최소비용구하기.java)
  #### 현재 사용할 수 있는 노드를 우선순위 큐 자료구조에 넣은 이유
  - 이 문제에서 현재 사용할 수 있는 노드들을 **`우선순위 큐`** 자료구조에 넣은 이유는 현재 연결된 노드 중 **가장 적은 비용**을 지니고 있는 노드를 빠르고 간편하게
    찾을 수 있기 때문이다. 우선순위 큐는 데이터가 새롭게 들어올 때마다 자동으로 정렬한다.<br/>
    정렬 기준은 위 구현 코드에서 알 수 있듯이 Node 클래스에서 적절한 **`compareTo()`** 함수를 이용해 설정할 수 있다. compareTo() 함수는 클래스의 정렬이 필요할 때
    가장 보편적으로 사용하는 방식이므로 숙지해 두는 것이 좋다.
### [문제 058] : K번째 최단 경로 찾기 (2s)
  ### 문제
  - 봄 캠프를 마친 김 조교는 여러 도시를 돌며 여행을 다닐 계획이다. 그런데 김 조교는 '느림의 미학'을 중요시하는 사람이라 항상 최단 경로로만 이동하는 것은 별로 좋아하지
    않는다. 하지만 너무 시간이 오래 걸리는 경로도 그리 매력적인 것만은 아니어서 적당한 타협안인 'K번째 최단 경로'를 구하길 원한다. 그를 돕기 위한 프로그램을 작성해 보자.
  ### 입력
  - 1번째 줄에 n,m,k가 주어진다. (1≤n≤1000, 0≤m≤2000000, 1≤k≤100) n과 m은 각각 김 조교가 여행을 고려하고 있는 도시들의 개수와 도시 간에 존재하는 도로의 수다.
    이어지는 m개의 줄에는 각각 도로의 정보를 제공하는 3개의 정수 a,b,c가 포함돼 있다. 이것은 a번 도시에서 b번 도시로 갈 때는 c의 시간이 걸린다는 의미다(1≤a,b≤n, 1≤c≤1000).
    도시의 번호는 1번부터 n번까지 연속해 있고, 1번은 시작 도시다.
  ### 출력
  - n개의 줄을 출력한다. i번째 줄에 1번 도시에서 i번 도시로 가는 K번째 최단 경로의 소요 시간을 출력한다. 경로의 소요 시간은 경로 위에 있는 도로들을 따라 이동하는 데 필요한
    시간들의 합이다. i번 도시에서 i번 도시로 가는 최단 경로는 0이지만, 일반적인 K번째 최단 경로는 0이 아닐 수 있다는 것에 유의한다. 또 K번째 최단 경로가 존재하지 않으면
    -1을 출력한다. 최단 경로에 같은 노드가 여러 번 포함될 수 있다.
  ### 예제 입력1
  ```java
  5 10 2   // 도시 수, 도로 수, K
  1 2 2
  1 3 7
  1 4 5
  1 5 6
  2 4 2
  2 3 4
  3 4 6
  3 5 8
  5 2 4
  5 4 1
  ```
  ### 예제 출력1
  ```java
  -1
  10
  7
  5
  14
  ```
  ### [1단계] 문제 분석하기
  - 시작점과 도착점이 주어지고 이 목적지까지 가는 K번째 최단 경로를 구하는 문제이다. 도시(노드)의 개수는 1,000개, 도로(에지)의 수는 2,000,000이면서 시간 제약이 2초이므로
    다익스트라 알고리즘으로 접근해보자. 이 문제에서 가장 고민되는 부분은 최단 경로가 아니라 K번째 최단 경로라는 것이다.
    #### [K번째 최단 경로 해결 방법]
    - 최단 경로를 표현하는 배열을 **우선순위 큐 배열(크기는 K)** 로 변경하고자 한다. 이렇게 하면 최단 경로뿐 아니라 최단 경로 ~ K번째 최단 경로까지 표현할 수 있다.
    - 사용한 노드는 방문 배열에 확인해 두고 재사용하지 않는 로직은 삭제가 필요해 보인다. K번째 경로를 찾기 위해서는 **노드를 여러 번 쓰는 경우** 가 생기기 때문이다.
  ### [2단계] 손으로 풀어보기
  1. 주어진 예제 데이터를 기반으로 그래프를 그린다. 도시는 노드로, 도로는 에지로 나타낸다.
  2. 변수를 선언하고, 그래프 데이터를 받는 부분은 모두 일반적인 다익스트라 알고리즘 준비 과정과 동일하다.
  3. 최단 거리 배열을 우선순위 큐 배열로 선언하고, 다음과 같은 기준을 세워 채워야 한다.
     #### [최단 거리 배열 세우기 규칙]
     >1. 현재 노드에 저장된 경로가 **K개 미만일 때 신규 경로를 추가**한다.
     >2. 경로가 K개일 때 현재 경로 중 최대 경로와 신규 경로를 비교해 **신규 경로가 더 작을 때 업데이트**한다. 우선순위 큐를 사용하면 이 로직을 쉽게 구현할 수 있다.
     >3. K번째 경로를 찾기 위해서는 노드를 여러 번 쓰는 경우가 생기므로 사용한 노드는 방문 배열에 확인해 두고 재사용하지 않는 로직을 삭제한다.
        
  4. 최단 거리 배열을 탐색하면서 K번째 경로가 존재하면 출력하고, 존재하지 않으면 -1을 출력한다.
  - #### 우선순위 큐로 선언하면 편리한 점
    - 이 부분에서 최단 거리 배열의 객체 형식을 우선순위 큐로 선언했기 때문에 새로운 노드가 삽입됐을 때 별도로 정렬을 해주지 않아도 자동으로 정렬돼 편리하게 구현할 수
      있다는 장점이 있다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(노드 개수) M(에지 개수)
  K(몇 번째 최단 경로를 구해야 하는지 나타내는 변수)
  W(그래프 정보 저장 인접 행렬)
  for (노드 개수 + 1) {
    최단 거리 큐 배열 초기화하기
  }
  for (에지 개수) {
    인접 행렬에 에지 정보를 저장하기
  }
  다익스트라 알고리즘 수행하기
  출발 노드는 우선순위 큐에 넣고 시작하기   // 자동으로 거리가 최소인 노드를 선택할 수 있음
  while (큐가 빌 때까지) [
    for (노드 개수만큼 반복하기) {    // 시간 복잡도 측면에서 인접 행렬 구조가 불리함
      if (해당 노드와 현재 노드가 연결돼 있으면) {
        if (최단 거리 큐 배열에 해당 노드에 관해 저장된 경로가 K개보다 작으면) {
          최단 거리 큐 배열에 거리 정보 삽입하고 큐에 선택 노드를 추가하기
        } else if (최단 거리 큐의 마지막 값 > 이전 노드의 값 + 두 노드 사이의 에지 가중치) {
          해당 노드에 최단 거리 큐에 마지막값 삭제하고 신규값으로 업데이트하기
          큐에 선택 노드를 추가하기
        }
      }
    }
  }
  for (노드 개수) {                // 최단 거리 배열 큐를 이용해 각 노드의 K번째 경로를 출력함
    우선순위 큐 크기가 K이면 큐의 값 출력, 아니면 -1 출력
  }
  Node {                           // 가중치가 있는 그래프를 담기 위한 클래스 별도 구현하기
    node (가리키는 노드(
    cost (에지의 가중치)
    우선순위 큐 정렬 기준을 위해 compareTo 함수 구현하기
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam058_K번째최단경로찾기](src/book/ch08/exam058_K번째최단경로찾기.java)

# 5. 벨만-포드
- **`벨만-포드(bellman-ford-moore)`** 알고리즘은 그래프에서 최단 거리를 구하는 알고리즘으로, 주요 특징은 다음과 같다.

  |기능|특징|시간 복잡도 (노드 수: V, 에지 수: E)|
  |:---|:---|:---|
  |특정 출발 노드에서 다른 모든<br/> 노드까지의 **최단 경로** 탐색|* **음수 가중치** 에지가 있어도 수행할 수 있음<br/>* 전체 그래프에서 **음수 사이클** 의 존재 여부를<br/>&nbsp;&nbsp;판단할 수 있음|O(VE)|

## 벨만-포드 알고리즘 원리
### 1. 에지 리스트로 그래프를 구현하고 최단 경로 배열 초기화하기
- 벨만-포드 알고리즘은 **에지를 중심으로 동작**하므로 그래프를 **`에지 리스트`** 로 구현한다.<br/>
  또한 최단 겨오 배열은 출발 노드는 0, 나머지 노드는 무한대로 초기화한다.
  - [edge 클래스]는 일반적으로 **노드 변수 2개**와 **가중치** 변수로 구성돼 있다.
### 2. 모든 에지를 확인해 정답 배열 업데이트하기
- 최단 거리 배열에서 업데이트 **반복 횟수**는 **`노드 개수 - 1`** 이다. 노드 개수가 N이고, 음수 사이클이 없을 때 **특정 두 노드의 최단 거리를 구성할 수 있는 에지의
  최대 개수는 N-1**이기 때문이다. 특정 에지 E = (s, e, w)에서 다음 조건을 만족하면 업데이트를 실행한다.
  #### [업데이트 조건과 방법]
  - **`D[s] != ∞` && `D[e] > D[s] + w`** ⇒ **D[e] = D[s] + w**
    - 음수 사이클이 없을 때 최대 에지 개수가 나오려면 사향 트리 형태에서 양 도착 노드를 선택해야 한다.
    - 에지의 출발 노드를 s, 종료 노드를 e, 에지의 가중치를 w로 가정하였다.
  
  음수 사이클이 없을 때 N-1번 에지 사용 횟수를 반복하면 출발 노드와 모든 노드 간의 최단 거리를 알려 주는 정답 배열에 완성된다. 이렇게 완성 후 마지막으로 이 그래프에
  음수 사이클이 존재하는지 확인해야 한다.
### 3. 음수 사이클 유무 확인하기
- 음수 사이클 유무를 확인하기 위해 **모든 에지를 한 번씩 다시 사용해 업데이트되는 노드가 발생하는지 확인**한다.<br/>
  만약 업데이트되는 노드가 있다면 **`음수 사이클이 있다`** 는 뜻이 되고, 2단계에서 도출한 정답 배열이 무의미하고 **`최단 거리를 찾을 수 없는 그래프`** 라는 뜻이 된다.
  음수 사이클이 존재하면 이 사이클을 무한하게 돌수록 가중치가 계속 감소하므로 최단 거리를 구할 수 없다.
### [문제 059] : 타임머신으로 빨리 가기 (1s)
  ### 문제
  - N개의 도시와 한 도시에서 출발해 다른 도시에 도착하는 버스가 M개 있다. 각 버스는 A, B, C로 나타낼 수 있는데, A는 시작 도시, B는 도착 도시, C는 버스를 타고 이동하는
    데 걸리는 시간이다. 시간 C가 양수가 아닐 때가 있다. C=0일 경우에는 순간 이동을 할 때, C<0일 경우에는 타임머신으로 시간을 되돌아갈 때다.<br/>
    1번 도시에서 출발해 나머지 도시로 가는 가장 빠른 시간을 구하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 도시의 개수 N(1≤N≤500), 버스 노선의 개수 M(1≤M≤6,000)이 주어진다.
    2번째 줄부터 M개의 줄에는 버스 노선의 정보 A,B,C(1≤A,B≤N, -10,000≤C≤10,000)가 주어진다.
  ### 출력
  - 만약 1번 도시에서 출발해 어떤 도시로 가는 과정에서 시간을 무한히 오래 전으로 되돌릴 수 있다면 1번째 줄에 -1을 출력한다.
    그렇지 않다면 N-1개의 줄에 걸쳐 각 줄의 1번 도시에서 출발해 2번 도시, 3번 도시, ..., N번 도시로 가는 가장 빠른 시간을 순서대로 출력한다.
    만약 이 도시로 가는 경로가 없다면 -1을 출력한다.
  ### 예제 입력1
  ```java
  3 4   // 노드, 에지
  1 2 4
  1 3 3
  2 3 -4
  3 1 -2
  ```
  ### 예제 출력1
  ```java
  -1
  ```
  ### 예제 입력2
  ```java
  3 2
  1 2 4
  1 2 3
  ```
  ### 예제 출력2
  ```java
  3
  -1
  ```
  ### [1단계] 문제 분석하기
  - 시작점 및 다른 노드와 관련된 최단 거리를 구하는 문제지만, 특이한 점은 에지에 해당하는 이동 시간이 양수가 아닌 0 또는 음수가 가능하다는 것이다. 이렇게 시작점에서
    다른 노드와 관련된 최단 거리를 구하는데, 에지가 음수가 가능한 경우 벨만-포드 알고리즘을 사용하면 된다.
  ### [2단계] 손으로 풀어보기
  1. 에지 리스트에 에지 데이터를 저장한 후 거리 배열을 다음과 같이 초기화한다. 최초 시작점에 해당하는 거리 배열값은 0으로 초기화한다.
  2. **벨만-포드 알고리즘 수행 과정**
     1. 모든 에지와 관련된 정보를 가져온 후 다음 조건에 따라 종료 노드의 거리 배열값을 업데이트한다.
        - **`출발 노드가 방문한 적이 없는 노드(출발 노드 거리 == INF)`** ⇒ **업데이트 X**
        - **`출발 노드의 거리 배열값 + 에지 가중치 < 종료 노드의 거리 배열값`** ⇒ **업데이트 O**
     2. **`노드 개수 - 1`** 번만큼 ⅰ을 반복한다.
     3. 음수 사이클 유무를 알기 위해 모든 에지에 관해 다시 한번 ⅰ을 수행한다.<br/>
        이때 한 번이라도 **값이 업데이트**되면 **`음수 사이클이 존재한다`** 고 판단한다.
  - 실제로 수행할 때는 에지가 저장된 순서에 따라 동작하므로 거리 배열의 값이 이론의 업데이트와는 약간 다르지만, 알고리즘의 결과는 동일하다.
  3. 음수 사이클이 존재하면 -1, 존재하지 않으면 거리 배열의 값을 출력한다. 단, 거리 배열의 값이 INF일 경우에는 -1을 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  자료구조 선언하기 (그래프 정보 저장, 최단 거리 저장 배열)
  N(노드 개수)
  M(에지 개수)
  Edges(에지 리스트 배열)
  거리 배열은 충분히 큰 수로 초기화하기
  for (에지 개수) {
    에지 리스트 배열에 이 에지 정보를 저장하기
  }
  // 벨만-포드 알고리즘 수행하기
  거리 배열에 출발 노드를 0으로 초기화하기
  for (노드 개수 - 1) {
    for (에지 개수) {
      현재 에지 데이터 가져오기
      if (출발 노드가 무한대가 아님 && 종료 노드값 > 출발 노드값 + 에지 가중치)
        업데이트 수행 → 종료 노드값 = 출발 노드값 + 에지 가중치
    }
  }
  for (에지 개수) {   // 음수 사이클 존재 여부 확인하기
    현재 에지 데이터 가져오기
    if (출발 노드가 무한대가 아님 && 종료 노드값 > 출발 노드값 + 에지 가중치)
      업데이트 가능 → 음수 사이클 존재
  }
  음수 사이클 미존재 → 거리 배열 출력하기 (단, 거리 배열의 값이 무한대일 때 -1 출력)
  음수 사이클 존재 → -1 출력하기
  // 에지를 담기 위한 클래스 별도 구현하기
  Edge {
    start (출발 노드)
    end (종료 노드)
    value (에지의 가중치)
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam059_타임머신](src/book/ch08/exam059_타임머신.java)
### [문제 060] : 세일즈맨의 고민 (2s)
  ### 문제
  - 오민식은 세일즈맨이다. 오민식의 나라에는 N개의 도시가 있다. 도시는 0번부터 N-1번까지 번호가 매겨져 있다. 오민식은 A 도시에서 시작해 B 도시에서 끝나는 출장으로
    최대한 많은 돈을 벌고 싶다.<br/>
    오민식이 이용할 수 있는 교통수단에는 여러 가지가 있다. 오민식은 모든 교통수단의 출발 도시와 도착 도시를 알고 있고, 비용도 알고 있다. 더욱이 오민식은 각각의 도시를
    방문할 때마다 벌 수 있는 돈을 알고 있다. 해당 값은 도시마다 다르고, 액수는 고정돼 있다. 같은 도시를 여러 번 방문할 수 있고, 도시를 방문할 때마다 그 돈을 벌게 된다.
    오민식이 버는 돈보다 쓰는 돈이 많다면 도착 도시에 도착할 때 지니고 있는 돈의 액수가 음수가 될 수도 있다. 모든 교통 수단은 입력으로 주어진 방향으로만 이용할 수 있고,
    여러 번 이용할 수도 있다.<br/>
    오민식은 도착 도시에 도착할 때 지니고 있는 돈의 액수를 최대로 하려고 한다. 이 최댓값을 구하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 도시의 수 N과 시작 도시, 도착 도시 그리고 교통 수단의 개수 M이 주어진다. 2번째 줄부터 M개의 줄에는 교통 수단의 정보가 주어진다. 교통 수단의 정보는
    '시작 끝 가격'과 같은 형식이다. 마지막 줄에는 오민식이 각 도시에서 벌 수 있는 돈의 최댓값이 0번부터 차례대로 주어진다. N과 M은 100보다 작거나 같고, 돈의 최댓값과
    교통 수단의 가격은 1,000,000보다 작거나 같은 음이 아닌 정수다.
  ### 출력
  - 1번째 줄에 도착 도시에 도착할 때 지니고 있는 돈의 액수의 최댓값을 출력한다. 만약 오민식이 도착 도시에 도착할 수 없을 때는 'gg'를 출력한다. 그리고 오민식이 도착 도시에
    도착했을 때 돈을 무한히 많이 지니고 있을 수 있다면 'Gee'를 출력한다.
  ### 예제 입력1
  ```java
  5 0 4 5   // 노드 수, 시작 도시, 도착 도시, 에지 수
  0 1 10
  1 2 10
  2 3 10
  3 1 10
  2 4 10
  0 10 10 110 10
  ```
  ### 예제 출력1
  ```java
  Gee
  ```
  ### 예제 입력2
  ```java
  5 0 4 7
  0 1 13
  1 2 17
  2 4 20
  0 3 22
  1 3 4747
  2 0 10
  3 4 10
  0 0 0 0 0
  ```
  ### 예제 출력2
  ```java
  -32
  ```
  ### 예제 입력3
  ```java
  3 0 2 3
  0 1 10
  1 0 10
  2 1 10
  1000 1000 47000
  ```
  ### 예제 출력3
  ```java
  gg
  ```
  ### 예제 입력4
  ```java
  2 0 1 2
  0 1 1000
  1 1 10
  11 11
  ```
  ### 예제 출력4
  ```java
  Gee
  ```
  ### 예제 입력5
  ```java
  1 0 0 1
  0 0 10
  7
  ```
  ### 예제 출력5
  ```java
  7
  ```
  ### 예제 입력6
  ```java
  5 0 4 7
  0 1 13
  1 2 17
  2 4 20
  0 3 22
  1 3 4747
  2 0 10
  3 4 10
  8 10 20 1 100000
  ```
  ### 예제 출력6
  ```java
  99988
  ```
  ### [1단계] 문제 분석하기
  - 벨만-포드 알고리즘의 원리를 바탕으로 요구사항에 따라 내부 로직을 바꿔야 하는 문제이다. 기존 벨만-포드는 최단 거리를 구하는 알고리즘이지만, 이 문제에서는 도착 도시에
    도착할 때 돈의 액수를 최대로 하고 싶기 때문에 **업데이트 방식을 반대로 변경**해야 한다. 또한 돈을 무한히 많이 버는 케이스가 있다고 하는 것을 바탕으로 음수 사이클이
    아닌 **양수 사이클**을 찾도록 변경해야 한다.<br/>
    그리고 마지막 예외 처리가 1개 필요하다. 바로 **`양수 사이클이 있어도 출발 노드에서 이 양수 사이클을 이용해 도착 도시에 가지 못할 때`** 이다. 이 부분을 해결할 수
    있는 방법에는 여러 가지가 있는데, 여기서는 에지의 업데이트를 N-1번이 아닌 **충분히 큰 수(도시 개수 N의 최대치 = 100)만큼 추가로 돌리면서 업데이트를 수행**하도록 로직을
    변경하여 해결하고자 한다. 이렇게 변경하는 이유는 에지를 충분히 탐색하면서 **양수 사이클에서 도달할 수 있는 모든 노드를 양수 사이클에 연결된 노드로 업데이트**하기 위해서이다.
  ### [2단계] 손으로 풀어보기
  1. 에지 리스트에 에지 데이터를 저장하고, 거리 배열값을 초기화한다. 최초 시작점에 해당하는 거리 배열값은 0으로 초기화한다.
  2. **변형된 벨만-포드 알고리즘**
     1. 모든 에지와 관련된 정보를 가져와 다음 조건에 따라 거리 배열의 값을 업데이트한다.
        - **시작 도시가 방문한 적이 없는 도시일 때(시작 도시 == MIN)** ⇒ **업데이트X**
        - **시작 도시가 양수 사이클과 연결된 도시일 때(시작 도시 == MAX)**  ⇒ **업데이트O** (도착 도시도 양수 사이클과 연결된 도시로 업데이트)
        - **`도착 도시값 < 시작 도시값 + 도착 도시 수입 - 에지 가중치`**  ⇒ **업데이트O** (더 많이 벌 수 있는 새로운 경로)
     2. 노드보다 충분히 많은 값(N+100)으로 ⅰ을 반복한다.
     3. 도착 도시의 값에 따라 결과를 출력한다.
        - MIN(도착하지 못할 때) : 'gg'
        - MAX(무한히 많이 벌 수 있을 때) : 'Gee'
        - 이외 : 도착 도시의 배열값 출력
  ### [3단계] 슈도코드 작성하기
  ```java
  N(노드 개수), M(에지 개수)
  sCity(출발 도시), eCity(도착 도시)
  Edges(에지 리스트 배열), cityMoney(각 도시에서 버는 수입 배열)
  거리 배열은 충분히 작은 수로 초기화하기(Long.MIN_VALUE)
  for (에지 개수) {
    에지 리스트 배열에 이 에지 정보를 저장하기
  }
  // 변형된 벨만-포드 알고리즘 수행하기
  거리 배열에 출발 노드 sCityMoney[출발 노드]로 초기화하기
  for (노드 개수 + 100) {    // 양수 사이클이 전파되도록 충분히 큰 수로 반복하기) {
    for (에지 개수) {
      현재 에지 데이터 가져오기
      if (출발 노드가 방문하지 않은 노드 → 값이 Long.MIN_VALUE) Skip
      else if (출발 노드가 양수 사이클에 연결된 노드 → 값이 Long.MAX_VALUE)
        종료 노드를 양수 사이클에 연결된 노드로 업데이트 → 값 = Long.MAX_VALUE
      else if (종료 노드의 값 < 출발 노드의 값 + 도착 도시에서의 수입 - 에지의 가중치) {
        // 더 많은 수입을 얻는 경로가 새로 발견될 때
        종료 노드의 값 = 출발 노드의 값 + 도착 도시에서의 수입 - 에지의 가중치로 업데이트
        if (N-1 반복 이후 업데이트될 때) 이 종료 노드를 양수 사이클 연결 노드로 업데이트
      }
    }
  }
  // 도착 도시의 값에 따른 결과 출력하기
  도착 도시가 Long.MIN_VALUE : 도착 불가 → "gg" 출력하기
  도착 도시가 Long.MAAX_VLAUE : 돈을 무한대로 벌 수 있음 → "Gee" 출력하기
  이외의 경우 →  도착 도시의 값을 출력하기
  // 에지를 담기 위한 클래스 별도 구현하기
  Edge {
    start (출발 노드)
    end (도착 노드)
    value (에지의 가중치)
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam060)_세일즈맨의 고민](src/book/ch08/exam060_세일즈맨의고민.java)

# 6. 플로이드-워셜
- **`플로이드 워셜(floyd-warshall)`** 알고리즘은 그래프에서 최단 거리를 구하는 알고리즘으로, 주요 특징은 다음과 같다.
  
  |기능|특징|시간 복잡도 (노드수: V)|
  |:---|:---|:---|
  |모든 노드 간에 최단<br/>경로 탐색|* 음수 가중치 에지가 있어도 수행할 수 있음<br/>* **동적 계획법**의 원리를 이용해 알고리즘에 접근|O(V^3)|

## 플로이드-워셜 점화식
- 플로이드-워셜 알고리즘을 도출하는 가장 핵심적인 원리는 A노드에서 B노드까지 최단 경로를 구했다고 가정했을 때 최단 경로 위에 K 노드가 존재한다면
  그것을 이루는 부분 경로 역시 최단 경로라는 것이다. 즉, 전체 경로의 최단 경로는 부분 경로의 최단 경로의 조합으로 이뤄진다는 의미가 된다.
  - **`D[S][E] = Math.min(D[S][E], D[S][K] + D[K][E])`**
## 플로이드-워셜 알고리즘 구현 방법
### 1. 배열을 선언하고 초기화하기
- D[S][E]는 노드 S에서 노드 E까지의 최단 거리를 저장하는 배열이라 정의한다. **S와 E의 값이 같은 칸은 `0`, 다른 칸은 `∞`로 초기화**한다.
  여기에서 S == E는 자기 자신에게 가는 데 걸리는 최단 경로값을 의미하기 때문이다.
### 2. 최단 거리 배열에 그래프 데이터 저장하기
- 출발 노드는 S, 도착 노드는 E, 이 에지의 가중치는 W라고 했을 때 D[S][E] = W로 에지의 정보를 배열에 입력한다.
  이로써 플로이드-워셜 알고리즘은 그래프를 **`인접 행렬`** 로 표현한다는 것을 알 수 있다.
### 3. 점화식으로 배열 업데이트하기
- 기존에 구했던 점화식을 3중 for 문의 형태로 반복하면서 배열의 값을 업데이트한다.
  #### 플로이드-워셜 알고리즘 로직
  ```
  for 경유지 K에 관해 (1~N)  // N: 노드 개수
    for 출발 노드에 관해 (1~N)
      for 도착 노드에 관해 (1~N)
        D[S][E] = Math.min(D[S][E], D[S][K] + D[K][E])
  ```
  - 완성된 배열은 모든 노드 간의 최단 거리를 알려준다. 예를 들어 1번 노드에서 5번 노드까지 가는 최단 거리는 D[1][5] = 6으로 나타난다는 것을 알 수 있다.

## 플로이드-워셜 알고리즘의 특징
- 플로이드-워셜 알고리즘은 모든 노드 간의 최단 거리를 확인해 주기 때문에 시간 복잡도가 O(V^3)으로 빠르지 않은 편이다.
  이에 따라 플로이드-워셜 알고리즘을 사용해야 하는 문제가 나오면 일반적으로 노드의 개수의 범위가 다른 그래프에 비해 적게 나타나는 것을 알 수 있다.

### [문제 061] : 가장 빠른 버스 노선 구하기 (1s)
  ### 문제
  - n(2≤n≤100)개의 도시가 있다. 그리고 한 도시에서 출발해 다른 도시에 도착하는 m(1≤m≤100,000)개의 버스가 있다. 각 버스는 한 번 사용할 때 필요한 비용이 있다.
    모든 도시의 쌍(A,B)에 관해 도시 A에서 B로 가는 데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 도시의 개수 n, 2번째 줄에 버스의 개수 m이 주어진다. 그리고 3번째 줄에서 m+2줄까지 다음과 같은 버스의 정보가 주어진다.<br/>
    먼저 처음에는 그 버스의 출발 도시으 번호가 주어진다. 버스의 정보는 버스의 시작 도시 a, 도착 도시 b, 한 번 타는 데 필요한 비용 c로 이뤄져 있다.
    시작 도시와 도착 도시가 같은 경우는 없다. 비용은 100,000보다 작거나 같은 자연수다. 시작 도시와 도착 도시를 연결하는 노선은 1개가 아닐 수 있다.
  ### 출력
  - n개의 줄을 출력해야 한다. i번째 줄에 출력하는 j번째 숫자는 도시 i에서 j로 가는 데 필요한 최소 비용이다. 만약, i에서 j로 갈 수 없을 때는 그 자리에 0을 출력한다.
  ### 예제 입력1
  ```java
  5    // 도시 개수
  14   // 노선 개수
  1 2 2
  1 3 3
  1 4 1
  1 5 10
  2 4 2
  3 4 1
  3 5 1
  4 5 3
  3 5 10
  3 1 8
  1 4 2
  5 1 7
  3 4 2
  5 2 4
  ```
  ### 예제 출력1
  ```java
  0 2 3 1 4
  12 0 15 2 5
  8 5 0 1 1
  10 7 13 0 3
  7 4 10 6 0
  ```
  ### [1단계] 문제 분석하기
  - 모든 도시에 쌍과 관련된 최솟값을 찾아야 하는 문제이다. 그래프에서 시작점을 지정하지 않고, 모든 노드와 관련된 최소 경로를 구하는 알고리즘이 바로 플로이드-워셜
    알고리즘이다. 도시의 최대 개수가 100개로 매우 작은 편이므로 O(N^3) 시간 복잡도의 플로이드-워셜 알고리즘으로 문제를 해결할 수 있다.
  ### [2단계] 손으로 풀어보기
  1. 버스 비용 정보를 인접 행렬에 저장한다. 먼저 인접 행렬을 초기화한다. 연결 도시가 같으면(i==j) 0, 아니면 충분히 큰 수로 값을 초기화하면 된다. 그리고 주어진 버스
     비용 데이터값을 인접 행렬에 저장한다.
  2. 플로이드-워셜 알고리즘을 수행한다. 다음 점화식을 이용한 3중 for문으로 모든 중간 경로를 탐색한다.
     #### [플로이드-워셜 점화식]
     ```
     // 두 도시의 연결 비용 중 최솟값
     Math.min(distance[S][E], distance[S][K] + distance[K][E])
     ```
  3. 알고리즘으로 변경된 인접 행렬을 출력한다. 인접 행렬 자체가 모든 쌍의 최단 경로를 나타내는 정답 배열이다. 정답 배열을 그대로 출력하되, 문제의 요구사항에 따라
     두 도시가 도달하지 못할 때(∞)는 0, 아닐 때는 배열의 값을 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(도시 개수) M(노선 개수)
  distance(노선 데이터를 저장하는 인접 행렬)
  for (i → N만큼 반복하기) {
    for (j → N만큼 반복하기) {
      시작 도시와 종료 도시가 같으면 0, 아니면 충분히 큰 수로 저장하기
    }
  }
  for (M만큼 반복하기) {
    노선 데이터를 distance 배열에 저장하기
  }
  for (k → N만큼 반복하기) {      // 3중 for 문의 순서가 중요함. k가 가장 바깥쪽이 돼야 함
    for (i → N만큼 반복하기) {
      for (j → N만큼 반복하기) {
        distance[i][j]에 distance[i][k] + distance[k][j] 값들 중 최솟값 넣기
        i~j 사이에 가능한 모든 경로를 탐색하기
      }
    }
  }
  정답 배열 출력하기 → 만약 정답 배열의 값이 최초 초기화하기에 충분한 큰 수일 경우에는 도착할 수 없는 경로이기 때문에 0을 출력 아니면 거리 배열 값 출력하기
  ```
  ### [4단계] 코드 구현하기
  - [exam061_플로이드](src/book/ch08/exam061_플로이드.java)
### [문제 062] : 경로 찾기 (1s)
  ### 문제
  - 가중치 없는 방향 그래프 G가 주어졌을 때 모든 노드(i,j)에 관해 i에서 j로 가는 경로가 있는지 여부를 구하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 노드의 개수 N(1≤N≤100), 2번째 줄부터 N개의 줄에 그래프의 인접 행렬이 주어진다. i번째 줄의 j번째 숫자가 1일 경우에는 i에서 j로 가는 에지가 존재한다는
    뜻이고, 0일 경우에는 없다는 뜻이다. i번째 줄의 i번째 숫자는 항상 0이다.
  ### 출력
  - 총 N개의 줄에 걸쳐 문제의 정답을 인접 행렬 형식으로 출력한다. 노드 i에서 j로 가는 경로가 있으면 i번째 줄의 j번째 숫자를 1, 없으면 0을 출력해야 한다.
  ### 예제 입력1
  ```java
  3   // 인접 행렬의 크기
  0 1 0
  0 0 1
  1 0 0
  ```
  ### 예제 출력1
  ```java
  1 1 1
  1 1 1
  1 1 1
  ```
  ### 예제 입력2
  ```java
  7
  0 0 0 1 0 0 0
  0 0 0 0 0 0 1
  0 0 0 0 0 0 0
  0 0 0 0 1 1 0
  1 0 0 0 0 0 0
  0 0 0 0 0 0 1
  0 0 1 0 0 0 0
  ```
  ### 예제 출력2
  ```java
  1 0 1 1 1 1 1
  0 0 1 0 0 0 1
  0 0 0 0 0 0 0
  1 0 1 1 1 1 1
  1 0 1 1 1 1 1
  0 0 1 0 0 0 1
  0 0 1 0 0 0 0
  ```
  ### [1단계] 문제 분석하기
  - 플로이드-워셜 알고리즘을 이해하고 있고, 문제의 요구사항에 따라 적절하게 수정할 수 있는지를 묻는 문제이다. 모든 노드 쌍에 관해 경로가 있는지 여부를 확인하는 방법은
    플로이드-워셜 알고리즘을 수행해 결과 배열을 그대로 출력하면 된다. 단, 최단 거리를 구하는 문제가 아니기 때문에 기존 플로이드-워셜 알고리즘에서 최단 거리를 업데이트하는
    부분만 조금 수정해 줄 필요가 있다.
  ### [2단계] 손으로 풀어보기
  1. 입력 데이터를 인접 행렬에 저장한다.
  2. 변경된 플로이드-워셜 알고리즘을 수행한다. S와 E가 모든 중간 경로(K) 중 1개라도 연결돼 있다면 S와 E는 연결 노드로 저장한다.
  3. 알고리즘으로 변경된 인접 행렬을 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(인접 행렬의 크기)
  distance(노선 데이터를 저장하는 인접 행렬)
  for (i → N만큼 반복하기) {
    for (j → N만큼 반복하기) {
      인접 행렬 데이터를 distance 행렬에 그대로 저장하기
    }
  }
  for (k → N만큼 반복하기) {   // 3중 for 문의 순서가 중요함. k가 가장 바깥쪽이 돼야 함
    for (i → N만큼 반복하기) {
      for (j → N만큼 반복하기) {
        i~j 사이에 가능한 모든 경로를 탐색하기
        만약 distance[i][k] == 1이고, distance[k][j] == 1이면 distance[i][j] = 1로 저장
        // k를 거치는 모든 경로 중 1개라도 연결돼 있는 경로가 있다면 i와 j는 연결 노드로 취급
      }
    }
  }
  distance 배열 출력하기
  ```
  - i와 j의 중간 지점인 k 중 연결되지 않은 부분이 있다면, 그 부분으로 인해 연결된 경로가 1개 이상이 있음에도 불구하고 인접 행렬의 값이 0으로 수정될 수 있다는 점을 생각하였다.
    이를 방지하기 위한 구현 방법을 생각하다가 이는 생각할 필요가 없는 부분임을 깨닫게 되었다.<br/>인접 행렬 값이 바뀔 때의 조건문은 연결된 부분이 있을 때만을 고려하기 때문이다. 
  ### [4단계] 코드 구현하기
  - [exam062_경로찾기](src/book/ch08/exam062_경로찾기.java)
### [문제 063] : 케빈 베이컨의 6단계 법칙 (2s)
  ### 문제
  - 케빈 베이컨의 6단계 법칙에 따르면 지구에 있는 모든 사람은 최대 6단계 이내에서 서로 아는 사람으로 연결될 수 있다. 케빈 베이컨 게임은 임의의 두 사람이 최소 몇 단계 만에
    이어질 수 있는지 계산하는 게임이다. 케빈 베이컨 수는 모든 사람과 케빈 베이컨 게임을 했을 때 나오는 단계의 합이다. 예를 들어 백준 온라인 저지의 유저가 5명, 1과 3, 1과 4,
    2와 3, 3과 4, 4와 5가 친구일 때를 생각해 보자.
    - 1은 2까지 3을 이용해 2단계, 3까지 1단계, 4까지 1단계, 5까지 4를 이용해 2단계만에 알 수 있다. 따라서 케빈 베이컨의 수는 2 + 1 + 1 + 2 = 6이다.
    - 2는 1까지 3을 이용해 2단계, 3까지 1단계, 4까지 3을 이용해 2단계, 5까지 3과 4를 이용해 3단계만에 알 수 있다. 따라서 케빈 베이컨의 수는 2 + 1 + 2 + 3 = 8이다.
    - 3은 1까지 1단계, 2까지 1단계, 4까지 1단계, 5까지 4를 이용해 2단계만에 알 수 있다. 따라서 케빈 베이컨의 수는 1 + 1 + 1 + 2 = 5이다.
    - 4는 1까지 1단계, 2까지 3을 이용해 2단계, 3까지 1단계, 5까지 1단계만에 알 수 있다. 4의 케빈 베이컨의 수는 1 + 2 + 1 + 1 = 5가 된다.
    - 5는 1까지 4를 이용해 2단계, 2까지 4와 3을 이용해 3단계, 3까지 4를 이용해 2단계, 4까지 1단계만에 알 수 있다. 5의 베이컨의 수는 2 + 3 + 2 + 1 = 8이다.
    즉, 5명의 유저 중 케빈 베이컨의 수가 가장 작은 사람은 3과 4다. 위와 같이 백준 온라인 저지의 유저 수와 친구 관계가 입력으로 주어졌을 때 케빈 베이컨의 수가 가장
    작은 사람을 구하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 유저의 수 N(2≤N≤100)과 친구 관계의 수 M(1≤M≤5,000)이 주어진다. 2번째 줄부터 M개의 줄에는 친구 관계가 주어진다. 친구 관계는 A와 B로 이뤄져 있으며,
    A와 B는 친구라는 뜻이다. A와 B가 친구이면 B와 A도 친구이며, A와 B가 같은 경우는 없다. 친구 관계는 중복돼 들어올 수도 있으며, 친구가 1명도 없는 사람은 없다.
    또한 모든 사람은 친구 관계로 연결돼 있다. 사람의 번호는 1부터 N까지이고, 두 사람이 같은 번호일 경우는 없다.
  ### 출력
  - 1번째 줄에 백준 온라인 저지의 유저 중 케빈 베이컨의 수가 가장 작은 사람을 출력한다. 그런 사람이 여러 명일 때는 번호가 가장 작은 사람을 출력한다.
  ### 예제 입력1
  ```java
  5 5    // 유저의 수, 친구 관계의 수
  1 3
  1 4
  4 5
  4 3
  3 2
  ```
  ### 예제 출력1
  ```java
  3
  ```
  ### [1단계] 문제 분석하기
  - BFS 탐색 알고리즘을 이용해도 해결할 수 있는 문제이다. 하지만 유저의 최대 수가 100 정도로 작기 때문에 플로이드-워셜 알고리즘으로도 해결할 수 있다. 이를 위해서는
    몇 가지 아이디어가 필요하다. 1번째로 사람들이 직접적인 친구 관계를 맺은 상태를 비용 1로 계산하는 것이다. 즉, 가중치를 1로 정한 후 인접 행렬에 저장한다.
    또한 플로이드-워셜은 모든 쌍과 관련된 최단 경로이므로 한 row의 배열값은 이 row의 index값에서 다른 모든 노드와 관련된 최단 경로를 나타낸다고 볼 수 있다. 즉, i번째
    row의 합이 i번째 사람의 케빈 베이컨의 수가 된다는 뜻이 된다.
  ### [2단계] 손으로 풀어보기
  1. 먼저 인접 행렬을 생성한 후, 자기 자신이면(i==j) 0, 아니면 충분히 큰 수로 인접 행렬의 값을 초기화한다. 그리고 주어진 친구 관계 정보를 인접 행렬에 저장한다.
     i와 j가 친구라면 distance[i][j] = 1, distance[j][i] = 1로 값을 업데이트하면 된다.
     ⇒ 단계를 나타내므로 **가중치는 1**, 친구는 서로 맺는 관계이니 **양방향에 모두 값을 저장**
  2. 다음 점화식을 이용해 플로이드-워셜 알고리즘을 수행하여 3중 for 문으로 모든 중간 경로를 탐색한다.
     #### [플로이드-워셜 점화식]
     ```
     // 두 사람을 잇는 최솟값
     Math.min(D[S][E], D[S][K] + D[K][E])
     ```
  3. 케빈 베이컨의 수(각 행의 합)를 비교해 가장 작은 수가 나온 행 번호를 정답으로 출력한다. 같은 수가 있을 때는 더 작은 행 번호를 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(유저 수) M(친구 관계 수)
  distance(친구 관계 데이터를 저장하는 인접 행렬)
  for (i → N만큼 반복하기) {
    for (j → N만큼 반복하기) {
      시작 노드와 종료 노드가 같으면 0, 아니면 충분히 큰 수로 저장하기
    }
  }
  for (M만큼 반복하기) {
    친구 관계 데이터를 distance 행렬에 저장하기
    친구 관계는 서로 관계를 맺는 것이므로 양방향 에지로 저장하고 가중치를 1로 함
  }
  for (k → N만큼 반복하기) {   // 3중 for 문의 순서가 중요함. k가 가장 바깥쪽이 돼야 함
    for (i → N만큼 반복하기) {
      for (j → N만큼 반복하기) {
        distance[i][j]에 distance[i][k] + distance[k][j] 값들 중 최솟값 넣기
        i ~ j 사이에 가능한 모든 경로를 탐색하기
      }
    }
  }
  MIN(충분히 큰 수로 초기화)
  for (i → N만큼 반복하기) {
    for (j → N만큼 반복하기) {
      각 배열의 값을 합치기 → i의 케빈 베이컨의 수
    }
    if (MIN > i의 케빈 베이컨의 수) MIN값을 i의 케빈 베이컨의 수로 저장하기
  }
  가장 작은 케빈 베이컨의 수를 지니고 있는 i 출력하기
  ```
  ### [4단계] 코드 구현하기
  - [exam063_케빈베이컨의6단계법칙](src/book/ch08/exam063_케빈베이컨의6단계법칙.java)
    

# 7. 최소 신장 트리
- **`최소 신장 트리(minimum spanning tree)** 란 그래프에서 모든 노드를 연결할 때 사용된 에지들의 가중치의 합을 최소로 하는 트리이다.
  ### 최소 신장 트리의 특징
  - 사이클이 포함되면 가중치의 합이 최소가 될 수 없으므로 **사이클을 포함하지 않는다**.
  - N개의 노드가 있으면 최소 신장 트리를 구성하는 에지의 개수는 항상 **`N-1`** 개다.
  ### 최소 신장 트리 구현하기
  #### 1. 에지 리스트로 그래프를 구현하고 유니온 파인드 배열 초기화하기
  - 최소 신장 트리는 데이터를 노드가 아닌 에지 중심으로 저장하므로 인접 리스트가 아닌 **에지 리스트**의 형태로 저장한다. edge class는 일반적으로 노드 변수 2개와 가중치 변수로
    구성된다. 사이클 처리를 위한 유니온 파인드 배열도 함께 초기화한다. 배열의 인덱스를 해당 자리의 값으로 초기화하면 된다.
  #### 2. 그래프 데이터를 가중치 기준으로 정렬하기
  - 에지 리스트에 담긴 그래프 데이터를 가중치 기준으로 오름차순 정렬한다.
    - 에지 리스트의 1개의 객체를 Class로 표현하면 **Comparable() 함수**를 사용해 높은 자유도로 정렬을 수행할 수 있다.
  #### 3. 가중치가 낮은 에지부터 연결 시도하기
  - 가중치가 낮은 에지부터 순서대로 선택해 연결을 시도한다. 이때 바로 연결하지 않고 이 에지를 연결했을 때 **그래프에 사이클 형성 유무**를 **`find 연산`** 을 이용해
    확인한 후 **사이클이 형성되지 않을 때만 `union 연산`을 이용해 두 노드를 연결**한다.
  #### 4. 과정 3 반복하기
  - 전체 노드의 개수가 N개이면 연결한 에지의 개수가 N-1이 될 때까지 과정 3을 반복한다.
  #### 5. 총 에지 비용 출력하기
  - 에지의 개수가 N-1이 되면 알고리즘을 종료하고, 완성된 최소 신장 트리의 총 에지 비용을 출력한다.
  ### 최소 신장 트리의 특징
  - 최소 신장 트리는 다른 그래프 알고리즘과는 달리, 에지 리스트의 형태를 이용해 데이터를 담는다는 특징이 있다. 그 이유는 **에지를 기준으로 하는 알고리즘**이기 때문이다.
    또한 사이클이 존재하면 안 되는 특징을 지니고 있기 때문에 **사이클 판별 알고리즘**인 **`유니온 파인드 알고리즘`** 을 내부에 구현해야 한다.
### [문제 064] : 최소 신장 트리 구하기 (2s)
  ### 문제
  - 최소 신장 트리(최소 스패닝 트리)는 주어진 그래프의 모든 노드들을 연결하는 부분 그래프 중 그 가중치의 합이 최소인 트리를 말한다. 그래프가 주어졌을 때 그 그래프의
    최소 신장 트리를 구하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 노드의 개수 V(1≤V≤10,000)와 에지의 개수 E(1≤E≤100,000)가 주어진다. 다음 E개의 줄에는 각 에지와 관련된 정보를 나타내는 세 정수 A,B,C가 주어진다.
    이는 A번 노드와 B번 노드가 가중치 C인 에지로 연결돼 있다는 의미다. C는 음수일 수도 있으며, 절댓값이 1,000,000을 넘지 않는다.<br/>
    그래프의 노드는 1번부터 V번까지 번호가 매겨져 있고, 임의의 두 노드 사이에 경로가 있다. 최소 신장 트리의 가중치가 -2,147,483,648보다 크거나 같고 2,147,483,647보다
    작거나 같은 데이터만 입력으로 주어진다.
  ### 출력
  - 1번째 줄에 최소 신장 트리의 가중치를 출력한다.
  ### 예제 입력1
  ```java
  3 3     // 노드 개수, 에지 개수
  1 2 1
  2 3 2
  1 3 3
  ```
  ### 예제 출력1
  ```java
  3
  ```
  ### [1단계] 문제 분석하기
  - 최소 신장 트리를 구하는 가장 기본적인 문제이다. 문제의 내용 자체가 최소 신장 트리에 관해 설명하고 있기 때문에 앞에서 배운 핵심 이론을 이용하면 이 문제를 해결할 수 있다.
  ### [2단계] 손으로 풀어보기
  1. 에지 리스트에 에지 정보를 저장한 후 부모 노드 데이터를 초기화한다. 최소 신장 트리는 에지 중심의 알고리즘이므로 데이터를 에지 리스트에 활용해 저장해야 한다.
     사이클 생성 유무를 판단하기 위한 유니온 파인드용 부모 노드도 초기화한다.
  2. 크루스칼 알고리즘을 수행한다. 현재 미사용 에지 중 가중치가 가장 작은 에지를 선택하고, 이 에지를 연결했을 때 사이클의 발생 유무를 판단한다. 사이클이 발생하면
     생략하고, 발생하지 않으면 에지값을 더한다.
  3. 과정 2에서 에지를 더한 횟수가 'V(노드 개수) - 1'이 될 때까지 반복하고, 반복이 끝나면 에지의 가중치를 모두 더한 값을 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(노드 수), M(에지 수)
  parent(대표 노드 저장 배열)
  queue(에지 정보를 저장할 우선순위 큐)
  for (M만큼 반복하기) {
    queue에 에지 정보 저장하기   // 우선순위 큐이므로 자동 정렬하기
  }
  while (사용한 에지 수가 노드 - 1이 될 때까지) {
    큐에서 에지 정보 가져오기
    에지 시작점과 끝점의 부모 노드가 다르면 → 연결해도 사이클이 생기지 않으면
      union 연산 수행하기
      에지의 가중치를 정답 변수에 더하기
  }
  정답 변수 출력하기
  union(a,b) {      // union 연산
    a와 b의 대표 노드 찾기
    두 원소의 대표 노드끼리 연결하기
  }
  find(a) {         // find 연산
    a가 대표 노드면 리턴하기
    아니면 a의 대표 노드값을 find(parent[a]) 값으로 저장 → 재귀 함수 형태
  }
  pNode implements Comparable {
    s(출발 노드), e(종료 노드), v(가중치)
    가중치의 오름차순 정렬되도록 compareTo 함수 구현하기
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam064_최소신장트리](src/book/ch08/exam064_최소신장트리.java)
### [문제 065] : 다리 만들기 (1s)
  ### 문제
  - 섬으로 이뤄진 나라가 있고, 모든 섬을 다리로 연결하려고 한다. 이 나라의 지도는 N×M 크기의 2차원 격자로 나타낼 수 있고, 격자의 각 칸은 땅이거나 바다다.
    섬은 연결된 땅이 상하좌우로 붙어 있는 덩어리를 말한다.<br/>
    다리는 바다에만 건설할 수 있고, 다리의 길이는 다리가 격자에서 차지하는 칸의 수다. 다리를 연결해 모든 섬을 연결하려고 한다. 섬 A에서 다리를 이용해 섬 B로 갈 수 있을 때
    섬 A와 B를 연결했다고 한다. 다리의 양끝은 섬과 인접한 바다 위에 있어야 하고, 한 다리의 방향이 중간에 바뀌면 안 된다. 또한 다리의 길이는 2 이상이어야 한다. 다리의 방향이
    중간에 바뀌면 안 되기 때문에 다리의 방향은 가로 또는 세로가 될 수밖에 없다. 방향이 가로인 다리는 다리의 양끝이 가로 방향으로 섬과 인접해야 하고, 방향이 세로인 다리는
    다리의 양끝이 세로 방향으로 섬과 인접해야 한다. 섬 A와 B를 연결하는 다리가 중간에 섬 C와 인접한 바다를 지나갈 때 섬 C는 A,B와 연결돼 있는 것이 아니다.<br/>
    다리가 교차할 때가 있을 수도 있다. 교차하는 다리의 길이를 계산할 때는 각 칸이 각 다리의 길에 모두 포함돼야 한다.<br/>
    나라의 정보가 주어졌을 때 모든 섬을 연결하는 다리 길이의 최솟값을 구해보자.
  ### 입력
  - 1번째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다(1≤N,M≤10, 3≤N×M≤100). 2번째 줄부터 N개의 줄에 지도의 정보가 주어진다. 각 줄은 M개의 수로 이뤄져 있고,
    수는 0 또는 1이다. 0은 바다, 1은 땅을 의미한다. 섬의 개수는 2 이상 6 이하이다.
  ### 출력
  - 모든 섬을 연결하는 다리 길이의 최솟값을 출력한다. 모든 섬을 연결할 수 없다면 -1을 출력한다.
  ### 예제 입력1
  ```java
  7 8     // 행렬 크기
  0 0 0 0 0 0 1 1
  1 1 0 0 0 0 1 1
  1 1 0 0 0 0 0 0
  1 1 0 0 0 1 1 0
  0 0 0 0 0 1 1 0
  0 0 0 0 0 0 0 0
  1 1 1 1 1 1 1 1
  ```
  ### 예제 출력1
  ```java
  9
  ```
  ### 예제 입력2
  ```java
  7 8
  0 0 0 1 1 0 0 0
  0 0 0 1 1 0 0 0
  1 1 0 0 0 0 1 1
  1 1 0 0 0 0 1 1
  1 1 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 1 1 1 1 1 1
  ```
  ### 예제 출력2
  ```java
  10
  ```
  ### 예제 입력3
  ```java
  7 8
  1 0 0 1 1 1 0 0
  0 0 1 0 0 0 1 1
  0 0 1 0 0 0 1 1
  0 0 1 1 1 0 0 0
  0 0 0 0 0 0 0 0
  0 1 1 1 0 0 0 0
  1 1 1 1 1 1 0 0
  ```
  ### 예제 출력3
  ```java
  9
  ```
  ### 예제 입력4
  ```java
  7 7
  1 1 1 0 1 1 1
  1 1 1 0 1 1 1
  1 1 1 0 1 1 1
  0 0 0 0 0 0 0
  1 1 1 0 1 1 1
  1 1 1 0 1 1 1
  1 1 1 0 1 1 1
  ```
  ### 예제 출력4
  ```java
  10
  ```
  ### [1단계] 문제 분석하기
  - 문제 조건에서 데이터의 크기는 매우 작은 편이라 시간 복잡도에 제약은 크지 않다. 단 몇 개의 단계로 나눠 생각해야 할 문제이다. 먼저 주어진 지도에서 섬으로 표현된 값을
    각각의 섬마다 다르게 표현해야 한다. 그 이후 각 섬의 모든 위치에서 다른 섬으로 연결할 수 있는 에지가 있는지 확인해 에지 리스트를 만든다. 이후에는 최소 신장 트리를
    적용하면 문제를 해결할 수 있다. 아이디어와 구현 능력이 골고루 필요한 문제이다.
  ### [2단계] 손으로 풀어보기
  1. 지도의 정보를 2차원 배열에 저장하고 섬으로 표시된 모든 점에서 BFS를 실행해 섬을 구분한다(상하좌우 네 방향으로 탐색). 방문한 적이 없고 바다가 아닐 때 같은 섬으로
     인식한다.
  2. 모든 섬에서 상하좌우로 다리를 지어 다른 섬으로 연결할 수 있는지 확인한다. 연결할 곳이 현재 섬이면 탐색 중단, 바다라면 탐색을 계속 수행한다. 다른 섬을 만났을 때
     다리의 길이가 2 이상이면 이 다리를 에지 리스트에 추가한다.
  3. 전 단계에서 수집한 모든 에지를 오름차순 정렬해 최소 신장 트리 알고리즘을 수행한다. 알고리즘이 끝나면 사용한 에지의 합을 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  dr, dc (네 방향 탐색을 위한 상수)
  N, M (행렬의 크기)
  map(맵 정보 저장 배열)
  parent(대표 노드 저장 배열)
  visited(BFS를 할 때 방문 여부 저장 배열)
  sumlist(모든 섬 정보 저장하기)
  mlist(1개의 섬 정보 저장하기)
  queue(다리 정보를 저장할 우선순위 큐)
  for (N만큼 반복하기) {
    for (M만큼 반복하기) {
      입력 데이터를 map 변수에 저장하기
    }
  }
  for (i → N만큼 반복하기) {     // 섬 분리 작업 수행하기
    for (j → M만큼 반복하기) {
      BFS(i,j) 모든 위치에서 BFS를 실행해 섬을 분리하기
      결과를 sumlist 변수에 넣기
    }
  }
  for (i → sumlist 크기만큼 반복하기) {     // 모든 섬에서 지울 수 있는 다리를 찾고 저장하기
    now ← sumlist에서 추출     // 1개의 섬 정보
    for (j → now 크기만큼 반복하기) {
      1개의 섬의 모든 위치에서 만들 수 있는 다리 정보 저장하기
      // 네 방향 탐색 → 큐에 에지 정보 저장하기
    }
  }
  parent(대표 노드 저장 배열)
  대표 노드 저장 배열의 값을 자신의 index로 초기화하기

  while (큐가 빌 때까지) {
    큐에서 에지 정보 가져오기
    에지 시작점과 끝점의 부모 노드가 다르면 → 연결해도 사이클이 생기지 않으면
      union 연산 수행하기
      에지의 가중치를 정답 변수에 더하기
  }
  사용한 에지가 노드 개수 - 1이면 가중치의 합을 결과로 출력하기
  아니면 -1 출력하기
  union(a, b) {                   // union 연산
    a와 b의 대표 노드 찾기
    두 원소의 대표 노드끼리 연결하기
  }
  find(a) {                       // find 연산
    a가 대표 노드면 리턴하기
    아니면 a의 대표 노드 값을 find(parent[a]) 값으로 저장 → 재귀 함수 형태
  }
  BFS(i,j) {                      // 탐색 알고리즘
    i,j 위치에서 네 방향을 탐색해 1개 섬의 영역을 저장하기
  }
  bEdge implements Comparable {
    s(출발 노드), e(종료 노드), v(가중치)
    가중치의 오름차순 정렬되도록 구현하기
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam065_다리만들기](src/book/ch08/exam065_다리만들기.java)
### [문제 066] : 불우이웃돕기 (2s)
  ### 문제
  - 다솜이는 불우이웃돕기 활동을 하기 위해 무엇을 해야 할 것인지 생각했다. 마침 집에 엄청나게 많은 랜선이 있다는 것을 깨달았다. 마침 랜선이 이렇게 많이 있을 필요가
    없다고 느낀 다솜이는 랜선을 이용해 지역 사회에 봉사하기로 했다.<br/>
    다솜이의 집에는 N개의 방이 있다. 각각의 방에는 모두 1개의 컴퓨터가 있다. 각각의 컴퓨터는 랜선으로 연결돼 있다. 어떤 컴퓨터 A와 B가 있을 때 A와 B가 서로 랜선으로
    연결돼 있거나 다른 컴퓨터를 이용해 연결돼 있으면 서로 통신할 수 있다. 다솜이는 집 안에 있는 N개의 컴퓨터를 모두 서로 연결되게 하고 싶다. N개의 컴퓨터가 서로 연결돼
    있는 랜선의 길이가 주어질 때 다솜이가 기부할 수 있는 랜선의 길이의 최댓값을 출력하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 컴퓨터의 개수 N, 2번째 줄부터 랜선의 길이가 주어진다. i번째 줄의 j번째 문자가 0일 경우에는 컴퓨터 i와 컴퓨터 j를 연결하는 랜선이 없다는 것을 의미한다.
    이외의 경우에는 랜선의 길이를 의미한다. 랜선의 길이는 a에서 z는 1부터 26, A에서 Z는 27부터 52를 나타낸다. N은 100보다 작거나 같은 자연수다.
  ### 출력
  - 1번째 줄에 다솜이가 기부할 수 있는 랜선의 길이의 최댓값을 출력한다. 만약, 모든 컴퓨터가 연결돼 있지 않으면 -1을 출력한다.
  ### 예제 입력1
  ```java
  3   // 컴퓨터의 개수
  abc
  def
  ghi
  ```
  ### 예제 출력1
  ```java
  40
  ```
  ### [1단계] 문제 분석하기
  - 인접 행렬의 형태로 데이터가 들어오기 때문에 이 부분을 최소 신장 트리가 가능한 형태로 변형하는 것이 이 문제의 핵심이다. 먼저 문자열로 주어진 랜선의 길이를 숫자로
    변형해 랜선의 총합을 저장한다. 이때 i와 j가 같은 곳의 값은 같은 컴퓨터를 연결한다는 의미이므로 별도 에지로 저장하지 않고 나머지 위치의 값들을 i→j로 가는 에지로
    생성하고, 에지 리스트에 저장하면 최소 신장 트리 문제로 변형할 수 있다.
  ### [2단계] 손으로 풀어보기
  1. 입력 데이터의 정보를 배열에 저장한다. 먼저 입력으로 주어진 문자열을 숫자로 변환해 총합으로 저장한다. 소문자는 '현재 문자 - 'a' + 1', 대문자는 '현재 문자 - 'A' + 27'로
     변환한다. i와 j가 다른 경우에는 다른 컴퓨터를 연결하는 랜선이므로 에지 리스트에 저장한다.
  2. 저장된 에지 리스트를 바탕으로 최소 신장 트리 알고리즘을 수행한다.
  3. 최소 신장 트리의 결괏값이 다솜이가 최소한으로 필요한 랜선 길이이므로 처음 저장해 둔 랜선의 총합에서 최소 신장 트리의 결괏값을 뺀 값을 정답으로 출력한다.
     단, 최소 신장 트리에서 사용한 에지 개수가 N-1이 아닌 경우에는 모든 컴퓨터를 연결할 수 없다는 의미이므로 -1을 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(컴퓨터의 개수), sum(모든 랜선의 합 저장하기)
  parent(대표 노드 저장 배열)
  queue(랜선 정보를 저장할 우선순위 큐)
  for (N만큼 반복하기) {
    for (N만큼 반복하기) {
      랜선의 총합 저장하기 → 소문자일 때 → 현재 문자 - 'a' + 1
                          → 대문자일 때 → 현재 문자 - 'A' + 1
      i와 j가 다르면 랜선 정보를 큐에 저장하기
    }
  }
  while (큐가 빌 때까지) {
    큐에서 에지 정보 가져오기
    에지 시작점과 끝점의 부모 노드가 다르면 → 연결해도 사이클이 생기지 않으면
      union 연산 수행하기
      에지의 가중치를 정답 변수에 더하기
  }
  사용한 에지의 개수가 노드 개수 - 1이면 모든 랜선의 합에서 최소 신장 트리의 결괏값을 뺀 값을 출력,
  아니면 -1 출력하기
  union(a,b) {   // union 연산
    a와 b의 대표 노드 찾기
    두 원소의 대표 노드끼리 연결하기
  }
  find(a) {      // find 연산
    a가 대표 노드이면 리턴하기
    아니면 a의 대표 노드 값을 find(parent[a]) 값으로 저장 → 재귀 함수 형태
  }
  lEdge implements Comparable {
    s(출발 노드), e(종료 노드), v(가중치)
    가중치의 오름차순 정렬되도록 compareTo 함수 구현하기
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam067_불우이웃돕기](src/book/ch08/exam066_불우이웃돕기.java);
