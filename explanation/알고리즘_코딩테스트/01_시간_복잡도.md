# 알고리즘 선택의 기준이 되는 시간 복잡도
<br/>

# 목차
1. [시간 복잡도 표기법]()
2. [시간 복잡도 활용]()
<br/>

# 1. 시간 복잡도 표기법
- 알고리즘에서 시간 복잡도는 주어진 문제를 해결하기 위한 연산 횟수를 말한다.
- 일반적으로 수행 시간은 1억 번의 연산을 1초의 시간으로 간주하여 예측한다.
  
## (1) 시간 복잡도 정의
  - ### 시간 복잡도 유형
    - **빅-오메가(Ω(n))** : 최선일 때(best case)의 연산 횟수를 나타낸 표기법
    - **빅-세타(Θ(n))** : 보통일 때(average case)의 연산 횟수를 나타낸 표기법
    - **빅-오(Ο(n))** : 최악일 때(worst case)의 연산 횟수를 나타낸 표기법
  - ### 시간 복잡도 예제코드
    ```java
    public class timeComplexityExample1 {
      public static void main(String[] args) {
        // 1~100 사이 값 랜덤 선택
        int findNumber = (int)(Math.random() * 100);
        for (int i = 0; i < 100; i++) {
          if (i == findNumber) {
            System.out.println(i);
            break;
          }
        }
      }
    }
    // 빅-오메가(Ω(n)) : 1번
    // 빅-세타(Θ(n)) : 2/N번
    // 빅-오(Ο(n)) : N번
    ```
## (2) 시간 복잡도 정의
  - **빅-오 표기법(Ο(n))** 을 기준으로 수행 시간을 계산하는 것이 좋다.
    - 응시자가 작성한 프로그램으로 다양한 테스트 케이스를 수행해 모든 케이스를 통과해야만 합격으로 판단하므로 시간 복잡도를 판단할 때는 최악일 때(worst case)를 염두에 둬야 한다.
  - 빅-오 표기법(Ο(n))의 시간 복잡도
   (그림)

# 2. 시간 복잡도 활용
## (1) 알고리즘 선택의 기준으로 사용하기
  - ### 수 정렬하기
    - #### 문제
      - N개의 수가 주어졌을 때 이를 오름차순 정렬하는 프로그램을 작성하시오.
    - #### 입력
      - 1번째 줄에 수의 개수 N(1≤N≤1,000,000), 2번째 줄부터는 N개의 줄에 숫자가 주어진다. 이 수는 절댓값이 1,000,000보다 작거나 같은 정수다. 수는 중복되지 않는다.
    - #### 출력
      - 1번째 줄부터 N개의 줄에 오름차순 정렬한 결과를 1줄에 1개씩 출력한다.
    - #### 예제 입력1
      ```java
      5
      5
      2
      3
      4
      1
      ```
    - #### 예제 출력1
      ```java
      1
      2
      3
      4
      5
      ```
    - #### Solution
      - 시간 제한이 2초이므로 이 조건을 만족하려면 2억 번 이하의 연산 횟수로 문제를 해결해야 한다. 따라서 **문제에서 주어진 시간 제한과 데이터 크기**를 바탕으로 어떤 정렬 알고리즘을 사용해야 할 것인지를 판단할 수 있다.
        1. 연산 횟수는 **1초에 1억 번** 연산하는 것을 기준으로 생각한다.
        2. 시간 복잡도는 항상 최악일 때, 즉 **데이터의 크기가 가장 클 때**를 기준으로 한다.
        3. 연산 횟수 계산 방법 : ```연산 횟수 = 알고리즘 시간 복잡도 ⨯ 데이터의 크기```
           - 알고리즘 적합성 평가
             - 버블 정렬 = (1,000,000)^2 = 1,000,000,000,000 ```>``` 200,000,000 ☞ 부적합 알고리즘
             - 병합 정렬 = 1,000,000log(1,000,000) = 약 2,000,000 ```<``` 200,000,000 ☞ **적합 알고리즘**
## (2) 시간 복잡도를 바탕으로 코드 로직 개선하기
  - 시간 복잡도는 작성한 코드의 비효율적인 로직(logic)을 개선하는 바탕으로도 사용할 수 있다. 이 부분을 활용하려면 가장 먼저 코드의 시간 복잡도를 도출할 수 있어야 한다.
    - 시간 복잡도 도출 기준
      1. 상수는 시간 복잡도 계산에서 제외한다.
      2. 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.
  - 예시
    - 연산 횟수가 N인 경우
      ```java
      public class 시간복잡도_판별원리1 {
        public static void main(String[] args) {
          int N = 100000;
          int cnt = 0;
          for (int i = 0; i < N; i++) {
            System.out.println("연산 횟수: " + cnt++);
          }
        }
      }
      // 시간 복잡도: Ο(n)
      ```
    - 연산 횟수가 3N인 경우
      ```java
      public class 시간복잡도_판별원리2 {
        public static void main(String[] args) {
          int N = 100000;
          int cnt = 0;
          for (int i = 0; i < N; i++) {
            System.out.println("연산 횟수: " + cnt++);
          }
          for (int i = 0; i < N; i++) {
            System.out.println("연산 횟수: " + cnt++);
          }
          for (int i = 0; i < N; i++) {
            System.out.println("연산 횟수: " + cnt++);
          }
        }
      }
      // 시간 복잡도: Ο(n) ---> 상수는 시간 복잡도 계산에서 제외됨
      ```
    - 연산 횟수가 N^2인 경우
      ```java
      public class 시간복잡도_판별원리3 {
        public static void main(String[] args) {
          int N = 100000;
          int cnt = 0;
          for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
              System.out.println("연산 횟수: " + cnt++);
            }
          }
        }
      }
      // 시간 복잡도: Ο(n^2) ---> 가장 많이 중첩된 반복문을 기준으로 시간 복잡도가가 도출됨
      
      
