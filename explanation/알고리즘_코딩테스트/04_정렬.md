# 정렬
<br/>

# 목차
1. [버블 정렬](#1-버블-정렬)
2. [선택 정렬](#2-선택-정렬)
3. [삽입 정렬](#3-삽입-정렬)
4. [퀵 정렬](#4-퀵-정렬)
5. [병합 정렬](#5-병합-정렬)
6. [기수 정렬](#6-기수-정렬)
<br/>

# 정렬 알고리즘 정의
  |**정렬 알고리즘**|**정의**|
  |:---|:---|
  |버블(bubble)|데이터의 인접 요소끼리 비교하고, swap 연산을 수행하며 정렬하는 방식|
  |선택(selection)|대상에서 가장 크거나 작은 데이터를 찾아가 선택을 반복하면서 정렬하는 방식|
  |삽입(insertion)|대상을 선택해 정렬된 영역에서 선택 데이터의 적절한 위치를 찾아 삽입하면서 정렬하는 방식|
  |퀵(quick)|pivot 값을 선정해 해당 값을 기준으로 정렬하는 방식|
  |병합(merge)|이미 정렬된 부분 집합들을 효율적으로 병합해 전체를 정렬하는 방식|
  |기수(radix)|데이터의 자릿수를 바탕으로 비교해 데이터를 정렬하는 방식|

# 1. 버블 정렬
## (1) 버블 정렬의 핵심 이론
- 버블 정렬(bubble sort)은 **두 인접한 데이터의 크기를 비교**해 정렬하는 방법이다.
- 간단하게 구현할 순 있지만, 시간 복잡도는 **Ο(n^2)** 으로 다른 정렬 알고리즘보다 속도가 느린 편이다.
- 루프(loop)를 돌면서 인접한 데이터 간의 swap 연산으로 정렬한다.
## (2) 버블 정렬 과정
1. 비교 연산이 필요한 루프 범위를 설정한다.
2. 인접한 데이터 값을 비교한다.
3. swap 조건에 부합하면 swap 연산을 수행한다.
4. 루프 범위가 끝날 때까지 2~3을 반복한다.
5. 정렬 영역을 설정합니다. 다음 루프를 실행할 때는 이 영역을 제외한다.
6. 비교 대상이 없을 때까지 1~5를 반복한다.
- 만약 특정한 루프의 전체 영역에서 swap이 한 번도 발생하지 않았다면 그 영역 뒤에 있는 데이터가 모두 정렬됐다는 뜻이므로 프로세스를 종료해도 된다.
- ### [문제 015] : 수 정렬하기 1 (2s)
  - ### 문제
    - N개의 수가 주어졌을 때 이를 오름차순 정렬하는 프로그램을 작성하시오.
  - ### 입력
    - 1번째 줄에 수의 개수 N(1≤N≤1,000), 2번째 줄부터 N개의 줄에 숫자가 주어진다. 이 수는 절댓값이 1,000보다 작거나 같은 정수다. 수는 중복되지 않는다.
  - ### 출력
    - 1번째 줄부터 N개의 줄에 오름차순 정렬한 결과를 1줄에 1개씩 출력한다.
  - ### 예제 입력1
    ```java
    5    // 수의 개수
    5
    2
    3
    4
    1
    ```
  - ### 예제 출력1
    ```java
    1
    2
    3
    4
    5
    ```
  - ### [1단계] 문제 분석하기
    - 자바에서는 sort() 함수를 이용해 쉽게 정렬할 수 있지만, 이번에는 정렬을 직접 구현해 문제를 해결해보자.
      N의 최대 범위가 1,000으로 매우 작기 때문에 Ο(n^2) 시간 복잡도 알고리즘으로 풀 수 있다. 버블 정렬의 시간 복잡도가 Ο(n^2)이므로 버블 정렬 알고리즘을 이용해 정렬해도
      시간 복잡도 안에서 문제를 해결할 수 있다.
  - ### [2단계] 손으로 풀어보기
    (그림 생략)
  - ### [3단계] 슈도코드 작성하기
    ```java
    N (정렬할 수 개수)
    A (정렬할 배열 선언)
    for (i : 0 ~ N-1) {
      for (j : 0 ~ N - 1 - i) {
        현재 A 배열의 값보다 1칸 오른쪽 배열의 값이 더 작으면 두 수 바꾸기
      }
    }
    A 배열 출력
    ```
  - ### [4단계] 코드 구현하기
    - [exam015_수정렬하기](src/book/ch04/exam015_수정렬하기.java)
- ### [문제 016] : 버블 소트 프로그램 1 (2s)
  - ### 문제
    - 영식이는 다음과 같은 버블 소트 프로그램을 C++로 작성했다.
      ```C++
      bool change = false;
      for (int i = 1; i <= n; i++)
      {
        change = false;
        for (int j = 1; j <= n - i; j++) {
          if (a[j] > a[j+1]) {
            change = true;
            swap(a[j], a[j+1]);
          }
        }
        if (change == false) {
          cout << i << '\n';
          break;
        }
      }
      ```
      위 코드에서 n은 배열의 크기, a는 수가 들어 있는 배열이다. 수는 배열의 1번 방부터 채운다. 위와 같은 코드를 실행시켰을 때 어떤 값이 출력되는지를 구하는
      프로그램을 작성하시오.
  - ### 입력
    - 1번째 줄에 N이 주어진다. N은 500,000보다 작거나 같은 자연수다. 2번째 줄부터 N개의 줄에 A[1]부터 A[N]까지 1개씩 주어진다. A에 들어 있는 수는 1,000,000보다
      작거나 같은 자연수 또는 0이다.
  - ### 출력
    - 정답을 출력한다.
  - ### 예제 입력1
    ```java
    5   // 배열의 크기
    10
    1
    5
    2
    3
    ```
  - ### 예제 출력1
    ```java
    3
    ```
  - ### [1단계] 문제 분석하기
    - 버블 정렬의 swap이 한 번도 일어나지 않은 루프가 언제인지 알아내는 문제이다. '버블 정렬의 이중 for 문에서 안쪽 for 문 전체를 돌 때 swap이 한 번도 일어나지 않았다'는 것은
      이미 모든 데이터가 정렬되었다는 것을 의미한다. 이때는 프로세스를 바로 종료해 시간 복잡도를 줄일 수 있다. 하지만 이 문제는 N의 최대 범위가 500,000이므로 버블 정렬로 문제를
      풀면 시간을 초과할 수 있으므로, 안쪽 for 문이 몇 번 수행됐는지 구하는 다른 아이디어가 필요하다
    - [안쪽 for 문이 몇 번 수행됐는지 구하는 다른 아이디어]
      - 안쪽 루프는 1에서 n-j까지, 즉 왼쪽에서 오른쪽으로 이동하면서 swap을 수행한다. 이는 특정 데이터가 안쪽 루프에서 swap의 **왼쪽으로 이동할 수 있는 최대 거리가 1**이라는 뜻이다.
        즉, 데이터의 정렬 전 index와 정렬 후 index를 비교해 왼쪽으로 가장 많이 이동한 값을 찾으면 이 문제를 해결할 수 있다.
  - ### [2단계] 손으로 풀어보기
    1. 자바에서 기본적으로 제공하는 sort() 함수로 배열을 정렬한다. sort() 함수의 시간 복잡도는 Ο(nlogn)이다.
    2. 각 데이터마다 정렬 전 index 값에서 정렬 후 index 값을 빼고 최댓값을 찾는다. 그리고 swap이 일어나지 않는 반복문이 한 번 더 실행되는 것을 감안해 최댓값에 1을 더한다.
  - ### [3단계] 슈도코드 작성하기
    ```java
    N(데이터 개수) A(데이터 배열, 단 클래스를 데이터로 담는 배열)
    for (N만큼 반복하기) {
      A 배열 저장하기
    }
    A 배열 정렬하기
    for (N만큼 반복하기) [
      A[i]의 정렬 전 index - 정렬 후 index 계산의 최댓값을 찾아 저장하기
    }
    최댓값 + 1을 정답으로 출력하기

    별도 클래스 선언하기
    mData(데이터 표현) {
      index, value를 가지며
      value 기준 오름차순 정렬 함수 Comparable 구현하기
    }
    ```
  - ### [4단계] 코드 구현하기
    - [exam016_버블소트1](src/book/ch04/exam016_버블소트1.java)

# 2. 선택 정렬
- 선택 정렬(selection sort)은 대상 데이터에서 최대나 최소 데이터를 데이터가 나열된 순으로 찾아가며 선택하는 방법이다.
  선택 정렬은 구현 방법이 복잡하고, 시간 복잡도도 O(n^2)으로 효율적이지 않아 코딩 테스트에서 많이 사용하지 않는다.
## (1) 선택 정렬의 핵심 이론
- 최솟값 또는 최댓값을 찾고, 남은 정렬 부분의 가장 앞에 있는 데이터와 swap하는 것이 선택 정렬의 핵심이다.
## (2) 선택 정렬 과정
1. 남은 정렬 부분에서 최솟값 또는 최댓값을 찾는다.
2. 남은 정렬 부분에서 가장 앞에 있는 데이터와 선택 데이터를 swap한다.
3. 가장 앞에 있는 데이터의 위치를 변경해(index++) 남은 정렬 부분의 범위를 축소한다.
4. 전체 데이터 크기만큼 index가 커질 때까지, 즉 남은 정렬 부분이 없을 때까지 반복한다.
- ### [문제 017] : 내림차순으로 자릿수 정렬하기 (2s)
  - ### 문제
    - 배열을 정렬하는 것은 쉽다. 수가 주어지면 그 수의 각 자릿수를 내림차순으로 정렬하시오.
  - ### 입력
    - 1번째 줄에 정렬할 수 N이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수다.
  - ### 출력
    - 1번째 줄에 자릿수를 내림차순 정렬한 수를 출력한다.
  - ### 예제 입력1
    ```java
    2143
    ```
  - ### 예제 출력1
    ```java
    4321
    ```
  - ### [1단계] 문제 분석하기
    - 자연수를 받아 자릿수별로 정렬하는 문제이므로 먼저 숫자를 각 자릿수별로 나누는 작업이 필요하다. 나머지 연산으로 분리할 수도 있지만 여기서는 입력값을 String으로 받은 후
      substring() 함수를 이용해 자릿수 단위로 분리하고, 이를 다시 int 형으로 변경해 배열에 저장한다. 그 다음에는 단순하게 배열을 정렬하면 된다. 자바의 내장 함수를 사용해도 되지만,
      N의 길이가 크지 않으므로 앞에서 배운 선택 정렬을 이용해 내림차순 정렬을 수행해보자.
  - ### [2단계] 손으로 풀어보기
    1. String 변수로 정렬할 데이터를 받아 int형 배열에 저장한다. 이때는 substring() 함수를 사용해 숫자를 각 자릿수별로 나눈 후 배열에 저장한다.
    2. 배열의 데이터를 선택 정렬 알고리즘을 이용해 내림차순 정렬한다. 내림차순 정렬이므로 최댓값을 찾아 기준이 되는 자리와 swap한다.
  - ### [3단계] 슈도코드 작성하기
    ```java
    str (정렬할 수)
    A (자릿수별로 구분해 저장한 배열)
    for (str의 길이만큼 반복하기) {
      A 배열 저장 -> str.substring 사용하기
    }
    for (i: 0 ~ str의 길이만큼 반복하기) {
      for (j: i+1 ~ str의 길이만큼 반복하기) {
        현재 범위에서 Max값 찾기
      }
      현재 i의 값과 Max값 중 Max값이 더 크면 swap 수행하기
    }
    A 배열 출력하기
    ```
  - ### [4단계] 코드 구현하기
    - [exam017_내림차순정렬](algorithm_study/src/book/ch04/exam022_수정렬하기3.java)
   
# 3. 삽입 정렬
- 삽입 정렬(insertion sort)은 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 방식이다. 평균 시간 복잡도는 O(n^2)으로 느린 편이지만
  구현하기 쉽다.
## (1) 삽입 정렬의 핵심 이론
- 선택 데이터를 현재 정렬된 데이터 범위 내에서 적절한 위치에 삽입하는 것이 삽입 정렬의 핵심이다.
## (2) 삽입 정렬 수행 방식
  1. 현재 index에 있는 데이터 값을 선택한다.
  2. 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치를 탐색한다.
  3. 삽입 위치부터 index가 있는 위치까지 shift 연산을 수행한다.
  4. 삽입 위치에 현재 선택한 데이터를 삽입하고 index++ 연산을 수행한다.
  5. 전체 데이터의 크기만큼 index가 커질 때까지, 즉 선택할 데이터가 없을 때까지 반복한다.
  - 적절한 삽입 위치를 탐색하는 부분에서 이진 탐색(binary search) 등과 같은 탐색 알고리즘을 사용하면 시간 복잡도를 줄일 수 있다.
- ### [문제 018] : ATM 인출 시간 계산하기 (1s)
  - ### 문제
    - 인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM 앞에 N명의 사람들이 줄을 서 있다. 사람은 1번에서 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는 데 걸리는 시간은 Pi분이다.
      사람들이 줄을 서는 순서에 따라서 돈을 인출하는 데 필요한 시간의 합이 달라진다. 예를 들어 총 5명이 있고, P1=3, P2=1, P3=4, P4=3, P5=2일 때를 생각해 보자.
      [1,2,3,4,5] 순서로 줄을 선다면 1번 사람은 3분 만에 돈을 뽑을 수 있다. 2번 사람은 1번 사람이 돈을 뽑을 때까지 기다려야 하므로 3+1=4분이 걸린다. 3번 사람은 1번,2번 사람이 돈을 뽑을 때까지
      기다려야 하므로 총 3+1+4=8분이 걸린다. 4번 사람은 3+1+4+3=11분, 5번 사람은 3+1+4+3+2=13분이 걸린다. 즉, 각 사람이 돈을 인출하는 데 필요한 시간의 합은 3+4+8+11+13=39분이다.
      [2,5,1,4,3] 순서로 줄을 선다면 2번은 1분, 5번은 1+2=3분, 1번은 1+2+3=6분, 4번은 1+2+3+3=9분, 3번은 1+2+3+3+4=13분이 걸리므로 각 사람이 돈을 인출하는 데 필요한 시간의 합은 1+3+6+9+13=32분이다.
      이 순서보다 모든 사람이 돈을 인출하는 데 필요한 시간이 짧을 수는 없다. 줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는 데 걸리는 시간 Pi가 주어졌을 때 각 사람이 돈을 인출하는 데 필요한
      시간의 합의 최솟값을 구하는 프로그램을 작성하시오.
  - ### 입력
    - 1번째 줄에 사람의 수 N(1≤N≤1,000), 2번째 줄에 각 사람이 돈을 인출하는 데 걸리는 시간 Pi(1≤Pi≤1,000)가 주어진다.
  - ### 출력
    - 1번째 줄에 각 사람이 돈을 인출하는 데 필요한 시간의 합의 최솟값을 출력한다.
  - ### 예제 입력1
    ```java
    5   // 데이터 개수
    3 1 4 3 2
    ```
  - ### 예제 출력1
    ```java
    32
    ```
  - ### [1단계] 문제 분석하기
    - ATM에서 모든 사람이 가장 빠른 시간에 인출하는 방법을 그리디 방식으로 해결해보자. ATM 앞에 있는 사람 중 인출 시간이 가장 적게 걸리는 사람이 먼저 인출할 수 있도록
      순서를 정하는 것이 곧 그리디 방식이다. 그리고 이를 위해서는 인출 시간을 기준으로 값을 정렬해야 한다. N의 최댓값이 1,000이고, 시간 제한이 1초이므로
      시간 복잡도가 o(N^2) 이하인 정렬 알고리즘 중 아무거나 사용해도 된다. 여기서는 삽입 정렬을 이용하고, 정렬을 마친 후 각 사람이 돈을 인출하는데 필요한 시간을 더한다.
  - ### [2단계] 손으로 풀어보기
    1. 삽입 정렬을 이용해 인출 시간 Pi를 기준으로 데이터를 오름차순 정렬한다.
    2. 정렬된 데이터를 바탕으로 모든 사람이 돈을 인출하는 데 필요한 최솟값을 구한다. 인출에 필요한 시간은 앞사람들의 인출 시간의 합 + 자신의 인출 시간이므로 합 배열로 푼다.
  - ### [3단계] 슈도코드 작성하기
    ```java
    N(사람 수)
    A(자릿수별로 구분해 저장한 배열)
    S(A 합 배열 : 각 사람이 인출을 완료하는 데 필요한 시간을 저장하기)
    for (N만큼 반복하기) {
      A 배열 저장하기
    }
    for (i: N만큼 반복하기) {
      for (j: i-1 ~ 0까지 뒤에서부터 반복하기) {
        현재 범위에서 삽입 위치 찾기
      }
      for (j: i ~ insert_point+1 까지 뒤에서부터 반복하기) {
        삽입을 위해 삽입 위치에서 i까지 데이터를 한 칸씩 뒤로 밀기
      }
      삽입 위치에 현재 데이터 삽입하기
    }
    for (i: N만큼 반복하기) {
      A 배열을 통한 합 배열 S 만들기)
    }
    S 배열의 각 데이터 값을 모두 합해 결과 출력하기
    ```
  - ### [4단계] 코드 구현하기
    - [exam018_ATM](src/book/ch04/exam018_ATM.java)
   
# 4. 퀵 정렬
- 퀵 정렬(quick sort)은 **기준값(pivot)을 선정**해 해당 값보다 **작은 데이터와 큰 데이터로 분류하는 것을 반복**해 정렬하는 알고리즘이다.
  기준값이 어떻게 선정되는지가 시간 복잡도에 많은 영향을 미치고, 평균적인 시간 복잡도는 `O(nlogn)`이다.
## (1) 퀵 정렬의 핵심 이론
- pivot을 중심으로 계속 데이터를 2개의 집합으로 나누면서 정렬하는 것이 퀵 정렬의 핵심이다.
## (2) 퀵 정렬 과정
1. 데이터를 분할하는 pivot을 설정한다.
2. pivot을 기준으로 다음 a~e 과정을 거쳐 데이터를 2개의 집합으로 분리한다.
   1. start가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면 start를 오른쪽으로 1칸 이동한다.
   2. end가 가리키는 데이터가 pivot이 가리키는 데이터보다 크면 end를 왼쪽으로 1칸 이동한다.
   3. start가 가리키는 데이터가 pivot이 가리키는 데이터보다 크고, end가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면 start, end가 가리키는 데이터를 swap하고
      start는 오른쪽, end는 왼쪽으로 1칸씩 이동한다.
   4. start와 end가 만날 때까지 ⅰ~ⅲ을 반복한다.
   5. start와 end가 만나면 만난 지점에서 가리키는 데이터와 pivot이 가리키는 데이터를 비교하여 pivot이 가리키는 데이터가 크면 만난 지점의 오른쪽에, 작으면 만난 지점의
      왼쪽에 pivot이 가리키는 데이터를 삽입한다.
3. 분리 집합에서 각각 다시 pivot을 선정한다.
4. 분리 집합이 1개 이하가 될 때까지 과정 1~3을 반복한다.
- ### [문제 019] : K번째 수 구하기 (2s)
  - ### 문제
    - 수 N개(A1, A2, ..., AN)가 주어진다. A를 오름차순 정렬했을 때 앞에서부터 K번째에 있는 수를 구하는 프로그램을 작성하시오.
  - ### 입력
    - 1번째 줄에 N(1≤N≤5,000,000)과 K(1≤K≤N), 2번째 줄에 A1, A2, ..., AN이 주어진다(-109≤Ai≤109).
  - ### 출력
    - A를 정렬했을 때 앞에서부터 K번째에 있는 수를 출력한다.
  - ### 예제 입력1
    ```java
    5 2      // 데이터 개수, K번째 수
    4 1 2 3 5
    ```
  - ### 예제 출력1
    ```java
    2
    ```
  - ### [1단계] 문제 분석하기
    - N의 최대 범위가 5,000,000이므로 O(nlogn)의 시간 복잡도로 정렬을 수행하면 된다. 앞에서 배운 퀵 정렬을 구현해 주어진 수를 오름차순 정렬하고, K번째 수를 출력해보자.
      단, 이 문제는 시간 복잡도가 민감하므로 퀵 정렬 알고리즘에서 K번째 수를 좀 더 빨리 구하기 위한 아이디어를 먼저 고민해보자. 퀵 정렬 알고리즘을 구현하려면 먼저 pivot을
      지정해야 한다. 이때 어떤 값을 pivot으로 정하면 K번째 수를 더 빨리 구할 수 있을지 생각해보자.
      - pivot == K : K번째 수를 찾은 것이므로 알고리즘을 종료한다.
      - pivot > K : pivot의 왼쪽 부분에 K가 있으므로 왼쪽(S~pivot-1)만 정렬을 수행한다.
      - pivot < K : pivot의 오른쪽 부분에 K가 있으므로 오른쪽(pivot+1~E)만 정렬을 수행한다.
  - ### [2단계] 손으로 풀어보기
    1. 중간 위치를 pivot으로 설정한 다음 맨 앞에 있는 값과 swap한다. pivot을 맨 앞으로 옮기는 이유는 s,e 이동을 편하게 하기 위함이다. 이어서 s와 e를 pivot을 제외한 그룹에서
       왼쪽, 오른쪽 끝으로 정한다.
    2. 우선 e를 이동한다. e가 pivot보다 크면 j-- 연산을 반복한다. s가 pivot보다 작으면서 s보다 e가 크면 s++ 연산을 반복한다.'
       이 문제에서 e는 1에 위치하게 되며, s와 e의 위치가 같으므로 s는 이동하지 않는다.
    3. pivot을 두 집합을 나눠 주는 위치, 즉 s와 e가 만난 위치와 swap한다.
    4. K는 2이므로 이제 더이상 정렬하지 않고 A[2]를 출력한다.
  - ### [3단계] 슈도코드 작성하기
    ```java
    N(숫자의 개수) K(K번째 수)
    A(자 데이터 저장 배열)
    for (N만큼 반복하기) {
      A 배열 저장하기
    }
    퀵 소트 실행하기
    K번째 데이터 출력하기

    [별도의 함수 구현 부분]
    퀵 소트 함수(시작, 종료, K) {
      피벗 구하기 함수(시작, 종료)
      if (피벗 == K) 종료
      else if (K < 피벗) 퀵 소트 수행하기(시작, 피벗-1, K)
      else 퀵 소트 수행하기(피벗+1, 종료, K)
    }
    피벗 구하기 함수(시작, 종료) {
      중앙값을 피벗으로 설정하기
      s(시작점), e(종료점)
      while (s < e) {
        피벗보다 큰 수가 나올 때까지 s++
        피벗보다 작은 수가 나올 때까지 e--
        찾은 s와 e 데이터를 swap
      }
      피벗 데이터를 나눠진 두 그룹의 경계 index에 저장하기
    } 
    ```
  - ### [4단계] 코드 구현하기
    - [exam019_k번째수](src/book/ch04/exam019_K번째수.java)

# 5. 병합 정렬
- 병합 정렬(merge sort)은 **분할 정복(divide and conquer)** 방식을 이용해 데이터를 분할하고 분할한 집합을 정렬하며 합치는 알고리즘이다.
  병합 정렬의 시간 복잡도 평균값은 `O(nlogn)`이다.
## (1) 병합 정렬 수행 방식
- 2개씩 그룹을 합치며 오름차순 정렬
## (2) 2개의 그룹을 병합하는 과정
- 투 포인터 개념을 사용하여 왼쪽, 오른쪽 그룹을 병합한다. 왼쪽 포인터와 오른쪽 포인터의 값을 비교하여 작은 값을 결과 배열에 추가하고 포인터를 오른쪽으로 1칸 이동시킨다.
  이 방식은 여러 문제에서도 응용하므로 반드시 숙지하는 것이 좋다.
- ### [문제 020] : 수 정렬하기 2 (2s)
  - ### 문제
    - N개의 수가 주어졌을 때 이를 오름차순 정렬하는 프로그램을 작성하시오.
  - ### 입력
    - 1번째 줄에 수의 개수 N(1≤N≤1,000,000), 2번째 줄부터 N개의 줄에 숫자가 주어진다. 이 수는 절댓값이 1,000,000보다 작거나 같은 정수다. 수는 중복되지 않는다.
  - ### 출력
    - 1번째 줄부터 N개의 줄에 오름차순 정렬한 결과를 1줄에 1개씩 출력한다.
  - ### 예제 입력1
    ```java
    5     // 수의 개수수
    5
    4
    3
    2
    1
    ```
  - ### 예제 출력1
    ```java
    1
    2
    3
    4
    5
    ```
  - ### [1단계] 문제 분석하기
    - N의 최대 범위가 1,000,000이므로 O(nlogn)의 시간 복잡도로 정렬을 수행하면 된다. 앞에서 배운 병합 정렬로 정렬을 수행한 후 결과를 출력해보자.
  - ### [2단계] 손으로 풀어보기
    1. 정렬할 그룹을 최소 길이로 나눈 후, 나눈 그룹마다 병합 정렬한다. 각 그룹마다 index1, index2를 지정하여 비교하면서 정렬 용도로 선언한 tmp 배열에 병합 정렬한다.
    2. 이어서 병합된 그룹을 대상으로 정렬한다.
  - ### [3단계] 슈도코드 작성하기
    ```java
    N(정렬할 수 개수)
    arr(정렬할 배열 선언하기)
    tmp(정렬할 때 잠시 사용할 임시 배열 선언하기)
    for (N의 개수만큼) {
      arr 배열 선언하기
    }
    병합 정렬 함수 수행하기
    결괏값 출력하기
    // 병합 정렬 수행하기
    병합 정렬(s,e) {
      s(시작점), e(종료점), m(중간점)
      // 재귀 함수 형태로 구현하기
      병합 정렬(s,m)
      병합 정렬(m+1, e)
      for (s~e) {
        tmp 배열 저장하기
      }
      // 두 그룹을 병합하는 로직
      index1 -> 앞쪽 그룹 시작점
      index2 -> 뒤쪽 그룹 시작점
      while (index1 <= 중간점 && index2 <= 종료점) {
        양쪽 그룹의 index가 가리키는 값을 비교한 후 더 작은 수를 선택해 배열에 저장하고,
        선택된 데이터의 index 값을 오른쪽으로 한 칸 이동하기
      }
      반복문이 끝난 후 남아 있는 데이터 정리하기
    }
    ```
  - ### [4단계] 코드 구현하기
    - [exam020_수정렬하기2](src/book/ch04/exam020_수정렬하기2.java)
- ### [문제 021] : 버블 소트 프로그램 2 (1s)
  - ### 문제
    - 버블 소트는 서로 인접해 있는 두 수를 바꾸면서 정렬하는 방법이다. 예를 들어 수열이 3,2,1이었다고 가정해보자. 이때는 인접해 있는 3,2가 바뀌어야 하므로 2,3,1이 된다.
      그 다음은 3,1이 바뀌어야 하므로 2,1,3이 된다. 그다음에는 2,1이 바뀌어야 하므로 1,2,3이 된다. 그러면 더 이상 바꿀 수 없으므로 정렬이 완료된다.
      N개의 수로 이뤄진 수열 A[1], A[2], ..., A[N]이 있다. 이 수열로 버블 소트를 수행할 때 swap이 총 몇 번 발생하는지 알아내는 프로그램을 작성하시오.
  - ### 입력
    - 1번째 줄에 N(1N≤500,000), 2번째 줄에 N개의 정수로 A[1], A[2], ..., A[N]이 주어진다. 각각의 A[i]는 0≤|A[i]|≤1,000,000,000의 범위에 들어 있다.
  - ### 출력
    - 1번째 줄에 swap 횟수를 출력한다.
  - ### 예제 입력1
    ```java
    8   // 수의 개수
    3
    2
    8
    1
    7
    4
    5
    6
    ```
  - ### 예제 출력1
    ```java
    11
    ```
  - ### [1단계] 문제 분석하기
    - N의 최대 범위가 1,000,000이므로 O(nlogn)의 시간 복잡도로 정렬을 수행하면 된다. 앞에서 배운 병합 정렬로 정렬을 수행한 후 결과를 출력해보자.
      <br/>
      제목은 버블 소트이지만, N의 최대 범위가 5,000,000이므로 곧이곧대로 버블 소트를 사용하면 제한 시간을 초과한다. 즉, 이 문제는 버블 소트가 아닌 O(nlogn)의 시간 복잡도를
      가진 병합 정렬을 사용해야 한다. 병합 정렬을 이해한 상태라면 두 그룹을 병합하는 과정에 버블 정렬의 swap이 포함되어 있다는 것을 떠올릴 수 있다.
  - ### [2단계] 손으로 풀어보기
    - 병합 정렬은 동일하게 진행하고, 다만 정렬 과정에서 index가 이동한 거리를 result에 저장한다.
  - ### [3단계] 슈도코드 작성하기
    ```java
    N(정렬할 수 개수)
    arr(정렬할 배열 선언하기)
    tmp(정렬할 때 잠시 사용할 임시 배열 선언하기)
    for (N의 개수만큼) {
      A 배열 선언하기
    }
    병합 정렬 함수 수행하기
    결괏값 출력하기
    // 병합 정렬 수행하기
    병합 정렬(s,e) {
      s(시작점), e(종료점), m(중간점)
      // 재귀 함수 형태로 구현하기
      병합 정렬(s, m)
      병합 정렬(m+1, e)
      for (s~e) {
        tmp 배열 저장하기
      }
      // 두 그룹을 병합하는 로직
      index1 -> 앞쪽 그룹 시작점
      index2 -> 뒤쪽 그룹 시작점
      while(index1 <= 중간점 && index2 <= 종료점) {
        뒤쪽 데이터 값이 더 작아 선택될 때
        swap이 일어났다고 가정하고, 현재 남아 있는 앞쪽 데이터 개수만큼 결괏값을 더함
      }
      반복문이 끝난 후 남아 있는 데이터 정리하기
    }
    ```
  - ### [4단계] 코드 구현하기
    - [exam021_버블소트2](src/book/ch04/exam021_버블소트2.java)

# 6. 기수 정렬
- 기수 정렬(radix sort)은 값을 비교하지 않는 특이한 정렬이다. 기수 정렬은 값을 놓고 비교할 자릿수를 정한 다음 **해당 자릿수만 비교**한다.
  기수 정렬의 시간 복잡도는 `O(kn)`으로, 여기서 k는 데이터의 자릿수를 말한다.
## (1) 기수 정렬의 핵심 이론
- 기수 정렬은 10개의 큐를 이용한다. 각 큐는 값의 자릿수를 대표한다.
  <br/>
  기수 정렬은 시간 복잡도가 가장 짧은 정렬이다. 만약 코딩 테스트에서 정렬해야 하는 데이터의 개수가 너무 많으면 기수 정렬 알고리즘을 활용해보자.
- ### [문제 022] : 수 정렬하기 3 (3s)
  - ### 문제
    - N개의 수가 주어졌을 때 이를 오름차순 정렬하는 프로그램을 작성하시오.
  - ### 입력
    - 1번째 줄에 수의 개수 N(1≤N≤10,000,000), 2번째 줄부터 N개의 줄에 숫자가 주어진다. 이 수는 10,000보다 작거나 같은 자연수다.
  - ### 출력
    - 1번째 줄부터 N개의 줄에 오름차순 정렬한 결과를 1줄에 1개씩 출력한다.
  - ### 예제 입력1
    ```java
    11
    215
    15
    344
    372
    294
    100
    8
    145
    24
    198
    831
    ```
  - ### 예제 출력1
    ```java
    8
    15
    24
    100
    145
    198
    215
    294
    344
    372
    831
    ```
  - ### [1단계] 문제 분석하기
    - 이 문제는 N의 최대 개수가 10,000,000으로 매우 크기 때문에 O(nlogn)보다 더 빠른 알고리즘이 필요하다. 문제에서 주어지는 숫자의 크기가 10,000보다 작다는 것을 바탕으로
      O(kn)의 시간 복잡도의 기수 정렬을 사용하면 된다는 것을 알 수 있다.
  - ### [2단계] 손으로 풀어보기
    - 자릿수가 서로 다른 경우 자릿수가 적은 수 앞에 0이 채워져 있다고 생각하여 큐에 삽입하면 된다. 가장 큰 자릿수까지 각 자릿수에 해당하는 큐에 삽입 및 출력을 반복한다.
  - ### [3단계] 슈도코드 작성하기
    ```java
    N(정렬할 수 개수)
    A(정렬할 배열 선언하기)
    for (N의 개수만큼 반복하기) {
      A 배열 저장하기
    }
    기수 정렬 함수 수행하기
    정렬된 A 배열 출력하기
    // 기수 정렬 함수 구현하기
    // 변수 선언 부
    * bucket(현재 자릿수들의 분포를 합 배열의 형태로 알려 주는 배열)
        ex) bucket[4] -> 현재 기준 자릿값이 0~4까지 몇 개의 데이터가 있는지 저장하기
    * output (임시 정렬을 위한 배열)
    * jarisu(현재 자릿수를 표현하는 수)
    // 로직 부분
    while {
      현재 기준 자릿수를 기준으로 A 배열 데이터를 bucket에 count
      합 배열 공식으로 bucket을 합 배열 형태로 변경하기
      for (N의 개수만큼 반복하기) {
        bucket값을 이용해 현재 기준 자릿수로 데이터를 정렬하기
        output 배열에 저장하기
      }
      for (N의 개수만큼 반복하기) {
        다음 자릿수 이동을 위해 A 배열에 output 데이터 저장하기
      }
      jarisu = jarisu * 10
    }
    ```
  - ### [4단계] 코드 구현하기
    - [exam022_수정렬하기3](src/book/ch04/exam022_수정렬하기3.java)
