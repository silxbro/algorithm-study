# 그리디
<br/>

# 목차
1. [그리디 알고리즘](#1-그리디-알고리즘)
<br/>

# 1. 그리디 알고리즘
- `그리디(greedy)` 알고리즘은 현재 상태에서 보는 선택지 중 최선의 선택지가 전체 선택지 중 최선의 선택지라고 가정하는 알고리즘이다.
## (1) 그리디 알고리즘의 핵심 이론
### [그리디 알고리즘 수행 과정]
  1. 해 선택 : 현재 상태에서 가장 최선이라고 생각되는 해를 선택한다.
  2. 적절성 검사 : 현재 선택한 해가 전체 문제의 제약 조건에 벗어나지 않는지 검사한다.
  3. 해 검사 : 현재까지 선택한 해 집합이 전체 문제를 해결할 수 있는지 검사한다. 전체 문제를 해결하지 못한다면 1로 돌아가 같은 과정을 반복한다.
### [문제 032] : 동전 개수의 최솟값 구하기 (1s)
  ### 문제
  - 준규가 소유하고 있는 동전은 총 N 종류이고, 각 동전의 개수가 많다. 동전을 적절히 사용해 그 가격의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는
    프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 N과 K(1≤N≤10,1≤K≤100,000,000), 2번째 줄부터 N개의 줄에 동전의 가격 Ai가 오름차순으로 주어진다(1≤Ai≤1,000,000, A1=1, i≥2일 때 A(i)는 A(i-1)의 배수).
  ### 출력
  - 1번째 줄에 K원을 만드는 데 필요한 동전 개수의 최솟값을 출력한다.
  ### 예제 입력1
  ```java
  10 4200   // 동전 수, 목표 금액
  1
  5
  10
  50
  100
  500
  1000
  5000
  10000
  50000
  ```
  ### 예제 출력1
  ```java
  6
  ```
  ### 예제 입력2
  ```java
  10 4790
  1
  5
  10
  50
  100
  500
  1000
  5000
  10000
  50000
  ```
  ### 예제 출력2
  ```java
  12
  ```
  ### [1단계] 문제 분석하기
  - 전형적인 그리디 알고리즘 문제이다. 이 문제는 그리디 알고리즘으로 풀 수 있도록 뒤의 동전 가격 A(i)가 앞에 나오는 동전 가격 A(i-1)의 배수가 된다는 조건을 부여했다.
    즉, 동전을 최소로 사용하여 K를 만들기 위해서는 가장 가격이 큰 동전부터 차례대로 사용하면 된다.
  ### [2단계] 손으로 풀어보기
  1. 가격이 큰 동전부터 내림차순으로 K보다 가격이 작거나 같은 동전이 나올 때까지 탐색한다.
  2. 탐색을 멈춘 동전의 가격으로 K를 나눠 몫은 동전 개수에 더하고, 나머지는 K값으로 업데이트한다.
  3. 과정 1~2를 나머지가 0이 될 때까지 반복한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(동전 개수) K(목표 금액)
  A(동전 데이터 배열)
  배열 선언 for (N만큼 반복하기) {
    A 배열 저장하기
  }
  // 가치가 큰 동전부터 선택해야 개수를 최소로 구성할 수 있음
  for (N만큼 반복 -> N-1 ~ 0으로 역순으로 반복하기) {
    if (현재 K보다 동전 가치가 작으면) {
      동전 수 += 목표 금액 / 현재 동전 가치
      목표 금액 = 목표 금액 % 현재 동전 가치
    }
  }
  누적된 동전 수 출력하기
  ```
  ### [4단계] 코드 구현하기
  - [exam032_동전개수최솟값](src/book/ch06/exam032_동전개수최솟값.java)
### [문제 033] : 카드 정렬하기 (2s)
  ### 문제
  - 정렬된 두 묶음의 숫자 카드가 있다. 각 묶음의 카드의 개수가 A,B일 때 보통 두 묶음을 합쳐 1개로 만들려면 A+B번 비교해야 한다. 예를 들어 20장의 숫자 카드 묶음과 30장의
    숫자 카드 묶음을 합치려면 50번의 비교가 필요하다.<br/>
    매우 많은 숫자 카드 묶음이 책상 위에 놓여 있다고 가정해 보자. 이들을 두 묶음씩 골라 서로 합쳐 나가면 고르는 순서에 따라 비교 횟수가 달라진다. 예를 들어 10장, 20장,
    40장의 묶음이 있다면 10장과 20장을 합친 후 합친 30장 묶음과 40장을 합치면 (10+20) + (30+40) = 100번의 비교가 필요하다. 그러나 10장과 40장을 합친 후 합친 50장 묶음과
    20장을 합치면 (10+40) + (50+20) = 120번의 비교가 필요하므로 덜 효율적이다.<br/>
    N개의 숫자 카드 묶음의 각각의 크기가 주어질 때 최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 N이 주어진다(1≤N≤100,000). 그다음 N개의 줄에 걸쳐 숫자 카드 묶음의 각각의 크기가 주어진다. 숫자 카드 묶음의 크기는 1,000보다 작거나 같은 양의 정수다.
  ### 출력
  - 1번째 줄에 최소 비교 횟수를 출력한다.
  ### 예제 입력1
  ```java
  3    // 카드 묶음 수
  10
  20
  40
  ```
  ### 예제 출력1
  ```java
  100
  ```
  ### [1단계] 문제 분석하기
  - 잘 생각하면 먼저 선택된 카드 묶음이 비교 횟수에 더 많은 영향을 미치는 것을 알 수 있다. 따라서 카드 묶음의 카드의 개수가 작은 순서대로 먼저 합치는 것이
    전체 비교 횟수를 줄일 수 있는 방법이다. 현재 데이터 중 가장 작은 카드의 개수를 가진 묶음 2개를 뽑아야 하고, 이 2개를 기준으로 합친 새로운 카드 묶음을 다시
    데이터에 넣고 정렬해야 한다. 즉, 데이터의 삽입, 삭제, 정렬이 자주 일어난다는 뜻이다. 따라서 이 문제는 우선순위 큐를 이용해야 한다.
  ### [2단계] 손으로 풀어보기
  1. 현재 카드의 개수가 가장 작은 묶음 2개를 선택해 합친다.
  2. 합친 카드 묶음을 다시 전체 카드 묶음 속에 넣는다.
  3. 과정 1~2를 카드 묶음이 1개만 남을 때까지 반복한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(카드 묶음 개수)
  pq(우선순위 큐)
  배열 선언 for (N만큼 반복하기) {
    우선순위 큐에 데이터 저장하기
  }
  // 자동 정렬에 따라 작은 카드 묶음 2개를 쉽게 뽑을 수 있음
  while (우선순위 큐 크기가 1이 될 때까지) {
    2개 카드 묶음을 큐에서 뽑음(remove 연산)
    2개 카드 묶음을 합치는 데 필요한 비교 횟수를 결괏값에 더함
    2개 카드 묶음의 합을 우선순위 큐에 다시 넣음(add 연산)
  }
  비교 횟수 합계 출력하기
  ```
  ### [4단계] 코드 구현하기
  - [exam033_카드정렬하기](src/book/ch06/exam033_카드정렬하기.java)
### [문제 034] : 수를 묶어서 최댓값 만들기 (0.5s)
  ### 문제
  - 길이가 N인 수열이 주어질 때 수열의 합을 구하려고 한다. 그런데 수열의 합을 구하기 전에 먼저 수열 안에 있는 임의의 두 수를 묶으려 한다. 위치에 상관없이 두 수를
    묶을 수 있다. 단, 같은 위치에 있는 수(자기 자신)를 묶을 수는 없다. 묶인 두 수는 수열의 합을 구할 때 서로 곱한 후 계산한다. 수열의 모든 수는 각각 한 번씩만 묶을 수 있다.
    예를 들어 어떤 수열이 {0,1,2,4,3,5}일 때 그냥 이 수열의 합을 구하면 0+1+2+4+3+5=15이다. 하지만 2와 3을 묶고, 4와 5를 묶으면 0+1+(2*3)+(4*5)=26이 돼 최댓값이 나온다.<br/>
    주어진 수열의 각 수를 적절히 묶어 그 합을 최대로 만드는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 수열의 크기 N이 주어진다. N은 10,000보다 작은 자연수다. 2번째 줄부터 N개의 줄에 수열의 각 수가 주어진다. 수열의 수는  -10,000보다 크거나 같고, 10,000보다
    작거나 같은 정수다.
  ### 출력
  - 합이 최대가 나오게 수를 묶었을 때 그 합을 출력한다. 정답은 항상 231보다 작다.
  ### 예제 입력1
  ```java
  9  // 수의 개수
  -1
  -8
  2
  1
  3
  6
  -5
  0
  1
  ```
  ### 예제 출력1
  ```java
  62
  ```
  ### [1단계] 문제 분석하기
  - N의 최대 범위가 10,000이므로 시간 복잡도와 관련된 제약은 적은 문제이다. 문제의 내용에 집중해 아이디어를 생각해보자. 가능한 한 큰 수들끼리 묶어야 결괏값이 커진다는
    것을 알 수 있다. 주어진 수열이 1,2,3,4라면 1*4 + 2*3 보다 1*2 + 3*4의 결괏값이 더 크다. 또한 음수끼리 곱하면 양수로 변하는 성질을 추가로 고려해 문제를 풀어야한다.
  ### [2단계] 손으로 풀어보기
  1. 수의 집합을 1보다 큰 수, 1, 0, 음수 이렇게 4가지 유형으로 나눠 저장한다.
  2. 1보다 큰 수의 집합을 정렬해 최댓값부터 차례대로 곱한 후에 더한다. 원소의 개수가 홀수일 때 마지막 남은 수는 그대로 더한다.
  3. 음수의 집합을 정렬해 최솟값부터 차례대로 곱한 후에 더한다. 원소의 개수가 홀수일 때 수열에 0이 있다면 1개 남는 음수를 0과 곱해 0을 만들고, 수열에 0이 없다면 그대로 더한다.
  4. 과정 2~3에서 구한 값을 더하고, 그 값에 숫자 1의 개수를 더한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(수의 개수)
  plusPq(양수 우선순위 큐) minusPq(음수 우선순위 큐)
  one(1의 개수 카운트) zero(0의 개수 카운트)
  배열 선언 for (N만큼 반복하기) {
    데이터를 4개의 그룹에 분리 저장하기
  }
  while (양수 우선순위 큐 크기가 2보다 작을 때까지) {
    수 2개를 큐에서 뽑음(remove 연산)
    2개의 수를 곱한 값을 결괏값에 더함
  }
  양수 우선순위 큐에 데이터가 남아 있으면
  이 데이터를 결괏값에 더함
  while (음수 우선순위 큐 크기가 2보다 작을 때까지) {
    수 2개를 큐에서 뽑음(remove 연산)
    2개의 수를 곱한 값을 결괏값에 더함
  }
  음수 우선순위 큐에 데이터가 남아 있고, 데이터 0이 1개도 없으면
  이 데이터를 결괏값에 더함
  숫자 1의 개수를 결괏값에 더함
  ```
  ### [4단계] 코드 구현하기
  - [exam034_수묶기](src/book/ch06/exam034_수묶기.java)
### [문제 035] : 회의실 배정하기 (2s)
  ### 문제
  - 1개의 회의실에서 N개의 회의를 진행하기 위해 회의실 사용표를 만들려고 한다. 각 회의마다 시작 시간과 끝나는 시간이 주어질 때 회의 시간이 겹치지 않으면서 회의를 가장
    많이 진행하려면 최대 몇 번까지 할 수 있는지 알아보자. 단, 회의를 시작하면 중간에 중단할 수 없고, 한 회의를 끝내는 것과 동시에 다음 회의를 시작할 수 있다. 회의의
    시작과 끝나는 시간이 같을 수도 있는데, 이때는 시작하자마자 끝나는 것으로 생각하면 된다.
  ### 입력
  - 1번째 줄에 회의의 수 N(1≤N≤100,000), 2번째 줄부터 N+1줄까지는 각 회의의 시작 시간과 끝나는 시간이 공백을 사이에 두고 주어진다. 시작 시간과 끝나는 시간은 1보다 크거나
    같은 자연수 또는 0이다.
  ### 출력
  - 1번째 줄에 진행할 수 있는 회의의 최대 개수를 출력한다.
  ### 예제 입력1
  ```java
  11    // 회의 개수
  1 4
  3 5
  0 6
  5 7
  3 8
  5 9
  6 10
  8 11
  8 12
  2 13
  12 14
  ```
  ### 예제 출력1
  ```java
  4
  ```
  ### [1단계] 문제 분석하기
  - 문제에서는 1개의 회의실에 회의가 겹치지 않게 최대한 많은 회의를 배정해야 한다. 이때는 그리디 알고리즘을 적용해야 하는데, 현재 회의의 종료 시간이 빠를수록 다음 회의와
    겹치지 않게 시작하는 데 유리하다. 그렇기 때문에 종료 시간이 빠른 순서대로 정렬해 겹치지 않는 회의를 적절하게 선택하면 이 문제를 해결할 수 있다.
  ### [2단계] 손으로 풀어보기
  1. 회의 정보와 관련된 데이터를 저장한 후 종료 시간 순으로 정렬한다. 단, 종료 시간이 같을 때는 시작 시간을 기준으로 다시 한번 정렬한다.
  2. 순차적으로 탐색하다가 시간이 겹치지 않는 회의가 나오면 선택한다.
  - 종료 시간이 같은 경우
    - 위 문제에 나오지는 않았지만, 종료 시간이 같을 때는 시작 시간이 빠른 순으로 정렬하는 기준이 포함돼야 한다. 문제에서 회의의 시작 시간과 종료 시간이 같을 수도 있다고
      했기 때문이다. 따라서 종료 시간이 같으면 시작 시간이 빠른 순서로 정렬하는 로직도 추가해야 한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(회의 개수) A(회의 정보 저장)
  for (회의 개수만큼 반복하기) {
    if (앞 회의의 종료 시간보다 시작 시간이 뒤인 회의가 나온 경우) {
      현재 회의의 종료 시간으로 종료 시간 업데이트하기
      진행할 수 있는 회의 수 1 증가
    }
  }
  총 진행 가능 회의 수 출력하기
  ```
  ### [4단계] 코드 구현하기
  - [exam035_회의실배정](src/book/ch06/exam035_회의실배정.java)
### [문제 036] : 최솟값을 만드는 괄호 배치 찾기 (2s)
  ### 문제
  - 세준이는 양수와 +, - 그리고 괄호를 이용해 어떤 수식을 만들었다. 그리고 괄호를 모두 지우고, 다시 괄호를 적절히 넣어 이 수식의 값을 최소로 만들려고 한다.
    이렇게 수식의 괄호를 다시 적절하게 배치해 수식의 값을 최소로 만드는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 식이 주어진다. 식은 '0'~'9', '+' 그리고 '-' 만으로 이뤄져 있고, 가장 처음과 마지막 문자는 숫자다. 그리고 연속해서 2개 이상의 연산자가 다시 나타나지 않고,
    5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다.
  ### 출력
  - 1번째 줄에 정답을 출력한다.
  ### 예제 입력1
  ```java
  100-40+50+74-30+29-45+43+11
  ```
  ### 예제 출력1
  ```java
  -222
  ```
  ### [1단계] 문제 분석하기
  - 그리디의 관점에서 생각하면 쉽게 풀 수 있는 문제이다. 가장 작은 최솟값을 만들기 위해서는 가능한 한 큰 수를 빼야 한다. 수식이 더하기와 빼기 연산만으로 이뤄져 있기
    때문에 더하기에 해당하는 부분에 괄호를 쳐서 모두 계산한 후 빼기를 실행하면 문제가 해결된다.
  ### [2단계] 손으로 풀어보기
  1. 가장 먼저 더하기 연산을 실행한다.
  2. 가장 앞에 있는 값에서 더하기 연산으로 나온 결괏값들을 모두 뺀다.
  ### [3단계] 슈도코드 작성하기
  ```java
  answer(정답 변수)
  들어온 데이터를 "-" 기호를 기준으로 split() 수행하기
  for (나눠진 데이터 개수만큼 반복하기) {
    결괏값 = mySum() 함수 수행하기
    if (가장 앞 데이터일 때) answer에 결괏값 더하기
    else answer에 결괏값 빼기
  }
  answer 출력하기
  mySum() 함수 구현하기 {     // 현재 String에 있는 수를 모두 더하는 함수
    현재 들어온 String값을 "+" 기호 기준으로 split() 수행하기
    for (나눠진 데이터 개수만큼 반복하기) {
      String 값을 Integer형으로 변환해 리턴값에 더하기
    }
    전체 합 리턴하기
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam036_잃어버린괄호](src/book/ch06/exam036_잃어버린괄호.java)
