# 자료구조
<br/>

# 목차
1. [배열과 리스트](#1-배열과-리스트)
2. [구간 합](#2-구간-합)
3. [투 포인터](#3-투-포인터)
4. [슬라이딩 윈도우](#4-슬라이딩-윈도우)
5. [스택과 큐](#5-스택과-큐)
<br/>

# 1. 배열과 리스트
## (1) 배열과 리스트의 핵심 이론
- ### 배열 : 메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조
  - **인덱스**를 사용하여 값에 바로 접근할 수 있다.
  - 새로운 값을 삽입하거나 특정 인덱스에 있는 값을 삭제하기 어렵다. 값을 삽입하거나 삭제하려면 해당 인덱스 **주변에 있는 값들을 이동**시키는 과정이 필요하다.
  - 배열의 크기 및 자료형은 선언할 때 지정할 수 있으며, 한 번 선언하면 변경할 수 없다.
  - 구조가 간단하므로 코딩 테스트에서 많이 사용한다.
- ### 리스트 : 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조
  - 인덱스가 없으므로 값에 접근하려면 Head 포인터부터 순서대로 접근해야 한다. 다시 말해 값에 접근하는 속도가 느리다.
  - 포인터로 연결되어 있으므로 데이터를 삽입하거나 삭제하는 연산 속도가 빠르다.
  - 선언할 때 크기를 별도로 지정하지 않아도 된다. 다시 말해 리스트의 크기는 정해져 있지 않으며, 크기가 변하기 쉬운 데이터를 다룰 때 적절하다.
  - 포인터를 저장할 공간이 필요하므로 배열보다 구조가 복잡하다.
- ### [문제 001] : 숫자의 합 구하기 (2s)
  - ### 문제
    - N개의 숫자가 공백 없이 써 있다. 이 숫자를 모두 합해 출력하는 프로그램을 작성하시오.
  - ### 입력
    - 1번째 줄에 숫자의 개수 N(1≤N≤100), 2번째 줄에 숫자 N개가 공백 없이 주어진다.
  - ### 출력
    - 입력으로 주어진 숫자 N개의 합을 출력한다.
  - ### 예제 입력1
    ```java
    1 // 숫자의 개수
    1 // 공백 없이 주어진 N개의 숫자
    ```
  - ### 예제 출력1
    ```java
    1
    ```
  - ### 예제 입력2
    ```java
    5
    54321
    ```
  - ### 예제 출력2
    ```java
    15
    ```
  - ### 예제 입력3
    ```java
    25
    7000000000000000000000000
    ```
  - ### 예제 출력3
    ```java
    7
    ```
  - ### 예제 입력4
    ```java
    11
    10987654321
    ```
  - ### 예제 출력4
    ```java
    46
    ```
  - ### [1단계] 문제 분석하기
    - N의 범위가 1부터 100까지이므로 값을 int형, long형과 같은 숫자형으로 담을 수 없다.
      먼저 **문자열 형태**로 입력값을 받은 후 이를 문자 배열로 변환하고, 문자 배열값을 순서대로 읽으면서 숫자형으로 변환하여 더해야 한다.
      - `문자형을 숫자형으로 변경하려면 아스키코드 개념 필요`
  - ### [2단계] 손으로 풀어 보기
    1. 숫자의 개수만큼 입력받은 값을 String형으로 저장한다.
    2. String형으로 입력받은 값을 char[]형으로 변환한다.
    3. 인덱스 0부터 끝까지 배열을 탐색하며 각 값을 정수형으로 변환하고 결괏값에 더하여 누적한다.
  - ### [3단계] 슈도코드 작성하기
    ```java
    N값 입력받기
    길이 N의 숫자를 입력받아 String형 변수 sNum에 저장하기
    sNum을 다시 char[]형 변수 cNum에 변환하여 저장하기
    int형 변수 sum 선언하기
    for (cNum 길이만큼 반복하기)
    {
      배열의 각 자릿값을 정수형으로 변환하며 sum에 더하여 누적하기
    }
    sum 출력하기
    ```
  - ### [4단계] 코드 구현하기
    - [exam001_숫자의합](src/book/ch03/exam001_숫자의합.java)
- ### [문제 002] : 숫자의 합 구하기 (2s)
  - ### 문제
    - 세준이는 기말고사를 망쳤다. 그래서 점수를 조작해 집에 가져가기로 결심했다. 일단 세준이는 자기 점수 중 최댓값을 골랐다. 그런 다음 최댓값을 M이라 할 때 모든 점수를 `점수/M*100`으로 고쳤다.
      예를 들어 세준이의 최고점이 70점, 수학 점수가 50점이라면 수학 점수는 `50/70*100`이므로 71.43점이다. 세준이의 성적을 이 방법으로 계산했을 때 새로운 평균을 구하는 프로그램을 작성하시오.
  - ### 입력
    - 1번째 줄에 시험을 본 과목의 개수 N이 주어진다. 해당 값은 1,000보다 작거나 같다.
      2번째 줄에 세준이의 현재 성적이 주어진다. 해당 값은 100보다 작거나 같은, 음이 아닌 정수이고, 적어도 1개의 값은 0보다 크다.
  - ### 출력
    - 1번째 줄에 새로운 평균을 출력한다. 실제 정답과 출력값의 절대 오차 또는 상대 오차가 10^(-2) 이하이면 정답이다.
  - ### 예제 입력1
    ```java
    3          // 시험을 본 과목의 개수
    40 80 60   // 각 과목의 시험 성적
    ```
  - ### 예제 출력1
    ```java
    75.0
    ```
  - ### 예제 입력2
    ```java
    3
    10 20 30
    ```
  - ### 예제 출력2
    ```java
    66.666667
    ```
  - ### 예제 입력3
    ```java
    4
    1 100 100 100
    ```
  - ### 예제 출력3
    ```java
    75.25
    ```
  - ### 예제 입력4
    ```java
    5
    1 2 4 8 16
    ```
  - ### 예제 출력4
    ```java
    38.75
    ```
  - ### 예제 입력5
    ```java
    2
    3 10
    ```
  - ### 예제 출력5
    ```java
    65.0
    ```
  - ### [1단계] 문제 분석하기
    - 최고 점수를 기준으로 전체 점수를 다시 계산해야 하므로 모든 점수를 입력받은 후에 최고점을 별도로 저장해야 한다. 또한 문제에서 제시한 한 과목의 점수를 계산하는 식은 총합과 관련된 식으로 변환할 수 있다.
      또한 문제에서 제시한 한 과목의 점수를 계산하는 식은 총합과 관련된 식으로 변환할 수 있다. 따라서 일일이 변환 점수를 구할 필요 없이 한번에 변환한 점수의 평균 점수를 구할 수 있다.
    - 변환 점수의 평균을 구하는 식 (점수가 A,B,C인 경우)
      - (A / M * 100 + B / M * 100 + C / M * 100) / 3 = (A + B + C) * 100 / M / 3
  - ### [2단계] 손으로 풀어 보기
    1. 점수를 1차원 배열에 저장한다.
    2. 배열을 탐색하며 최고 점수와 점수의 총합을 구한다.
    3. '총합 * 100 / 최고 점수 / 과목의 수'를 계산해 다시 계산한 점수의 평균값을 출력한다.
  - ### [3단계] 슈도코드 작성하기
    ```java
    변수 N에 과목의 수 입력받기
    길이가 N인 1차원 배열 A[] 선언하기
    for (A[] 길이만큼 반복하기) {
      A[i]에 각 점수 저장하기
    }
    for (A[] 길이만큼 반복하기) {
      최고점은 변수 max에, 총점은 변수 sum에 저장하기
    }
    sum * 100 / max / N 출력하기
  - ### [4단계] 코드 구현하기
    - [exam002_평균](src/book/ch03/exam002_평균.java)

# 2. 구간 합
- 구간 합은 합 배열을 이용하여 시간 복잡도를 더 줄이기 위해 사용하는 특수한 목적의 알고리즘이다.
## (1) 구간 합의 핵심 이론
- 합 배열은 기존의 배열을 전처리한 배열이며, 합 배열을 미리 구해 놓으면 기존 배열의 일정 범위의 합을 구하는 시간 복잡도가 **Ο(N)에서 Ο(1)**로 감소한다.
- 합 배열 S 정의
  - `S[i] = A[0] + A[1] + A[2] + ... + A[i-1] + A[i]`   //A[0]부터 A[i]까지의 합
- 합 배열 S를 만드는 공식
  - `S[i] = S[i-1] + A[i]`
- 구간 합을 구하는 공식
  - `S[j] - S[i-1]`   // i에서 j까지 구간 합
- ### [문제 003] : 구간 합 구하기 (0.5s)
  - ### 문제
    - 수 N개가 주어졌을 때 i번째 수에서 j번째 수까지의 합을 구하는 프로그램을 작성하시오.
  - ### 입력
    - 1번째 줄에 수의 개수 N(1≤N≤100,000), 합을 구해야 하는 횟수 M(1≤M≤100,000),
      2번째 줄에 N개의 수가 주어진다. 각 수는 1,000보다 작거나 같은 자연수다.
      3번째 줄부터는 M개의 줄에 합을 구해야 하는 구간 i와 j가 주어진다.
  - ### 출력
    - 총 M개의 줄에 입력으로 주어진 i번째 수에서 j번째 수까지의 합을 출력한다.
  - ### 예제 입력1
    ```java
    5 3         // 데이터의 개수, 질의 개수
    5 4 3 2 1   // 구간 합을 구할 대상 배열
    1 3
    2 4
    5 5
    ```
  - ### 예제 출력1
    ```java
    12
    9
    1
    ```
  - ### [1단계] 문제 분석하기
    - 문제에서 수의 개수와, 합을 구해야 하는 횟수는 최대 100,000이다. 게다가 구간마다 합을 매번 계산하면 0.5초 안에 모든 구간 합 계산을 끝낼 수 없다.
      이럴 때 바로 구간 합을 이용해야 한다. 구간 합 개념을 적용하는 가장 기본적인 문제이다.
  - ### [2단계] 손으로 풀어보기
    1. N개의 수를 입력받음과 동시에 합 배열을 생성한다.
    2. 구간 i~j가 주어지면 구간 합을 구하는 공식으로 정답을 출력한다.
  - ### [3단계] 슈도코드 작성하기
    ```java
    suNo(숫자 개수), quizNo(질의 개수) 저장하기
    for (숫자 개수만큼 반복하기) {
      합 배열 생성하기 (S[i] = S[i-1] + A[i])
    }
    for (질의 개수만큼 반복하기) {
      질의 범위 받기(i ~ j)
      구간 합 출력하기 (S[j] - S[i-1])
    }
    ```
  - ### [4단계] 코드 구현하기
    - [exam003_구간합](src/book/ch03/exam003_구간합.java)
- ### [문제 004] : 구간 합 구하기2 (1s)
  - ### 문제
    - N ⨯ N개의 수가 N ⨯ N 크기의 표에 채워져 있다. 표 안의 수 중 (X1,Y1)에서 (X2,Y2)까지의 합을 구하려 한다. X는 행, Y는 열을 의미한다.
      표에 채워져 있는 수와 합을 구하는 연산이 주어졌을 때 이를 처리하는 프로그램을 작성하시오.
  - ### 입력
    - 1번째 줄에 표의 크기 N과 합을 구해야 하는 횟수 M이 주어진다(1≤N≤1024, 1≤M≤100,000).
      2번째 줄부터 N개의 줄에는 표에 채워져 있는 수가 1행부터 차례대로 주어진다.
      다음 M개의 줄에는 4개의 정수 X1, Y1, X2, Y2가 주어지며, (X1,Y1)에서 (X2,Y2)의 합을 구해 출력해야 한다.
      표에 채워져 있는 수는 1,000보다 작거나 같은 자연수다(X1≤X2, Y1≤Y2).
  - ### 출력
    - 총 M줄에 걸쳐 (X1, Y1)에서 (X2, Y2)까지 합을 구해 출력한다.
  - ### 예제 입력1
    ```java
    4 3       // 2차원 배열의 크기, 구간 합 질의의 개수
    1 2 3 4   // 원본 배열 1번째 줄
    2 3 4 5   // 원본 배열 2번째 줄
    3 4 5 6   // 원본 배열 3번째 줄
    4 5 6 7   // 원본 배열 4번째 줄
    2 2 3 4   // 구간 합 (X1,Y1), (X2,Y2) 1번째 질의
    3 4 3 4   // 구간 합 (X1,Y1), (X2,Y2) 2번째 질의
    1 1 4 4   // 구간 합 (X1,Y1), (X2,Y2) 3번째 질의
    ```
  - ### 예제 출력1
    ```java
    27
    6
    64
    ```
  - ### 예제 입력2
    ```java
    2 4
    1 2
    3 4
    1 1 1 1
    1 2 1 2
    2 1 2 1
    2 2 2 2
    ```
  - ### 예제 출력2
    ```java
    1
    2
    3
    4
    ```
  - ### [1단계] 문제 분석하기
    - 먼저 질의의 개수가 100,000이므로 이 문제 역시 질의마다 합을 구하면 안 되고, 구간 합 배열을 이용해야 한다는 것을 알 수 있다.
      구간 합 배열이 1차원에서 2차원으로 확장된 것으로 생각하여 구간 합 배열을 어떻게 구성할지 고민하는 것이 이 문제의 핵심이다.
      - 2차원 구간 합 배열 D[X][Y] 정의
        - `D[X][Y] = 원본 배열의 (0,0)부터 (X,Y)까지의 사각형 안에 있는 수의 합`
  - ### [2단계] 손으로 풀어보기
    1. 2차원 구간 합 배열의 1행, 1열부터 구합니다. 구간 합 배열 1행, 1열은 다음과 같이 구합니다.
       - D[i][1] = D[i-1][1] + A[i][1]     // 1열
       - D[1][i] = D[1][i-1] + A[1][i]     // 1행
    2. 이를 통해 나머지 2차원 구간 합 배열을 채운다.
       - `D[i][j] = D[i-1][j] + D[i][j-1] - D[i-1][j-1] + A[i][j]`
    3. 질의 X1, Y1, X2, Y2에 대한 답을 구간 합으로 구하는 방법
       - 'D[X2][Y2] - D[X1-1][Y2] - D[X2][Y1-1] + D[X1-1][Y1-1]`
  - ### [3단계] 슈도코드 작성하기
    ```java
    N (배열 크기) M (질의 수) 저장하기
    for (N만큼 반복하기) {
      for (N만큼 반복하기) {
        원본 배열 저장하기
      }
    }
    for (N만큼 반복하기) {
      for (N만큼 반복하기) {
        합 배열 저장하기
        D[i][j] = D[i-1][j] + D[i][j-1] - D[i-1][j-1] + A[i][j];
      }
    }
    for (M만큼 반복하기) {
      질의 계산 및 출력하기
      결과 = D[x2][y2] - D[x1-1][y2] - D[x2][y1-1] + D[x1-1][y1-1];
    }
    ```
  - ### [4단계] 코드 구현하기
    - [exam004_구간합2](src/book/ch03/exam004_구간합2.java)
- ### [문제 005] : 나머지 합 구하기 (1s)
  - ### 문제
    - N개의 수 A1, A2, ..., AN이 주어졌을 때 연속된 부분의 합이 M으로 나누어떨어지는 구간의 개수를 구하는 프로그램을 작성하시오.
      즉, Ai + ... + Aj(i≤j)이 합이 M으로 나누어떨어지는 (i,j) 쌍의 개수를 구하시오.
  - ### 입력
    - 1번째 줄에 N과 M(1≤N≤106, 2≤M≤103), 2번째 줄에 N개의 수 A1, A2, ..., AN이 주어진다(0≤Ai≤109).
  - ### 출력
    - 1번째 줄에 연속된 부분의 합이 M으로 나누어떨어지는 구간의 개수를 출력한다.
  - ### 예제 입력1
    ```java
    5 3
    1 2 3 1 2
    ```
  - ### 예제 출력1
    ```java
    7
    ```
  - ### [1단계] 문제 분석하기
    - N의 최댓값이 106이라 연산량이 작게 느껴질 수 있다. 하지만 잠시 생각해 보면 106개의 수에 대하여 모든 구간 합을 구해야 하므로 1초 안에 연산하기는 어렵다.
      여기서도 구간 합 배열을 이용해야 한다.
    - 나머지 합 문제 풀이의 핵심 아이디어
      - (A + B) % C은 ((A % C) + (B % C)) % C와 같다. 다시 말해 특정 구간 수들의 나머지 연산을 더해 나머지 연산을 한 값과 이 구간 합의 나머지 연산을 한 값은 동일하다.
      - 구간 합 배열을 이용한 식 S[i] - S[j]는 원본 배열의 j + 1부터 i까지의 구간 합이다.
      - S[i] % M의 값과 S[j] % M의 값이 같다면 (S[i] - S[j]) % M은 0이다. 즉, 구간 합 배열의 원소를 M으로 나눈 나머지로 업데이트하고 S[i]와 S[j]가 같은 (i,j) 쌍을 찾으면
        원본 배열에서 j + 1부터 i까지의 구간 합이 M으로 나누어떨어진다는 것을 알 수 있다.
  - ### [2단계] 손으로 풀어보기
    1. A 배열의 합 배열 S를 생성한다.
    2. 합 배열 S의 모든 값을 M으로 나머지 연산을 수행해 값을 업데이트한다.
    3. 우선 변경된 합 배열에서 원소 값이 0인 개수만 세어 정답에 더한다. 변경된 합 배열의 원소 값이 0이라는 것은 원본 배열의 0부터 i까지의 구간 합이 이미 M으로 나누어떨어진다는 뜻이다.
    4. 변경된 합 배열에서 원소 값이 같은 인덱스의 개수, 즉, 나머지 값이 같은 합 배열의 개수를 센다. 변경된 합 배열에서 원소 값이 같은 2개의 원소를 뽑는 경우의 수를 구하여 정답에 더하면 된다.
  - ### [3단계] 슈도코드 작성하기
    ```java
    N 입력받기 (수열의 개수)
    M 입력받기 (나누어덜어져야 하는 수)
    S 선언하기 (합 배열)
    C 선언하기 (같은 나머지의 인덱스를 카운트하는 배열)
    for (i -> 1 ~ N) {
      S[i] = S[i-1] + A[i]    // 합 배열 저장
    }
    for (i -> 0 ~ N) {
      remainder = S[i] % M    // 합 배열을 M으로 나눈 나머지 값
      if (remainder == 0) 정답을 1 증가시키기
      C[remainder]의 값을 1 증가시키기
    }
    for (i -> 0 ~ M) {
      C[i](i가 나머지인 인덱스의 개수)에서 2가지를 뽑는 경우의 수를 정답에 더하기
      // C[i]개 중 2개를 뽑는 경우의 수 계산 공식 : C[i] * (C[i]-1) / 2
    }
    결괏값(answer) 출력
    ```
  - ### [4단계] 코드 구현하기
    - [exam005_나머지합](src/book/ch03/exam005_나머지합.java)

# 3. 투 포인터
- 투 포인터는 2개의 포인터로 알고리즘의 시간 복잡도를 최적화한다.
- ### [문제 006] : 연속된 자연수의 합 구하기 (2s)
  - ### 문제
    - 어떠한 자연수 N은 몇 개의 연속된 자연수의 합으로 나타낼 수 있다. 당신은 어떤 자연수 N(1≤N≤10,000,000)을 몇 개의 연속된 자연수의 합으로 나타내는 가짓수를 알고 싶다.
      이때 사용하는 자연수는 N이어야 한다. N을 입력받아 연속된 자연수의 합으로 나타내는 가짓수를 출력하는 프로그램을 작성하시오.
  - ### 입력
    - 1번째 줄에 정수 N이 주어진다.
  - ### 출력
    - 입력된 자연수 N을 연속된 자연수의 합으로 나타내는 가짓수를 출력한다.
  - ### 예제 입력1
    ```java
    15  // N
    ```
  - ### 예제 출력1
    ```java
    4
    ```
  - ### [1단계] 문제 분석하기
    - 이 문제는 시간 복잡도 분석으로 사용할 알고리즘의 범위부터 줄여야 한다. 우선 문제에 주어진 시간 제한은 2초이다. 그런데 N의 최댓값은 10,000,000으로 매우 크게 잡혀 있다.
      이런 상황에서는 Ο(nlogn)의 시간 복잡도 알고리즘을 사용하면 제한 시간을 초과하므로 Ο(n)의 시간 복잡도 알고리즘을 사용해야 한다. 이런 경우 자주 사용하는 방법이 투 포인터이다.
      연속된 자연수의 합을 구하는 것이 문제이므로 시작 인덱스와 종료 인덱스를 지정하여 연속된 수를 표현하고 시작 인덱스, 종료 인덱스를 투 포인터로 지정한 후 문제에 접근해보자
  - ### [2단계] 손으로 풀어보기
    1. 입력받은 값을 N에 저장한 후 코드에서 사용할 변수를 모두 초기화한다.
       결과 변수 count를 1로 초기화하는 이유는 N이 15일 때 숫자 15만 뽑는 경우의 수를 미리 넣고 초기화했기 때문이다.
    2. 투 포인터 이동 원칙을 활용해 배열의 끝까지 탐색하면서 합이 N이 될 경우의 수를 구한다.
       start_index를 오른쪽으로 한 칸 이동하는 것은 연속된 자연수에서 왼쪽 값을 삭제하는 것과 효과가 같으며, end_index를 오른쪽으로 한 칸 이동하는 것은
       연속된 자연수의 범위를 한 칸 더 확장하는 의미이다. 같을 때는 경우의 수를 1 증가시키고, end_index를 오른쪽으로 이동시킨다.
       - [투 포인터 이동 원칙]
         * sum > N : sum = sum - start_index; start_index++;
         * sum < N : end_index++, sum = sum + end_index;
         * sum == N : count++; end_index++; sum = sum + end_index;
    3. 2단계를 end_index가 N이 될 때까지 반복하되, 포인터가 이동할 때마다 현재의 총합과 N을 비교해 값이 같으면 count를 1만큼 증가시킨다.
  - ### [3단계] 슈도코드 작성하기
    ```java
    N 변수 저장
    사용 변수 초기화 (count = 1, start_index = 1, end_index = 1, sum = 1)
    while (end_index != N) {
      if (sum == N) count 증가, end_index 증가, sum값 변경
      else if (sum > N) sum값 변경, start_index 증가
      else if (sum < N) end_index 증가, sum값 변경
    }
    count 출력하기
    ```
  - ### [4단계] 코드 구현하기
    - [exam006_연속된자연수의합]()
- ### [문제 007] : 주몽의 명령 (2s)
  - ### 문제
    - 주몽은 철기군을 양성하기 위한 프로젝트에 나섰다. 그래서 야철대장에게 철기군이 입을 갑옷을 만들라고 명령했다.
      야철대장은 주몽의 명령에 따르기 우해 연구에 착수하던 중 갑옷을 만드는 재료들은 각각 고유한 번호가 있고, 갑옷은 2개의 재료로 만드는 데 2가지 재료의 고유한 번호를 합쳐
      M(1≤M≤10,000,000)이 되면 갑옷이 만들어진다는 사실을 발견했다. 야철대장은 자신이 만들고 있는 재료로 갑옷을 몇 개나 만들 수 있을지 궁금해졌다.
      야철대장의 궁금증을 풀어 주기 위해 N(1≤N≤15,000)개의 재료와 M이 주어졌을 때 몇 개의 갑옷을 만들 수 있는지를 구하는 프로그램을 작성하시오.
  - ### 입력
    - 1번째 줄에 재료의 개수 N(1≤N≤15,000), 2번째 줄에 갑옷을 만드는 데 필요한 수 M(1≤M≤10,000,000)이 주어진다.
      3번째 줄에는 N개의 재료들이 가진 고유한 번호들이 공백을 사이에 두고 주어진다. 고유한 번호는 100,000보다 작거나 같은 자연수다.
  - ### 출력
    - 1번째 줄에 갑옷을 만들 수 있는 개수를 출력한다.
  - ### 예제 입력1
    ```java
    6              // 재료의 개수
    9              // 갑옷이 완성되는 번호의 합
    2 7 4 1 5 3    // 재료들
    ```
  - ### 예제 출력1
    ```java
    2
    ```
  - ### [1단계] 문제 분석하기
    - 우선 시간 복잡도를 고려해보자. 두 재료의 번호의 합, 즉 크기를 비교하므로 값을 정렬하면 문제를 좀 더 쉽게 풀 수 있다.
      N의 최대 범위가 15,000이므로 Ο(nlogn) 시간 복잡도 알고리즘을 사용해도 문제가 없다. 일반적으로 정렬 알고리즘의 시간 복잡도는 Ο(nlogn)이다.
      입력받은 N개의 재룟값을 정렬한 다음 양쪽 끝의 위치를 투 포인터로 지정해 문제에 접근해보자.
  - ### [2단계] 손으로 풀어보기
    1. 재료 데이터를 배열 A[N]에 저장한 후 오름차순 정렬한다.
    2. 투 포인터 i,j를 양쪽 끝에 위치시킨 후 문제의 조건에 적합한 포인터 이동 원칙을 활용해 탐색을 수행한다.
       - 투 포인터 이동 원칙
         - A[i] + A[j] > M : j--;    // 번호의 합이 M보다 크므로 큰 번호 index를 내린다.
         - A[i] + A[j] < M : i++;    // 번호의 합이 M보다 작으므로 작은 번호 index를 올린다.
         - A[i] + A[j] == M : count++; i++; j--;   // 양쪽 포인터를 모두 이동시키고 count를 증가시킨다.
    3. 2단계를 i와 j가 만날 때까지 반복한다. 반복이 끝나면 count를 출력한다.
  - ### [3단계] 슈도코드 작성하기
    ```java
    N(재료의 개수), M(갑옷이 되는 번호) 저장하기
    for (N만큼 반복) {
      재료 배열 저장하기
    }
    재료 배열 정렬하기
    while (i < j) {
      if (재료 합 < M) 작은 번호 재료를 한 칸 위로 변경하기
      else if (재료 합 > M) 큰 번호 재료를 한 칸 아래로 변경하기
      else 경우의 수 증가, 양쪽 index 각각 변경하기
    }
    count 출력하기
    ```
  - ### [4단계] 코드 구현하기
    - [exam007_주몽의명령](src/book/ch03/exam007_주몽의명령.java)
- ### [문제 008] : '좋은 수' 구하기 (2s)
  - ### 문제
    - 주어진 N개의 수에서 다른 두 수의 합으로 표현되는 수가 있다면 그 수를 '좋은 수'라고 한다. N개의 수 중 좋은 수가 총 몇 개인지 출력하시오.
  - ### 입력
    - 1번째 줄에 수의 개수 N(1≤N≤2,000), 2번째 줄에 N개의 수의 값(Ai)이 주어진다(|Ai|≤1,000,000,000, Ai는 정수).
  - ### 출력
    - 좋은 수의 개수를 출력한다.
  - ### 예제 입력1
    ```java
    10    // 수의 개수
    1 2 3 4 5 6 7 8 9 10
    ```
  - ### 예제 출력1
    ```java
    8
    ```
  - ### [1단계] 문제 분석하기
    - N의 개수가 최대 2,000이라 가정해도 좋은 수 하나를 찾는 알고리즘의 시간 복잡도는 N^2보다 작아야 한다.
      만약 시간 복잡도가 N^2인 알고리즘을 사용하면 최종 시간 복잡도는 N^3이 되어 제한 시간 안에 문제를 풀 수 없기 때문이다.
      따라서 좋은 수 하나를 찾는 알고리즘의 시간 복잡도는 최소 Ο(nlogn)이어야 한다. **정렬, 투 포인터** 알고리즘을 사용하면 된다.
      단, 정렬된 데이터에서 자기 자신을 좋은 수 만들기에 포함하면 안 된다. 이 점을 예외로 처리해야 한다는 것을 염두에 두고 문제에 접근해보자.
  - ### [2단계] 손으로 풀어보기
    1. 수를 입력받아 배열에 저장한 후 정렬한다.
    2. 투 포인터 i,j를 배열 A 양쪽 끝에 위치시키고 조건에 적합한 투 포인터 이동 원칙을 활용해 탐색을 수행한다. 판별의 대상이 되는 수는 K라고 가정한다.
       - 투 포인터 이동 원칙
         - A[i] + A[j] > K : j--; A[i] + A[j] < K : i++;
         - A[i] + A[j] == K : i++; j--; count++;
    3. 2단계를 배열의 모든 수에 대하여 반복한다. 즉, K가 N이 될 때까지 반복하며 좋은 수가 몇 개인지 센다.
  - ### [3단계] 슈도코드 작성하기
    ```java
    N (배열의 데이터 개수)
    A[N] 배열 선언
    for (N만큼 반복하기) {
      A 배열에 데이터 저장하기
    }
    A 배열 정렬하기
    for (N만큼 반복하기) {
      변수 초기화하기(찾고자 하는 값 K, 포인터 i, 포인터 j)
      while (i < j) {
        if (A[i] + A[j] == K)
          두 포인터 i,j가 k가 아닐 때 결괏값에 반영 및 while문 종료하기
          두 포인터 i,j가 k일 때 포인터 변경 및 계속 수행하기
        else if (A[i] + A[j] < K) 포인터 i 증가
        else 포인터 j 감소
      }
    }
    좋은 수의 개수 출력하기
    ```
  - ### [4단계] 코드 구현하기
    - [exam008_좋은수](src/book/ch03/exam008_좋은수.java)

# 4. 슬라이딩 윈도우
- 2개의 포인터로 범위를 지정한 다음 `범위(window)`를 **유지**한 채로 `이동(sliding)`하며 문제를 해결한다. 투 포인터 알고리즘과 매우 비슷하다.
- ### [문제 009] : DNA 비밀번호 (2s)
  - ### 문제
    - 평소 문자열을 이용해 노는 것을 좋아하는 민호는 DNA 문자열을 알게 됐다. DNA 문자열은 모든 문자열에 등장하는 문자가 {'A', 'C', 'G', 'T'}인 문자열을 말한다.
      예를 들어 "ACKA"는 DNA 문자열이 아니지만, "ACCA'는 DNA 문자열이다. 이런 신비한 문자열에 완전히 매료된 민호는 임의의 DNA 문자열을 만들고 만들어진 DNA 문자열의 부분 문자열을
      비밀번호로 사용하기로 마음먹었다.
      하지만 민호는 이 방법에는 문제가 있다는 것을 발견했다. 임의의 DNA 문자열의 부분 문자열을 뽑았을 때 "AAAA"와 같이 보안에 취약한 비밀번호가 만들어질 수 있기 때문이다.
      그래서 민호는 부분 문자열에서 등장하는 문자의 개수가 특정 개수 이상이어야 비밀번호로 사용할 수 있다는 규칙을 만들었다. 예를 들어 임의의 DNA 문자열이 "AAACCTGCCAA"이고,
      민호가 뽑은 부분 문자열의 길이를 4라고 가정해 보자. 그리고 부분 문자열에 'A'는 1개 이상, 'C'는 1개 이상, 'G'는 1개 이상, 'T'는 0개 이상 등장해야 비밀번호로 사용할 수 있다고
      가정해보자. 이때 "ACCT"는 'G'가 1개 이상 등장해야 한다는 조건을 만족하지 못해 비밀번호로 사용할 수 없지만, "GCCA"는 모든 조건을 만족하므로 비밀번호로 사용할 수 있다.
      민호가 만든 임의의 DNA 문자열과 비밀번호로 사용할 부분 문자열의 길이 그리고 {'A', 'C', 'G', 'T'}가 각각 몇 번 잇아 등장해야 비밀번호로 사용할 수 있는지, 순서대로 주어졌을 때
      민호가 만들 수 있는 비밀번호의 종류의 수를 구하는 프로그램을 작성하시오. 단, 부분 문자열이 등장하는 위치가 다르면 부분 문자열의 내용이 같더라도 다른 문자열로 취급한다.
  - ### 입력
    - 1번째 줄에 민호가 임의로 만든 DNA 문자열의 길이 |S|와 비밀번호로 사용할 부분 문자열의 길이 |P|가 주어진다(1<=|P|<=|S|<=1,000,000).
    - 2번째 줄에 민호가 임의로 만든 DNA 문자열이 주어진다.
    - 3번째 줄에 부분 문자열에 포함돼야 할 {'A', 'C', 'G', 'T'}의 최소 개수가 공백 문자를 사이에 두고 각각 주어진다. 각각의 수는 |S|보다 작거나 같은 음이 아닌 정수로 총합은 |S|보다 작거나 같다는 것이 보장된다.
  - ### 출력
    - 비밀번호 종류의 개수를 출력한다.
  - ### 예제 입력1
    ```java
    9 8          // DNA 문자열의 길이, 부분 문자열의 길이
    CCTGGATTG    // DNA 문자열
    2 0 1 1      // 부분 문자열에 포함돼야 할 A, C, G, T의 최소 개수
    ```
  - ### 예제 출력1
    ```java
    0
    ```
  - ### 예제 입력2
    ```java
    4 2
    GATA
    1 0 0 1
    ```
  - ### 예제 출력2
    ```java
    2
    ```
  - ### [1단계] 문제 분석하기
    - P와 S의 길이가 1,000,000으로 매우 크기 때문에 Ο(n)의 시간 복잡도 알고리즘으로 문제를 해결해야 한다. 이때 부분 문자열의 길이가 P이므로 슬라이딩 윈도우의 개념을
      이용하면 문제를 쉽게 해결할 수 있다.
      길이가 P인 윈도우를 지정하여 배열 S의 시작점에 놓은 후 윈도우를 오른쪽으로 밀면서 윈도우에 잡힌 값들이 조건에 맞는지 탐색한다. 마치 창틀에 창문을 놓고 이동하는 모양 같아서
      슬라이딩 윈도우라는 이름이 지어진 것이다. 배열 S의 길이만큼만 탐색을 진행하면 되므로 Ο(n)의 시간 복잡도로 문제를 해결할 수 있다.
  - ### [2단계] 손으로 풀어보기
    1. S 배열과 비밀번호 체크 배열을 저장한다.
    2. 윈도우에 포함된 문자로 현재 상태 배열을 만든다. 그런 다음 현재 상태 배열과 비밀번호 체크 배열을 비교하여 유효 비밀번호인지 판단한다.
    3. 윈도우를 한 칸씩 이동하며 현재 상태 배열을 업데이트한다. 현재 상태 배열을 업데이트한 이후에는 비밀번호 체크 배열과 비교하여 비밀번호 유효성을 판단한다.
       현재 상태 배열을 업데이트할 때는 빠지는 문자열, 신규 문자열만 보고 업데이트하는 방식으로 진행한다.
    - 이 문제는 슬라이딩 윈도우 원리 이외에도 '실제 문자열과 관련된 배열 처리를 어떻게 할 것인가?', '비밀번호 유효성 검사를 보다 빠르게 할 수 있는 방법이 있을까?' 등
      코드 레벨에서 고민이 필요한 부분이 있다.
  - ### [3단계] 슈도코드 작성하기
    ```java
    // 데이터 저장
    S(문자열 크기) P(부분 문자열 크기)
    A(문자열 데이터)
    checkArr(비밀번호 체크 배열)
    // 변수 선언
    myArr(현재 상태 배열)
    checkSecret(몇 개의 문자와 관련된 개수를 충족했는지 판단하는 변수)
    P 범위(0 ~ P-1)만큼 S 배열에 적용하고, 유효한 비밀번호인지 판단하기
    for (i를 P에서 S까지 반복) {
      j 선언 (i-P)
      // 이 부분은 함수로 별도 구현하기
      한 칸씩 이동하면서 제거되는 문자열과 새로 들어오는 문자열을 처리하기
      유효한 비밀번호인지(checkSecret == 4) 판단해 결괏값에 업데이트하기
    }
    결괏값 출력하기

    별도 함수
    Add(문자 더하기 함수) {
      새로 들어온 문자를 myArr에 업데이트하거나 checkSecret 값 변경하기
    }
    Remove(문자 빼기 함수) {
      제거되는 문자를 myArr에 업데이트하거나 checkSecret 값 변경하기
    }
    // *** 이 문제는 유효한 비밀번호를 검사할 때 기존 검사 결과에 새로 들어온 문자열, 제거되는 문자열만 반영하여 확인하는 것이 핵심 ***
    ```
  - ### [4단계] 코드 구현하기
    - [exam009_DNA비밀번호](src/book/ch03/exam009_DNA비밀번호.java)
- ### [문제 010] : 최솟값 찾기 (2.4s)
  - ### 문제
    - N개의 수 A1, A2, ..., AN이 주어진다. Ai-L+1 ~ Ai 중 최솟값을 Di라고 할 때 D에 저장된 수를 출력하는 프로그램을 작성하시오.
      이때 i≤0인 Ai는 무시하고 D를 구해야 한다.
  - ### 입력
    - 1번째 줄에 N과 L(1≤L≤N≤5,000,000), 2번째 줄에 N개의 수 Ai가 주어진다(-109≤Ai≤109).
  - ### 출력
    - 1번째 줄에 Di를 공백으로 구분해 순서대로 출력한다.
  - ### 예제 입력1
    ```java
    12 3  // 숫자의 개수, 슬라이딩 윈도우의 크기
    1 5 2 3 6 2 3 8 3 5 2 6
    ```
  - ### 예제 출력1
    ```java
    1 1 1 2 2 2 2 2 3 3 2 2
    ```
  - ### [1단계] 문제 분석하기
    - 일정 범위 안에서 최솟값을 구하는 문제이므로 슬라이딩 윈도우와 정렬을 사용한다고 가정하면, 윈도우의 크기는 문제에서 최솟값을 구하는 범위가 i-L+1부터 i까지이므로
      L로 생각하면 된다. 일반적으로 정렬은 nlog(n)의 시간 복잡도를 가지므로 N과 L의 최대 범위가 5,000,000인 이 문제에서는 정렬을 사용할 수 없다. 다시 말해 O(N)의 시간
      복잡도로 해결해야 한다. 하지만 슬라이딩 윈도우를 덱(deque)으로 구현하여 정렬 효과를 볼 수 있다.
      덱은 양 끝에서 데이터를 삽입하거나 삭제할 수 있는 자료구조로, 왼쪽에서는 addFirst(), removeFirst() 함수가 삽입, 삭제 역할을 하고 오른쪽에서는 addLast(), removeLast() 함수가 삽입, 삭제 역할을 한다.
  - ### [2단계] 손으로 풀어보기
    1. 덱에서는 (인덱스, 숫자) 형태의 노드를 클래스로 구현하여 저장한다.
    2. 새 노드가 저장될 때 뒤에서부터 비교를 시작한다. 새 노드의 숫자가 더 크거나 같을 때까지 덱에 있는 노드를 제거(removeLast)한다. 이후 탐색을 멈추고 덱에 저장(addLast)한다.
       결과를 보면 노드가 숫자 기준 오름차순 정렬되어 있다. 바로 이것이 덱을 이용하여 정렬 효과를 보는 방법이다.
    3. 새 노드를 추가했을 때, 인덱스 범위가 슬라이딩 윈도우 범위를 벗어날 경우 앞쪽의 노드를 제거한다.
    4. 최솟값은 덱의 맨 앞 노드의 숫자이다.
    5. 다시 정리하면 숫자 비교, 윈도우 범위 계산이 끝난 덱에서 맨 앞에 있는 노드의 숫자를 출력하기만 하면 정답이 된다.
  - ### [3단계] 슈도코드 작성하기
    ```java
    N(데이터 개수) L(최솟값을 구하는 범위)
    Deque<Node> mydeque (데이터를 담을 덱 자료구조)
    배열 선언하기

    for (N만큼 반복) {
      now(현재 데이터 값)
        덱의 마지막 위치에서부터 now보다 큰 값은 덱에서 제거하기
        덱의 마지막 위치에 now값 저장하기
        덱의 1번째 위치에서부터 L의 범위를 벗어난 값(now index - L >= index)을 덱에서 제거하기
        덱의 1번째 데이터 출력하기
    }

    덱에 저장할 노드 클래스 별도 생성하기
    노드 클래스에는 index(자신의 위치), value(자신의 값) 담
    ```
  - ### [4단계] 코드 구현하기
    - [exam010_최솟값찾기](src/book/ch03/exam010_최솟값찾기.java)

# 5. 스택과 큐
- 스택과 큐는 배열에서 발전된 형태의 자료구조이다. 스택과 큐는 구조는 비슷하지만 처리 방식은 다르다.
## (1) 스택과 큐의 핵심 이론
- ### 스택
  - 스택(stack)은 삽입과 삭제 연산이 `후입선출(LIFO: Last-in First-out)`로 이뤄지는 자료구조이다. 후입선출은 삽입과 삭제가 **한 쪽에서만** 일어나는 특징이 있다.
  - 스택 용어
    - **`top`** : 삽입과 삭제가 일어나는 위치를 뜻한다.
    - **`push`** : top 위치에 새로운 데이터를 삽입하는 연산이다.
    - **`pop`** : top 위치에 현재 있는 데이터를 삭제하고 확인하는 연산이다.
    - **`peek`** : top 위치에 현재 있는 데이터를 단순 확인하는 연산이다.
  - 스택은 **깊이 우선 탐색(DFS: Depth First Search)**, 백트래킹 종류의 코딩 테스트에 효과적이므로 반드시 알아 두어야 한다.
    후입선출은 개념 자체가 재귀 함수 알고리즘 원리와 일맥상통하다.
- ### 큐
  - 큐(queue)는 삽입과 삭제 연산이 `선입선출(FIFO: First-in First-out)로 이뤄지는 자료구조이다. 스택과 다르게 먼저 들어온 데이터가 먼저 나가고 삽입과 삭제가 **양방향에서** 이뤄진다.
  - 큐 용어
    - **`rear'** : 큐에서 가장 끝 데이터를 가리키는 영역이다.
    - **`front`** : 큐에서 가장 앞의 데이터를 가리키는 영역이다.
    - **`add`** : rear 부분에 새로운 데이터를 삽입하는 연산이다.
    - **`poll`** : front 부분에 있는 데이터를 삭제하고 확인하는 연산이다.
    - **`peek`** : 큐의 맨 앞(front)에 있는 데이터를 확인할 때 사용하는 연산이다.
  - 큐는 **너비 우선 탐색(BFS: Breadth First Search)** 에서 자주 사용하므로 이 역시도 스택과 함께 잘 알아두어야 하는 개념이다.
  - ### 우선순위 큐
    - 우선순위 큐((priority queue)는 값이 들어간 순서와 상관 없이 우선순위가 높은 데이터가 먼저 나오는 자료구조이다. 큐 설정에 따라 front에 항상 최댓값 또는 최솟값이 위치한다.
      우선순위 큐는 일반적으로 힙(heap)을 이용해 구현하는데 힙은 트리 종류 중 하나이다.
- ### [문제 011] : 스택으로 오름차순 수열 만들기 (2s)
  - ### 문제
    - 임의의 수열을 스택에 넣었다가 출력하는 방식으로 오름차순 수열을 출력할 수 있는지 확인하고,
      출력할 수 있다면 push와 pop 연산을 어떤 순서로 수행해야 하는지를 알아내는 프로그램을 작성해 보자.
  - ### 입력
    - 1번째 줄에 수열의 개수 n(1≤n≤100,000)이 주어진다. 2번째 줄에서 n개의 줄에는 수열을 이루는 1 이상 n 이하의 정수가 1개씩 순서대로 주어진다.
      이때 같은 정수가 두 번 이상 나오지는 않는다.
  - ### 출력
    - 오름차순 수열을 만들기 위한 연산 순서를 출력한다. push 연산은 +, pop 연산은 -로 출력하고, 불가능할 때는 NO를 출력한다.
  - ### 예제 입력1
    ```java
    8   // 수열의 개수
    4
    3
    6
    8
    7
    5
    2
    1
    ```
  - ### 예제 출력1
    ```java
    +
    +
    +
    +
    -
    -
    +
    +
    -
    +
    +
    -
    -
    -
    -
    -
    ```
  - ### 예제 입력2
    ```java
    5
    1
    2
    5
    3
    4
    ```
  - ### 예제 출력1
    ```java
    NO
    ```
  - ### [1단계] 문제 분석하기
    - 스택의 원리를 정확하게 알고 있는지를 묻는 문제이다. 이 문제는 스택의 pop, push 연산과 후입선출 개념을 이해하고 있다면 쉽게 풀 수 있다.
      스택에 넣는 값은 오름차순 정렬이어야 한다는 것에 유의해야 한다.
  - ### [2단계] 손으로 풀어보기
    - 이 문제는 1부터 자연수를 증가시키면서 입력으로 주어진 숫자와 비교하여 증가시킨 자연수를 스택에 추가하거나 빼는 방식으로 풀면 된다.
    - 스택 연산 수행 방법
      1. 현재 수열 값 ≥ 자연수
         - 현재 수열 값이 자연수보다 크거나 같을 때까지 자연수를 1씩 증가시키며 자연수를 스택에 push한다. 그리고 push가 끝나면 수열을 출력하기 위해 마지막 1회만 pop한다.
      2. 현재 수열 값 < 자연수
         - 현재 수열 값보다 자연수가 크다면 pop으로 스택에 있는 값을 꺼낸다. 꺼낸 값이 현재 수열 값이거나 아닐 수 있다. 만약 아니라면 후입선출 원리에 따라 수열을 표현할 수
           없으므로 NO를 출력한 후 문제를 종료하고, 현재 수열 값이라면 그대로 조건문을 빠져나온다.
  - ### [3단계] 슈도코드 작성하기
    ```java
    N(수열 개수)  A[](수열 배열)
    수열 배열 채우기
    for (N만큼 반복) {
      if (현재 수열 값 >= 오름차순 자연수) {
        while (값이 같아질 때까지) {
          push()
          (+) 저장
        }
        pop()
        (-) 저장
      }
      else (현재 수열 값 < 오름차순 자연수) {
        pop()
        if (스택 pop 결괏값 > 수열의 수) NO 출력
        else (-) 저장
      }
    }
    if (-값을 출력한 적이 없으면) 저장한 값 출력
    ```
  - ### [4단계] 코드 구현하기
    - [exam011_스택수열](src/book/ch03/exam011_스택수열.java)
- ### [문제 012] : 오큰수 구하기 (1s)
  - ### 문제
    - 크기가 N인 수열 A = A1, A2, ..., AN이 있다. 수열의 각 원소 Ai에 관련된 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중 가장 왼쪽에
      있는 수를 의미한다. 이러한 수가 없을 때 오큰수는 -1이다. 예를 들어 A = [3,5,2,7]일 때 NGE(1)=5, NGE(2)=7, NGE(3)=7, NGE(4)=-1이다.
      A = [9,5,4,8]일 경우에는 NGE(1)=-1, NGE(2)=8, NGE(3)=8, NGE(4)=-1이다.
  - ### 입력
    - 1번째 줄에 수열 A의 크기 N(1≤N≤1,000,000), 2번째 줄에 수열 A의 원소 A1, A2, ..., AN(1≤Ai≤1,000,000)이 주어진다.
  - ### 출력
    - 총 N개의 수 NGE(1), NGE(2), ..., NGE(N)을 공백으로 구분해 출력한다.
  - ### 예제 입력1
    ```java
    4   // 수열의 크기
    3 5 2 7
    ```
  - ### 예제 출력1
    ```java
    5 7 7 -1
    ```
  - ### 예제 입력2
    ```java
    4
    9 5 4 8
    ```
  - ### 예제 출력2
    ```java
    -1 8 8 -1
    ```
  - ### [1단계] 문제 분석하기
    - N의 최대 크기가 1,000,000이므로 반복문으로 오큰수를 찾으면 제한 시간을 초과한다.
    - 핵심 아이디어
      - 스택에 새로 들어오는 수가 top에 존재하는 수보다 크면 그 수는 오큰수가 된다.
      - 오큰수를 구한 후 수열에서 오큰수가 존재하지 않는 숫자에 -1을 출력해야 한다.
  - ### [2단계] 손으로 풀어보기
    - 정답 배열의 값을 모두 채운 후 출력하면 문제가 요구하는 답을 구할 수 있다.
    - 문제 푸는 순서
      1. 스택이 채워져 있거나 A[index] > A[top]인 경우 pop한 인덱스를 이용하여 정답 수열에 오큰수를 저장한다. pop은 조건을 만족하는 동안 계속 반복한다. 과정 1을 마치면 과정 2로 넘어간다.
      2. 현재 인덱스를 스택에 push하고 다음 인덱스로 넘어간다.
      3. 과정 1~2를 수열 길이만큼 반복한 후 현재 스택에 남아 있는 인덱스에 -1을 저장한다.
  - ### [3단계] 슈도코드 작성하기
    ```java
    N(수열 개수) A[](수열 배열) ans[](정답 배열)
    수열 배열 채우기
    최초 스택 초기화하기
    for (N만큼 반복) {
      while(스택이 비워있지 않고 현재 수열 값이 top에 해당하는 수열보다 클 때까지) {
        pop
        정답 배열에 오큰수를 현재 수열로 저장하기
      }
      현재 수열을 스택에 push
    }
    while (스택이 빌 때까지) {
      스택에 있는 인덱스의 정답 배열에 -1 저장하기
    }
    정답 배열 출력하기기
    ```
  - ### [4단계] 코드 구현하기
    - [exam012_오큰수](src/book/ch03/exam012_오큰수.java)
- ### [문제 013] : 카드 게임 (2s)
  - ### 문제
    - N장의 카드가 있다. 각각의 카드는 차례로 1에서 N가지의 번호가 붙어 있으며, 1번 카드가 가장 위, N번 카드가 가장 아래인 상태로 놓여 있다. 이제 다음과 같은 동작을
      카드가 1장 남을 때까지 반복한다.
      먼저 가장 위에 있는 카드를 바닥에 버린다. 그다음 가장 위에 있는 카드를 가장 아래에 있는 카드 밑으로 옮긴다.
      N이 주어졌을 때 가장 마지막에 남는 카드를 구하는 프로그램을 작성하시오.
  - ### 입력
    - 1번째 줄에 정수 N(1≤N≤500,000)이 주어진다.
  - ### 출력
    - 1번째 줄에 남는 카드의 번호를 출력한다.
  - ### 예제 입력1
    ```java
    6 // 카드의 개수
    ```
  - ### 예제 출력1
    ```java
    4
    ```
  - ### [1단계] 문제 분석하기
    - 큐를 잘 이해하고 있는지를 묻는 문제이다. 가장 위의 카드를 가장 아래에 있는 카드 밑으로 옮기는 동작은 큐의 선입선출 성질을 이용하면 쉽게 구현할 수 있다.
      카드의 개수의 최대가 500,000이므로 시간 복잡도의 제약도 크지 않다.
  - ### [2단계] 손으로 풀어보기
    1. poll을 수행하여 맨 앞의 카드를 버린다.
    2. 과정 1에 이어 바로 add를 수행해 맨 앞에 있는 카드를 가장 아래로 옮긴다.
    3. 큐의 크기가 1이 될 때 과정 1~2를 반복한 후 큐에 남은 원소를 출력한다.
  - ### [3단계] 슈도코드 작성하기
    ```java
    N(카드의 개수) myQueue(카드 저장 자료구조)
    for (카드의 개수만큼 반복) {
      큐에 카드 저장하기
    }
    while (카드가 1장 남을 때까지) {
      맨 위의 카드를 버림 : poll();
      맨 위의 카드를 가장 아래의 카드 밑으로 이동 : poll() -> add()
    }
    마지막으로 남은 카드 출력
    ```
  - ### [4단계] 코드 구현하기
    - [exam013_카드](src/book/ch03/exam013_카드.java)
- ### [문제 014] : 절댓값 힙 구현하기 (2s)
  - ### 문제
    - 절댓값 힙은 다음과 같은 연산을 지원하는 자료구조이다.
      1. 배열에 정수 x(x≠0)을 넣는다.
      2. 배열에서 절댓값이 가장 작은 값을 출력한 후 그 값을 배열에서 제거한다. 절댓값이 가장 작은 값이 여러 개일 경우에는 그중 가장 작은 수를 출력하고, 그 값을 배열에서 제거한다.
      프로그램은 처음에 비어 있는 배열에서 시작한다. 절댓값 힙을 구현하시오.
  - ### 입력
    - 1번째 줄에 연산의 개수 N(1≤N≤100,000)이 주어진다. 다음 N개의 줄에는 연산과 관련된 정보를 나타내는 정수 x가 주어진다. 만약 x가 0이 아니라면 배열에 x라는 값을 추가하고,
      x가 0이라면 배열에서 절댓값이 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다. 입력되는 정수는 -231보다 크고, 231보다 작다.
  - ### 출력
    - 입력에서 0이 주어진 횟수만큼 답을 출력한다. 만약 배열에 비어 있는데 절댓값이 가장 작은 값을 출력하라고 할 때는 0을 출력하면 된다.
  - ### 예제 입력1
    ```java
    18     // 연산의 개수
    1
    -1
    0
    0
    0
    1
    1
    -1
    -1
    2
    -2
    0
    0
    0
    0
    0
    0
    0
    ```
  - ### 예제 출력1
    ```java
    -1
    1
    0
    -1
    -1
    1
    1
    -2
    2
    0
    ```
  - ### [1단계] 문제 분석하기
    - N의 최대 범위가 100,000으로 O(nlogn) 시간 복잡도를 가진 알고리즘으로 풀 수 있다. 데이터를 새로 삽입할 때마다 절댓값과 관련된 정렬이 필요하므로 우선순위 큐로 문제를 쉽게 해결할 수 있다.
      단, 이 문제는 절댓값 정렬이 필요하므로 우선순위 큐의 정렬 기준을 직접 정의해야 한다. 예제의 절댓값이 같을 때는 음수를 우선하여 출력해야 하는 사실을 기억해야 한다.
  - ### [2단계] 손으로 풀어보기
    1. x = 0 일 때
       - 큐가 비어 있을 때는 0을 출력하고 비어 있지 않을 때는 절댓값이 최소인 값을 출력한다. 단, 절댓값이 같다면 음수를 우선하여 출력한다.
    2. x ≠ 0 일 때
       - add로 큐에 새로운 값을 추가하고 우선순위 큐 정렬 기준으로 자동 정렬한다.
  - ### [3단계] 슈도코드 작성하기
    ```java
    N(질의 요청 개수)
    우선순위 큐 선언
    - 절댓값 기준으로 정렬되도록 설정하기
    - 단, 절댓값이 같으면 음수 우선 정렬하기
    for (N만큼 반복) {
      요청이 0일 때 : 큐가 비어 있으면 0, 비어 있지 않으면 큐의 front 값 출력하기 (poll())
      요청이 0이 아닐 때 : 새로운 데이터를 우선순위 큐에 더하기 (add())
    }
    ```
  - ### [4단계] 코드 구현하기
    - [exam014_절댓값힙](src/book/ch03/exam014_절댓값힙.java)
