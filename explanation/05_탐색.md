# 탐색
<br/>

# 목차
1. [깊이 우선 탐색](#1-깊이-우선-탐색)
2. [너비 우선 탐색](#2-너비-우선-탐색)
3. [이진 탐색](#3-이진-탐색)
<br/>

# 1. 깊이 우선 탐색
- **`깊이 우선 탐색(DFS; depth-first search)`** 은 그래프 완전 탐색 기법 중 하나이다. 깊이 우선 탐색은 그래프의 시작 노드에서 출발하여 **탐색할 한 쪽 분기를 정하여
  최대 깊이까지 탐색**을 마친 후 다른 쪽 분기로 이동하여 다시 탐색을 수행하는 알고리즘이다.
  |기능|특징|시간 복잡도 (노드 수: V, 에지 수: E)|
  |:---|:---|:---|
  |그래프 완전 탐색|* 재귀 함수로 구현<br/>* 스택 자료구조 이용|O(V+E)|<br/>
  
  깊이 우선 탐색은 실제 구현 시 **`재귀 함수`** 를 이용하므로 **스택 오버플로(stack overflow)** 에 유의해야 한다. 깊이 우선 탐색을 응용하여 풀 수 있는 문제는 단절점 찾기,
  단절선 찾기, 사이클 찾기, 위상 정렬 등이 있다.
## (1) 깊이 우선 탐색의 핵심 이론
- DFS는 한 번 방문한 노드를 다시 방문하면 안 되므로 노드 방문 여부를 체크할 배열이 필요하며, 그래프는 인접 리스트로 표현한다. 그리고 DFS의 탐색 방식은 **후입선출** 특성을 가지므로
  `스택`을 사용하여 설명하기도 한다.
  - DFS 구현은 스택보다는 스택 성질을 갖는 재귀 함수로 많이 구현한다.
## (2) DFS 구현 순서
### 1. DFS를 시작할 노드를 정한 후 사용할 자료구조 초기화하기
- DFS를 위해 필요한 초기 작업은 인접 리스트로 그래프 표현하기, 방문 배열 초기화하기, 시작 노드 스택에 삽입하기이다.
### 2. 스택에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 스택에 삽입하기
  1. 스택에서 노드를 꺼내면서 탐색 순서에 꺼낸 노드 기록
  2. 대상 노드의 인접 노드를 스택에 삽입
  3. 노드를 삽입하며 방문 배열 체크
### 3. 스택 자료구조에 값이 없을 때까지 반복하기
- 앞선 과정을 스택 자료구조에 값이 없을 때까지 반복한다. 이때 이미 다녀간 노드는 **방문 배열을 바탕으로 재삽입하지 않는 것**이 핵심이다.
- 스택에 노드를 삽입할 때 방문 배열을 체크하고, 스택에서 노드를 뺄 때 탐색 순서에 기록하며 인접 노드를 방문 배열과 대조한 후 삽입한다.
### [문제 023] : 연결 요소의 개수 구하기 (3s)
  ### 문제
  - 방향 없는 그래프가 주어졌을 때 연결 요소(connected component)의 개수를 구하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 노드의 개수 N(1≤N≤1,000)과 에지의 개수 M(0≤M≤N⨯(N-1)/2), 2번째 줄부터 M개의 줄에 에지의 양끝 점 u와 v가 주어진다(1≤u,v≤N, u≠v). 같은 에지는 한 번만 주어진다.
  ### 출력
  - 1번째 줄에 연결 요소의 개수를 출력한다.
  ### 예제 입력1
  ```java
  6 5 // 노드 개수, 에지 개수
  1 2
  2 5
  5 1
  3 4
  4 6
  ```
  ### 예제 출력1
  ```java
  2
  ```
  ### 예제 입력2
  ```java
  6 8
  1 2
  2 5
  5 1
  3 4
  4 6
  5 4
  2 4
  2 3
  ```
  ### 예제 출력2
  ```java
  1
  ```
  ### [1단계] 문제 분석하기
  - 노드의 최대 개수가 1,000이므로 시간 복잡도 N^2 이하의 알고리즘을 모두 사용할 수 있다. 연결 요소는 에지로 연결된 노드의 집합이며, 한 번의 DFS가 끝날 때까지 탐색한
    모든 노드의 집합을 하나의 연결 요소로 판단할 수 있다.
  ### [2단계] 손으로 풀어보기
  1. 그래프를 인접 리스트로 저장하고 방문 배열도 초기화한다. 방향이 없는 그래프이기 때문에 양쪽 방향으로 에지를 모두 저장한다.
  2. 임의의 시작점에서 DFS를 수행한다.
  3. 아직 방문하지 않은 노드가 있을 경우 시작점을 다시 정해 탐색을 진행한다. 모든 노드를 방문한 후에는 전체 탐색을 종료한다.
  4. 1~3 과정을 통해 총 몇번의 DFS가 진행되었는지 출력한다. 즉, 연결 요소의 개수를 출력한다.
  - 만약 그래프가 모두 연결되어 있다면 DFS는 1번 실행되었을 것이다. 다시 말해 **모든 노드를 탐색하는 데 실행한 DFS의 실행 횟수가 곧 연결 요소 개수와 같다.**
  ### [3단계] 슈도코드 작성하기
  ```java
  n(노드 개수) m(에지 개수)
  A(그래프 데이터 저장 인접 리스트)
  visited(방문 기록 저장 배열)
  for (n의 개수만큼 반복하기) {
    A 인접 리스트의 각 ArrayList 초기화하기
  }
  for (m의 개수만큼 반복하기) {
    A 인접 리스트에 그래프 데이터 저장하기
  }
  for (n의 개수만큼 반복하기) {
    if (방문하지 않은 노드가 있으면) {
      연결 요소 개수++;
      DFS 실행하기
    }
  }
  // DFS 구현하기
  DFS {
    if (현재 노드 == 방문 노드) return;
    visited 배열에 현재 노드 방문 기록하기
    현재 노드의 연결 노드 중 방문하지 않은 노드로 DFS 실행하기 (재귀 함수 형태)
  }
  ```
  - 위의 슈도코드는 연결 리스트와 재귀 함수를 사용하였는데, **재귀 함수는 스택과 같은 방식으로 처리**되므로 스택을 사용한 방식과 같은 방식으로 구현한 것이라 할 수 있다.
  ### [4단계] 코드 구현하기
  - [exam023_연결요소의개수](src/book/ch05/exam023_연결요소의개수.java)
### [문제 024] : 신기한 소수 찾기 (2s)
  ### 문제
  - 수빈이가 세상에서 가장 좋아하는 것은 소수이고, 취미는 소수를 이용해 노는 것이다. 요즘 수빈이가 가장 관심 있어 하는 소수는 7331이다. 7331은 신기하게도 733도 소수,
    73도 소수, 7도 소수다. 즉, 왼쪽부터 1자리, 2자리, 3자리, 4자릿수 모두 소수다. 수빈이는 이런 숫자를 신기한 소수라고 이름 붙였다. 수빈이는 N의 자리의 숫자 중 어떤
    수들이 신기한 소수인지 궁금해졌다. 숫자 N이 주어졌을 때 N의 자리 숫자 중 신기한 소수를 모두 찾아보자.
  ### 입력
  - 1번째 줄에 N(1≤N≤8)이 주어진다.
  ### 출력
  - N의 자리 숫자 중 신기한 소수를 오름차순 정렬해 1줄에 1개씩 출력한다.
  ### 예제 입력1
  ```java
  4    // 자릿수 N
  ```
  ### 예제 출력1
  ```java
  2333
  2339
  2393
  2399
  2939
  3119
  3137
  3733
  3739
  3793
  3797
  5636
  7193
  7331
  7333
  7393
  ```
  ### [1단계] 문제 분석하기
  - 앞에서 언급했듯이 DFS는 재귀 함수의 형태를 띄고 있다. 여기서는 재귀 함수의 원리 설명과 함께 DFS를 풀어보자. 재귀 함수를 잘 이해하면 문제 조건에 맞도록 코드를 수정하기
    쉬울 것이다. 재귀 함수를 이용한 DFS 문제를 많이 풀어봐야 한다. 이 문제는 재귀 함수의 자릿수 개념을 붙여 구현한다. 또한 문제 조건에 맞도록 가지치기도 해야 한다.
  ### [2단계] 손으로 풀어보기
  - 소수는 약수가 1과 자기 자신인 수를 말한다. 소수 정의를 생각하며 문제를 풀어야 한다. <br/>
    우선 자릿수가 한 개인 소수는 2,3,5,7이므로 이 수부터 탐색을 시작한다. 4,6,8,9를 제외한 가지치기 방식을 적용한 것이다. 이어서 자릿수가 두 개인 현재 수 * 10 + a를 계산하여
    이 수가 소수인지 판단하고, 소수라면 재귀 함수로 자릿수를 하나 늘린다. 단, a가 짝수인 경우는 항상 2를 약수로 가지므로 가지치기로 a가 짝수인 경우를 제외한다.
    이런 방식으로 자릿수를 N까지 확장했을 때 그 값이 소수라면 해당 값을 출력한다. <br/>
    첫 탐색 배열, 중간 탐색 배열을 가지치기하여 시간 복잡도를 줄이고 중간 탐색 과정에서 소수가 아닌 경우 멈추는 가지치기도 포함한다. 소수를 판별하는 방법은 보통
    에라토스테네스의 체를 사용하지만 여기서는 단순한 소수 판별 함수를 사용해도 시간 안에 문제를 풀 수 있다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(자릿수)
  DFS 실행하기 (숫자 2,3,5,7로 탐색 시작)
  // DFS 구현하기
  DFS {
    if (자릿수 == N) {
      if (소수) 수 출력하기
      탐색 종료
    }
    for (1~9 반복하기) {
      if (뒤에 붙는 수가 홀수이면서 소수일 때)
      DFS 실행 : 자릿수 + 1, 수 * 10 + 뒤에 붙는 수
    }
  }
  // 소수 구하기 함수
  for ('2 ~ 현재 수 / 2' 반복하기) {
    if (나머지가 0이면) return 소수가 아님
  }
  return 소수임
  ```
  ### [4단계] 코드 구현하기
  - [exam024_신기한소수](src/book/ch05/exam024_신기한소수.java)
### [문제 025] : 친구 관계 파악하기 (2s)
  ### 문제
  - BOJ 알고리즘 캠프에는 총 N명이 참가하고 있다. 사람들은 0번부터 N-1번으로 번호가 매겨져 있고, 일부 사람들은 친구다. 오늘은 다음과 같은 친구 관계를 가진 사람
    A,B,C,D,E가 존재하는지 구해 보려고 한다.<br/>
    * A는 B와 친구다.
    * B는 C와 친구다.
    * C는 D와 친구다.
    * D는 E와 친구다.<br/>
    
    위와 같은 친구 관계가 존재하는지 여부를 구하는 프로그램을 작성하시오.    
  ### 입력
  - 1번째 줄에 사람의 수 N(5≤N≤2,000)과 친구 관계의 수 M(1≤M≤2,000), 2번째 줄부터 M개의 줄에 정수 a와 b가 주어진다. a와 b는 친구라는 뜻이다(0≤a,b≤N-1, a≠b).
    같은 친구 관계가 2번 이상 주어지지는 않는다.
  ### 출력
  - 문제의 조건에 맞는 A,B,C,D,E가 존재할 때 1, 없을 때 0을 출력한다.
  ### 예제 입력1
  ```java
  8 8
  1 7
  3 7
  4 7
  3 4
  4 6
  3 5
  0 4
  2 7
  ```
  ### 예제 출력1
  ```java
  1
  ```
  ### 예제 입력2
  ```java
  5 5
  0 1
  1 2
  2 3
  3 0
  1 4
  ```
  ### 예제 출력2
  ```java
  1
  ```
  ### 예제 입력3
  ```java
  6 5
  0 1
  0 2
  0 3
  0 4
  0 5
  ```
  ### 예제 출력3
  ```java
  0
  ```
  ### 예제 입력4
  ```java
  5 4    // 노드 개수, 에지 개수
  0 1
  1 2
  2 3
  3 4
  ```
  ### 예제 출력4
  ```java
  1
  ```
  ### [1단계] 문제 분석하기
  - N의 최대 범위가 2,000이므로 알고리즘의 시간 복잡도를 고려할 때 자유로운 편이다. 그리고 문제에서 요구하는 A,B,C,D,E의 관계는 재귀 함수의 형태와 비슷하다.
    주어진 모든 노드에 DFS를 수행하고 재귀의 깊이가 5 이상(5개의 노드가 재귀 형태로 연결)이면 1, 아니라면 0을 출력한다. DFS의 시간 복잡도는 O(V+E)이므로 최대 4,000,
    모든 노드를 진행했을 때 4,000*2,000, 즉, 8,000,000이므로 DFS를 사용해도 제한 시간 내에 문제를 풀 수 있다.
  ### [2단계] 손으로 풀어보기
  1. 그래프 데이터를 인접 리스트로 저장한다.
  2. 모든 노드에서 DFS를 수행한다. 수행할 때 재귀 호출마다 깊이를 더한다. 깊이가 5가 되면 1을 출력하고 프로그램을 종료한다.
  3. 모든 노드를 돌아도 1이 출력되지 않았다면 0을 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(노드 개수) M(에지 개수)
  A(그래프 데이터 저장 인접 리스트)
  visited(방문 기록 저장 배열)
  arrive(도착 확인 변수)
  for (N의 개수만큼 반복하기) {
    A 인접 리스트의 각 ArrayList 초기화하기
  }
  for (M의 개수만큼 반복하기) {
    A 인접 리스트에 그래프 데이터 저장하기
  }
  for (N의 개수만큼 반복하기) {
    각 노드마다 DFS 실행하기
    if(arrive) 반복문 종료   // depth가 5에 도달한 적이 있다면
  }
  if (arrive) 1 출력
  else 0 출력

  // DFS 구현하기
  DFS {
    if(깊이가 5 || arrive) {
      arrive = true;
      함수 종료
    }
    방문 배열에 현재 노드 방문 기록하기
    현재 노드의 연결 노드 중 방문하지 않은 노드로 DFS 실행하기(호출마다 depth는 1씩 증가)
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam025_친구관계파악하기](src/book/ch05/exam025_친구관계파악하기.java)

# 2. 너비 우선 탐색
- **`너비 우선 탐색(BFS; breadth-first search)`** 도 그래프를 완전 탐색하는 방법 중 하나로, 시작 노드에서 출발해 시작 노드를 기준으로 **가까운 노드를 먼저 방문**하면서
  탐색하는 알고리즘이다.
  
  |기능|특징|시간 복잡도 (노드 수: V, 에지 수: E)|
  |:---|:---|:---|
  |그래프 완전 탐색|* FIFO 탐색<br/>* Queue 자료구조 이용|O(V+E)|<br/>

  너비 우선 탐색은 **선입선출** 방식으로 탐색하므로 `큐`를 이용해 구현한다. 또한 너비 우선 탐색은 탐색 시작 노드와 가까운 노드를 우선하여 탐색하므로 목표 노드에 도착하는
  경로가 여러 개일 때 **최단 경로를 보장**한다.
## (1) 너비 우선 탐색의 핵심 이론
### 1. BFS를 시작할 노드를 정한 후 사용할 자료구조 초기화하기
  - BFS도 DFS와 마찬가지로 방문했던 노드는 다시 방문하지 않으므로 방문한 노드를 체크하기 위한 배열이 필요하다. 그래프를 인접 리스트로 표현하는 것 역시 DFS와 동일하다.
    하나 차이점이 있다면 탐색을 위해 스택이 아닌 큐를 사용한다는 점이다.
  - 인접 리스트, 방문 배열 초기화 && 큐 자료구조에 시작점 삽입
### 2. 큐에서 노드를 꺼낸 후 노드의 인접 노드를 다시 큐에 삽입하기
  1. 큐에서 노드를 꺼내면서 탐색 순서에 꺼낸 노드를 기록
  2. 대상 노드의 인접 노드를 큐에 삽입
  3. 노드를 삽입하며 방문 배열 체크
### 3. 큐 자료구조에 값이 없을 때까지 반복하기
  - 큐에 노드가 없을 때까지 앞선 과정을 반복한다. 선입선출 방식으로 탐색하므로 탐색 순서가 DFS와 다르다.
### [문제 026] : DFS와 BFS 프로그램 (2s)
  ### 문제
  - 그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 노드가 여러 개일 경우에는 노드 번호가 작은 것을 먼저 방문하고
    더 이상 방문할 수 있는 노드가 없을 때 종료한다. 노드 번호는 1에서 N까지다.
  ### 입력
  - 1번째 줄에 노드의 개수 N(1≤N≤1,000), 에지의 개수 M(1≤M≤10,000), 탐색을 시작할 노드의 번호 V가 주어진다. 그다음 M개의 줄에는 에지가 연결하는 두 노드의 번호가 주어진다.
    어떤 두 노드 사이에 여러 개의 에지가 있을 수 있다. 입력으로 주어지는 에지는 양방향이다.
  ### 출력
  - 1번째 줄에 DFS를 수행한 결과, 그다음 줄에 BFS를 수행한 결과를 출력한다. V부터 방문된 점을 순서대로 출력하면 된다.
  ### 예제 입력1
  ```java
  4 5 1    // 노드 개수, 에지 개수, 시작점
  1 2
  1 3
  1 4
  2 4
  3 4
  ```
  ### 예제 출력1
  ```java
  1 2 4 3
  1 2 3 4
  ```
  ### 예제 입력2
  ```java
  5 5 3
  5 4
  5 2
  1 2
  3 4
  3 1
  ```
  ### 예제 출력3
  ```java
  3 1 2 5 4
  3 1 4 2 5
  ```
  ### [1단계] 문제 분석하기
  - DFS와 BFS를 구현할 수 있는지 물어보는 기본 문제이다.
  ### [2단계] 손으로 풀어보기
  1. 인접 리스트에 그래프를 저장한다.
  2. DFS를 실행하면서 방문 배열 체크와 탐색 노드 기록을 수행한다. 문제 조건에서 작은 번호의 노드부터 탐색한다고 했으므로 인접 노드를 오름차순으로 정렬한 후 재귀 함수를
     호출한다.
  3. BFS도 같은 방식으로 진행한다. 노드를 오름차순으로 정렬하여 큐에 삽입한다.
  4. DFS와 BFS를 마쳤다면 각각 탐색하며 기록한 데이터를 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(노드 개수) M(에지 개수) Start(시작점)
  A(그래프 데이터 저장 인접 리스트) visited(방문 기록 저장 배열)
  for (N의 개수만큼 반복하기) {
    A 인접 리스트의 각 ArrayList 초기화하기
  }
  for (M의 개수만큼 반복하기) {
    A 인접 리스트에 그래프 데이터 저장하기
  }
  // 방문할 수 있는 노드가 여러 개일 경우에는 번호가 작은 것을 먼저 방문하기 위해 정렬하기
  for (N의 개수만큼 반복하기) {
    각 노드와 관련된 에지를 정렬하기
  }
  visited 배열 초기화하기
  DFS(Start) 실행하기
  visited 배열 초기화하기
  BFS(Start) 실행하기

  DFS {     // DFS 구현하기
    현재 노드를 출력하기
    visited 배열에 현재 노드 방문 기록하기
    현재 노드의 연결 노드 중 방문하지 않은 노드로 DFS 실행하기(재귀 함수 형태)
  }
  BFS {     // BFS 구현하기
    큐 자료구조에 시작 노드 삽입하기(add 연산)
    visited 배열에 현재 노드 방문 기록하기
    while (큐가 비어 있을 때까지) {
      큐에서 노드 데이터를 가져오기(poll 연산)
      가져온 노드 출력하기
      현재 노드의 연결 노드 중 미방문 노드를 큐에 삽입(add 연산)하고 방문 배열에 기록하기
    }
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam026_DFS와BFS](src/book/ch05/exam026_DFS와BFS.java)
### [문제 027] : 미로 탐색하기 (1s)
  ### 문제
  - N⨯M 크기의 미로의 각 칸에 들어 있는 숫자 중 1은 이동할 수 있는 칸, 0은 이동할 수 없는 칸을 나타낸다. 한 칸에서 다른 칸으로 이동할 때는 서로 인접한 칸으로만
    이동할 수 있다. 이동한 칸을 셀 때는 시작 위치와 도착 위치를 포함한다.
    N⨯M 크기의 미로가 주어질 때 (1,1)에서 출발해 (N,M)의 위치로 이동하기 위해 지나야 하는 칸 수의 최솟값을 구하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 두 정수 N,M(2≤N,M≤100), 그다음 N개의 줄에는 미로의 내용이 M개의 정수로 주어진다. 각각의 수들은 붙어서 입력된다.
  ### 출력
  - 1번째 줄에 지나야 하는 칸 수의 최솟값을 출력한다. 항상 도착 위치로 이동할 있을 때만 입력으로 주어진다.
  ### 예제 입력1
  ```java
  4 6   // N,M
  101111
  101010
  101011
  111011
  ```
  ### 예제 출력1
  ```java
  15
  ```
  ### 예제 입력2
  ```java
  4 6
  110110
  110110
  111111
  111101
  ```
  ### 예제 출력2
  ```java
  9
  ```
  ### 예제 입력3
  ```java
  2 25
  1011101110111011101110111
  1110111011101110111011101
  ```
  ### 예제 출력3
  ```java
  38
  ```
  ### 예제 입력4
  ```java
  7 7
  1011111
  1110001
  1000001
  1000001
  1000001
  1000001
  1111111
  ```
  ### 예제 출력4
  ```java
  13
  ```
  ### [1단계] 문제 분석하기
  - N,M의 최대 데이터의 크기가 100으로 매우 작기 때문에 시간 제한은 별도로 생각하지 않아도 되는 문제이다. 문제의 요구사항은 지나야 하는 칸 수의 최솟값을 찾는 것이다.
    이는 완전 탐색을 진행하며 몇 번째 깊이에서 원하는 값을 찾을 수 있는지를 구하는 것과 동일하다. 따라서 BFS를 사용해 최초로 도달했을 때 깊이를 출력하면 문제를 해결할 수 있다
    DFS보다 BFS가 적합한 이유는 BFS는 해당 깊이에서 갈 수 있는 노드 탐색을 마친 후 다음 깊이로 넘어가기 때문이다.
  ### [2단계] 손으로 풀어보기
  - 먼저 2차원 배열에 데이터를 저장한 다음 (1,1)에서 BFS를 실행한다. 상, 하, 좌, 우 네 방향을 보며 인접한 칸을 본다. 인접한 칸의 숫자가 1이면서 아직 방문하지 않았다면
    큐에 삽입한다. 종료 지점 (N,M)에서 BFS를 종료하며 깊이를 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  dx, dy (상하좌우를 탐색하기 위한 default값 정의 변수)
  A(데이터 저장 2차원 행렬)
  N(row) M(column)
  visited(방문 기록 저장 배열)
  A 배열 초기화하기
  visited 배열 초기화하기
  for (N의 개수만큼 반복하기) {
    for (M의 개수만큼 반복하기) {
      A 배열에 데이터 저장하기
    }
  }
  BFS(0,0) 실행하기
  BFS {    // BFS 구현하기
    큐 자료구조에 시작 노드 삽입하기(add 연산)
    visited 배열에 현재 노드 방문 기록하기
    while (큐가 비어 있을 때까지) {
      큐에서 노드 데이터를 가져오기(poll 연산)
      for (상하좌우 탐색) {
        if (유효한 좌표) {
          if (이동할 수 있는 칸이면서 방문하지 않은 노드) {
            visited 배열에 방문 기록하기
            A 배열에 depth를 현재 노드의 depth + 1로 업데이트하기
            큐에 데이터 삽입하기(add 연산)
          }
        }
      }
    }
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam027_미로탐색](src/book/ch05/exam027_미로탐색.java)
### [문제 028] : 트리의 지름 구하기 (2s)
  ### 문제
  - 트리의 지름은 트리를 구성하는 노드 중 두 노드 사이의 거리가 가장 긴 것을 말한다. 트리의 지름을 구하시오.
  ### 입력
  - 1번째 줄에서는 트리의 노드 개수 V(2≤V≤100,000), 2번째 줄부터 V개의 줄에 걸쳐 에지의 정보가 주어진다. 먼저 노드 번호가 주어지고, 그다음으로 연결된 에지의 정보를
    의미하는 정수가 2개씩(연결된 노드 번호, 거리) 주어진다. 거리는 10,000 이하의 자연수다.<br/>
    예를 들어 2번째 줄에 3 1 2 4 3 -1이 주어질 때 노드 3은 노드 1과 거리가 2인 에지로 연결돼 있고, 노드 4는 거리가 3인 에지로 연결돼 있다는 뜻이다. -1은 더이상 노드가
    없으므로 종료한다는 의미다.
  ### 출력
  - 트리의 지름을 출력한다.
  ### 예제 입력1
  ```java
  5   // 노드 개수
  1 3 2 -1
  2 4 4 -1
  3 1 2 4 3 -1
  4 2 4 3 3 5 6 -1
  5 4 6 -1
  ```
  ### 예제 출력1
  ```java
  11
  ```
  ### [1단계] 문제 분석하기
  - 가장 긴 경로를 찾는 방법과 관련된 아이디어가 필요한 문제이다. 아이디어는 다음과 같다.
    - 임의의 노드에서 **가장 긴 경로로 연결돼 있는 노드**는 **트리의 지름에 해당하는 두 노드 중 하나**다.
  ### [2단계] 손으로 풀어보기
  1. 그래프를 인접 리스트로 저장한다. 이때 (노드, 가중치)를 표현하기 위해 노드는 클래스로 선언한다.
  2. 임의의 노드에서 BFS를 수행하고 탐색할 때 각 방문 노드의 거리를 배열에 저장한다. (현재 노드의 거리 + 에지 길이)
  3. 과정 2에서 얻은 배열에서 임의의 노드와 가장 먼 노드를 찾는다. 그런 다음 그 노드부터 BFS를 다시 수행한다. 이와 마찬가지로 탐색할 때 각 노드의 거리를 배열에 저장한다.
  4. 과정 3에서 배열에 저장한 값 중 가장 큰 값을 이 트리의 지름으로 출력한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(노드 개수) A(그래프 데이터 저장 인접 리스트)  // ArrayList<Edge>[] 형태로 선언
  visited(방문 기록 저장 배열) distance(거리 저장 배열)
  for (N의 개수만큼 반복하기) {
    A 인접 리스트의 각 ArrayList 초기화하기
  }
  for (M의 개수만큼 반복하기) {
    A 인접 리스트에 그래프 데이터 저장하기
  }
  visited 배열 초기화하기
  distance 배열 초기화하기
  BFS(임의의 점을 시작점으로) 실행하기
  distance 배열에서 가장 큰 값을 지니고 있는 노드를 시작점으로 지정하기
  visited 배열 초기화하기
  distance 배열 초기화하기
  BFS(새로운 시작점으로) 실행하기
  distance 배열에서 가장 큰 수를 정답으로 출력하기
  BFS {     // BFS 구현하기
    큐 자료구조에 시작 노드 삽압하기(add 연산)
    visited 배열에 현재 노드 방문 기록하기
    while (큐가 비어 있을 때까지) {
      큐에서 노드 데이터를 가져오기(poll 연산)
      가져온 노드 출력하기
      현재 노드의 연결 노드 중 방문하지 않은 노드로
      큐에 데이터 삽입(add 연산)하고 visited 배열에 방문 기록하기
      && 현재 노드의 거리 + 에지의 가중치로 방문하지 않은 노드 거리 배열 업데이트하기
    }
  }
  Edge {   // 에지 클래스 별도 구현하기
    e(목적지 노드), value(에지의 가중치)
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam028_트리의지름](src/book/ch05/exam028_트리의지름.java)

# 3. 이진 탐색
- **`이진 탐색(binary search)`** 은 **데이터가 정렬돼 있는 상태**에서 원하는 값을 찾아내는 알고리즘이다. 대상 데이터의 **중앙값**과 찾고자 하는 값을 비교해 **데이터의 크기를
  절반씩 줄이면서** 대상을 찾는다.
  
  |기능|특징|시간 복잡도|
  |:---|:---|:---|
  |타깃 데이터 탐색|중앙값 비교를 통한 대상 축소 방식|O(logN)

  이진 탐색은 정렬 데이터에서 원하는 데이터를 탐색할 때 사용하는 가장 일반적인 알고리즘이다. 구현 및 원리가 비교적 간단한 편으로 많은 코딩 테스트에서 부분 문제로 요구하는
  영역이다.
## (1) 이진 탐색 과정
1. 현재 데이터셋의 중앙값(median)을 선택한다.
2. 중앙값 > 타깃 데이터(target data)일 때 중앙값 기준으로 왼쪽 데이터셋을 선택한다.
3. 중앙값 < 타깃 데이터(target data)일 때 중앙값 기준으로 오른쪽 데이터셋을 선택한다.
4. 과정 1~3을 반복하다가 중앙값 == 타깃 데이터일 때 탐색을 종료한다.
- 이진 탐색을 사용하면 N개의 데이터에서 log(N)번의 연산으로 원하는 데이터의 위치를 찾을 수 있다. 다만 이진 탐색은 데이터가 정렬되어 있어야 한다는 전제가 있어야 한다.
- 위의 경우는 오름차순 정렬이고, 내림차순의 경우 조건을 반대로 하여 과정을 반복하면 된다.
### [문제 029] : 원하는 정수 찾기 (2s)
  ### 문제
  - N개의 정수 A[1], A[2], ..., A[N]이 주어져 있을 때 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 자연수 N(1≤N≤100,000), 그다음 줄에 N개의 정수 A[1], A[2], ..., A[N]이 주어진다. 그다음 줄에 M(1≤M≤100,000), 그다음 줄에 M개의 수들이 주어지는데,
    이 수들이 A 안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -231보다 크거나 같고, 231보다는 작다.
  ### 출력
  - M개의 줄에 답을 출력한다. 존재하면 1, 존재하지 않으면 0을 출력한다.
  ### 예제 입력1
  ```java
  5   // 데이터 개수
  4 1 5 2 3
  5   // 찾아야 할 숫자 개수
  1 3 7 9 5
  ```
  ### 예제 출력1
  ```java
  1
  1
  0
  0
  1
  ```
  ### [1단계] 문제 분석하기
  - N의 최대 범위가 100,000이므로 단순 반복문으로는 이 문제를 풀 수 없다. 이진 탐색을 적용하면 O(nlogn) 시간 복잡도로 해결할 수 있으므로 이진 탐색을 적용하도록 하자.
    앞에서 언급했듯이 이진 탐색은 정렬을 가정하므로 정렬 함수도 사용한다.
    - 자바의 기본 정렬은 O(nlogn)의 시간 복잡도를 가지므로 정렬을 수행해도 제한 시간을 초과하지 않는다.
  ### [2단계] 손으로 풀어보기
  1. 탐색 데이터를 1차원 배열에 저장한 다음 저장된 배열을 정렬한다.
  2. X라는 정수가 존재하는지 이진 탐색을 사용해 확인한다.
  ### [3단계] 슈도코드 작성하기
  ```java
  N(정렬할 수 개수) M(탐색할 숫자의 개수)
  A(정렬할 배열 선언하기)
  for (N의 개수만큼 반복하기) {
    A 배열 저장하기
  }
  A 배열 정렬하기
  for (M의 개수만큼 반복하기) {
    target(찾아야 하는 수) {
      // 이진 탐색 시작
      start(시작 인덱스),
      end(종료 인덱스)
        while(시작 인덱스 <= 종료 인덱스) {
          midi(중간 인덱스)
          if (중앙값 > target) {
            종료 인덱스 = 중간 인덱스 - 1
          else if (중앙값 < target) {
            시작 인덱스 = 중간 인덱스 + 1
          } else {
            찾았으므로 반복문 종료
          }
    if (찾았음) 1 출력
    else 0 출력
  }
  ```
  ### [4단계] 코드 구현하기
  - [exam029_원하는정수찾기](src/book/ch05/exam029_원하는정수찾기.java)
### [문제 030] : 블루레이 만들기 (2s)
  ### 문제
  - 강토는 자신의 기타 레슨 동영상을 블루레이로 만들어 판매하려고 한다. 블루레이에는 총 N개의 레슨이 들어가는데, 블루레이를 녹화할 때 레슨의 순서가 바뀌면 안 된다.
    순서가 뒤바뀔 때는 레슨의 흐름이 끊겨 학생들이 혼란에 빠질 수 있기 때문이다. 즉, i,j번 레슨을 같은 블루레이에 녹화하려면 i와 j 사이의 모든 레슨도 같은 블루레이에 녹화해야 한다.<br/>
    강토는 이 블루레이가 얼마나 팔릴지 아직 알 수 없어 제작 개수를 가급적 줄이려고 한다. 강토는 고민 끝에 M개의 블루레이에 모든 기타 레슨 동영상을 녹화하기로 했다.
    이때 블루레이의 크기(녹화할 수 있는 길이)는 최소, M개의 블루레이는 모두 같은 크기로 만들려고 한다.<br/>
    강토의 각 레슨의 길이가 분 단위(자연수)로 주어질 때 가능한 블루레이의 크기 중 최솟값을 구하는 프로그램을 작성하시오.
  ### 입력
  - 1번째 줄에 레슨의 수 N(1≤N≤100,000)과 M(1≤M≤N), 2번째 줄에 강토의 기타 레슨의 길이가 레슨 순서대로 분 단위(자연수)로 주어진다. 각 레슨의 길이는 10,000분을 넘지 않는다.
  ### 출력
  - 1번째 줄에 블루레이 크기 중 최솟값을 출력한다.
  ### 예제 입력1
  ```java
  9 3   // 레슨 수, 블루레이 개수
  1 2 3 4 5 6 7 8 9
  ```
  ### 예제 출력1
  ```java
  17
  ```
  ### [1단계] 문제 분석하기
  - 블루레이의 크기가 모두 같고 녹화 순서가 바뀌지 않아야 함이라는 문제 조건이 이진 탐색 알고리즘을 선택하게 하는 실마리이다. 블루레이에 첫 레슨부터 마지막 레슨까지
    차례대로 저장하다 보면 지정한 블루레이 크기로 모든 레슨을 저장할 수 있는지 판단할 수 있기 때문이다. 모두 저장할 수 있다면 블루레이 크기를 줄이고 저장할 수 없다면
    블루레이 크기를 늘리는 방식으로 블루레이 크기의 최솟값을 알 수 있다.
  ### [2단계] 손으로 풀어보기
  1. 이진 탐색의 시작 인덱스는 최대 길이의 레슨이고 종료 인덱스는 모든 레슨 길이의 합이다.
  2. 이진 탐색을 다음과 같이 수행한다. 이진 탐색은 시작 인덱스 > 종료 인덱스일 때까지 수행한다.
     - 중앙값 크기로 모든 레슨을 저장할 수 있으면 종료 인덱스 = 중간 인덱스 - 1     // 왼쪽 데이터셋
     - 중앙값 크기로 모든 레슨을 저장할 수 없으면 시작 인덱스 = 중간 인덱스 + 1     // 오른쪽 데이터셋
  ### [3단계] 슈도코드 작성하기
  ```java
  N(레슨 개수) M(블루레이 개수)
  A(정렬할 배열 선언하기)
  for (N의 개수만큼 반복하기) {
    A 배열 저장하기
    - 시작 인덱스 저장(A 배열 중 최댓값)
    - 종료 인덱스 저장(A 배열의 총합)
  }
  start(시작 인덱스),
  end(종료 인덱스)
  while(시작 인덱스 <= 종료 인덱스) {
    middle(중간 인덱스)
    sum(레슨 합)
    count(현재 사용한 블루레이 개수)
    for (N의 개수만큼 반복하기) {
      만약 sum + 현재 레슨 시간 > 중간 인덱스 이면
      count값을 올리고 sum을 0으로 리셋하기
      // 현재 블루레이에 저장할 수 없어 새로운 블루레이로 교체한다는 의미
      sum에 현재 레슨 시간값 더하기
    }
    sum이 0이 아니면 마지막 블루레이가 필요하므로 count값 올리기
    if (count > M : 중간 인덱스값으로 모든 레슨 저장 불가능) 시작 인덱스 = 중앙 인덱스 + 1
    else (중간 인덱스값으로 모든 레슨 저장 가능) 종료 인덱스 = 중앙 인덱스 - 1
  }
  시작 인덱스 출력하기
  ```
  ### [4단계] 코드 구현하기
  - [exam030_블루레이](src/book/ch05/exam030_블루레이.java)
### [문제 031] : 배열에서 K번째 수 찾기 (2s)
  ### 문제
  - 세준이는 크기가 N⨯N인 배열 A를 만들었다. 배열에 들어 있는 수는 A[i][j] = i⨯j이다. 이 수를 1차원 배열 B에 넣으면 B의 크기는 N⨯N이 된다. B를 오름차순 정렬했을 때
    B[k]를 구하라(배열 A와 B의 인덱스는 1부터 시작한다).
  ### 입력
  - 1번째 줄에 배열의 크기 N이 주어진다. N은 10^5보다 작거나 같은 자연수다. 2번째 줄에 k가 주어진다. k는 min(10^9, N^2)보다 작거나 같은 자연수다.
  ### 출력
  - B[k]를 출력한다.
  ### 예제 입력1
  ```java
  3
  7
  ```
  ### 예제 출력1
  ```java
  6
  ```
  ### [1단계] 문제 분석하기
  - k의 범위가 1 ~ min(10^9, N^2)이므로 시간 복잡도가 N^2인 알고리즘은 사용할 수 없다. 여기서는 이진 탐색을 사용한다. 이진 탐색으로 중앙값보다 작은 수의 개수를 세면서
    범위를 절발씩 줄이는 방법으로 B[k]값을 구한다. 다시 말해 작은 수의 개수가 k-1개인 중앙값이 정답이다. 작은 수의 개수를 세는 아이디어가 이 문제를 푸는 열쇠이다.
  ### [2단계] 손으로 풀어보기
  - 2차원 배열은 N행이 N의 배수로 구성되어 있으므로 2차원 배열에서의 k번째 수는 k를 넘지 않는다. 다시 말해 2차원 배열의 1~k번째 안에 정답이 있다. 이점에 주목하여 이진
    탐색의 시작 인덱스를 1, 종료 인덱스를 k로 정한다.<br/>
    중앙값보다 작거나 같은 수의 개수는 중앙값을 N으로 나눈 값이다. 단, 나눈 값이 N보다 크면 N으로 정한다.(Math.min(middle/i, N))<br/>
    중앙값보다 작은 수의 개수가 k보다 작으면 시작 인덱스를 중앙값 + 1, 중앙값보다 작은 수의 개수가 k보다 크거나 같으면 종료 인덱스를 중앙값 - 1로 하면서 정답을 중앙값으로
    업데이트하며 시작 인덱스가 종료 인덱스보다 커질 때까지 이진 탐색을 진행한다.
    - 중앙값 크기보다 작은 수가 K보다 작으면 시작 인덱스 = 중앙값 + 1
    - 중앙값 크기보다 작은 수가 K보다 크거나 같으면 종료 인덱스 = 중앙값 - 1 && 정답 변수 = 중앙값    
  ### [3단계] 슈도코드 작성하기
  ```java
  N(배열의 크기) K(구하고자 하는 index)
  start(시작 인덱스 = 1)
  end(종료 인덱스= K)
  while (시작 인덱스 <= 종료 인덱스) {    // 이진 탐색 수행하기
    middle (중간 인덱스)
    cnt (중앙값보다 작은 수)
    // 중앙값보다 작은 수는 몇 개인지 계산하기
    for (N의 개수만큼 반복하기) {
      cnt에 중앙 인덱스를 i로 나눈 값과 N 중 작은 값을 더함
    }
    if (cnt < K : 현재 중앙값보다 작은 수의 개수가 K보다 작음)
      시작 인덱스 = 중앙 인덱스 + 1
    else (현재 중앙값보다 작은 수의 개수가 K보다 크거나 같음)
      종료 인덱스 = 중앙 인덱스 - 1
      정답 변수에 중앙값 저장
  }
  정답 출력
  ```
  ### [4단계] 코드 구현하기
  - [exam031_K번째수](src/book/ch05/exam031_K번째수.java)
